import {
  markdown
} from "./chunk-DKA5WT22.js";
import "./chunk-4FHZTDMT.js";
import "./chunk-O5GZAYIU.js";
import "./chunk-7JJZCWT5.js";
import {
  autocompletion,
  closeBrackets,
  closeBracketsKeymap,
  completionKeymap
} from "./chunk-3Y22YXFU.js";
import {
  Annotation,
  ChangeDesc,
  ChangeSet,
  CharCategory,
  Compartment,
  Decoration,
  Direction,
  EditorSelection,
  EditorState,
  EditorView,
  Facet,
  GutterMarker,
  HighlightStyle,
  IndentContext,
  LanguageDescription,
  LanguageSupport,
  NodeProp,
  Prec,
  RangeSet,
  RangeSetBuilder,
  StateEffect,
  StateField,
  StreamLanguage,
  Text,
  Transaction,
  ViewPlugin,
  WidgetType,
  bracketMatching,
  codePointAt,
  codePointSize,
  combineConfig,
  countColumn,
  crosshairCursor,
  defaultHighlightStyle,
  drawSelection,
  dropCursor,
  findClusterBreak,
  foldGutter,
  foldKeymap,
  fromCodePoint,
  getIndentUnit,
  getIndentation,
  getPanel,
  gutter,
  highlightActiveLine,
  highlightActiveLineGutter,
  highlightSpecialChars,
  hoverTooltip,
  indentOnInput,
  indentString,
  indentUnit,
  keymap,
  lineNumbers,
  logException,
  matchBrackets,
  placeholder,
  rectangularSelection,
  runScopeHandlers,
  showPanel,
  showTooltip,
  syntaxHighlighting,
  syntaxTree,
  tags
} from "./chunk-PGWBGNL6.js";
import "./chunk-M6XIBDLP.js";
import {
  Fragment,
  cloneVNode,
  computed,
  createVNode,
  defineComponent,
  h,
  inject,
  isVNode,
  nextTick,
  onBeforeUnmount,
  onMounted,
  provide,
  reactive,
  ref,
  shallowRef,
  toRef,
  watch
} from "./chunk-M6T4IMAK.js";
import {
  require_markdown_it
} from "./chunk-YZGAROU5.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField,
  __toESM
} from "./chunk-7REXU52E.js";

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i4 = 0; i4 < selection.rangeCount; i4++) {
        ranges.push(selection.getRangeAt(i4));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy(text, options) {
      var debug, message, reselectPrevious, range, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e4) {
          e4.stopPropagation();
          if (options.format) {
            e4.preventDefault();
            if (typeof e4.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text);
            } else {
              e4.clipboardData.clearData();
              e4.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e4.preventDefault();
            options.onCopy(e4.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy;
  }
});

// node_modules/markdown-it-task-lists/index.js
var require_markdown_it_task_lists = __commonJS({
  "node_modules/markdown-it-task-lists/index.js"(exports, module) {
    var disableCheckboxes = true;
    var useLabelWrapper = false;
    var useLabelAfter = false;
    module.exports = function(md, options) {
      if (options) {
        disableCheckboxes = !options.enabled;
        useLabelWrapper = !!options.label;
        useLabelAfter = !!options.labelAfter;
      }
      md.core.ruler.after("inline", "github-task-lists", function(state) {
        var tokens = state.tokens;
        for (var i4 = 2; i4 < tokens.length; i4++) {
          if (isTodoItem(tokens, i4)) {
            todoify(tokens[i4], state.Token);
            attrSet(tokens[i4 - 2], "class", "task-list-item" + (!disableCheckboxes ? " enabled" : ""));
            attrSet(tokens[parentToken(tokens, i4 - 2)], "class", "contains-task-list");
          }
        }
      });
    };
    function attrSet(token, name, value) {
      var index = token.attrIndex(name);
      var attr = [name, value];
      if (index < 0) {
        token.attrPush(attr);
      } else {
        token.attrs[index] = attr;
      }
    }
    function parentToken(tokens, index) {
      var targetLevel = tokens[index].level - 1;
      for (var i4 = index - 1; i4 >= 0; i4--) {
        if (tokens[i4].level === targetLevel) {
          return i4;
        }
      }
      return -1;
    }
    function isTodoItem(tokens, index) {
      return isInline(tokens[index]) && isParagraph(tokens[index - 1]) && isListItem(tokens[index - 2]) && startsWithTodoMarkdown(tokens[index]);
    }
    function todoify(token, TokenConstructor) {
      token.children.unshift(makeCheckbox(token, TokenConstructor));
      token.children[1].content = token.children[1].content.slice(3);
      token.content = token.content.slice(3);
      if (useLabelWrapper) {
        if (useLabelAfter) {
          token.children.pop();
          var id = "task-item-" + Math.ceil(Math.random() * (1e4 * 1e3) - 1e3);
          token.children[0].content = token.children[0].content.slice(0, -1) + ' id="' + id + '">';
          token.children.push(afterLabel(token.content, id, TokenConstructor));
        } else {
          token.children.unshift(beginLabel(TokenConstructor));
          token.children.push(endLabel(TokenConstructor));
        }
      }
    }
    function makeCheckbox(token, TokenConstructor) {
      var checkbox = new TokenConstructor("html_inline", "", 0);
      var disabledAttr = disableCheckboxes ? ' disabled="" ' : "";
      if (token.content.indexOf("[ ] ") === 0) {
        checkbox.content = '<input class="task-list-item-checkbox"' + disabledAttr + 'type="checkbox">';
      } else if (token.content.indexOf("[x] ") === 0 || token.content.indexOf("[X] ") === 0) {
        checkbox.content = '<input class="task-list-item-checkbox" checked=""' + disabledAttr + 'type="checkbox">';
      }
      return checkbox;
    }
    function beginLabel(TokenConstructor) {
      var token = new TokenConstructor("html_inline", "", 0);
      token.content = "<label>";
      return token;
    }
    function endLabel(TokenConstructor) {
      var token = new TokenConstructor("html_inline", "", 0);
      token.content = "</label>";
      return token;
    }
    function afterLabel(content, id, TokenConstructor) {
      var token = new TokenConstructor("html_inline", "", 0);
      token.content = '<label class="task-list-item-label" for="' + id + '">' + content + "</label>";
      token.attrs = [{ for: id }];
      return token;
    }
    function isInline(token) {
      return token.type === "inline";
    }
    function isParagraph(token) {
      return token.type === "paragraph_open";
    }
    function isListItem(token) {
      return token.type === "list_item_open";
    }
    function startsWithTodoMarkdown(token) {
      return token.content.indexOf("[ ] ") === 0 || token.content.indexOf("[x] ") === 0 || token.content.indexOf("[X] ") === 0;
    }
  }
});

// node_modules/md-editor-v3/lib/es/chunks/config.mjs
var a = "md-editor";
var o = "md-editor-v3";
var r = "https://at.alicdn.com/t/c/font_2605852_prouiefeic.js";
var n = "https://at.alicdn.com/t/c/font_2605852_prouiefeic.css";
var e = "https://cdnjs.cloudflare.com/ajax/libs";
var c = `${e}/highlight.js/11.7.0/highlight.min.js`;
var d = {
  main: `${e}/prettier/2.8.0/standalone.js`,
  markdown: `${e}/prettier/2.8.0/parser-markdown.js`
};
var h2 = {
  css: `${e}/cropperjs/1.5.13/cropper.min.css`,
  js: `${e}/cropperjs/1.5.13/cropper.min.js`
};
var g = `${e}/screenfull.js/5.2.0/screenfull.min.js`;
var m = [
  "bold",
  "underline",
  "italic",
  "strikeThrough",
  "-",
  "title",
  "sub",
  "sup",
  "quote",
  "unorderedList",
  "orderedList",
  "task",
  "-",
  "codeRow",
  "code",
  "link",
  "image",
  "table",
  "mermaid",
  "katex",
  "-",
  "revoke",
  "next",
  "save",
  "=",
  "prettier",
  "pageFullscreen",
  "fullscreen",
  "preview",
  "htmlPreview",
  "catalog",
  "github"
];
var p = ["markdownTotal", "=", "scrollSwitch"];
var u = {
  "zh-CN": {
    toolbarTips: {
      bold: "加粗",
      underline: "下划线",
      italic: "斜体",
      strikeThrough: "删除线",
      title: "标题",
      sub: "下标",
      sup: "上标",
      quote: "引用",
      unorderedList: "无序列表",
      orderedList: "有序列表",
      task: "任务列表",
      codeRow: "行内代码",
      code: "块级代码",
      link: "链接",
      image: "图片",
      table: "表格",
      mermaid: "mermaid图",
      katex: "katex公式",
      revoke: "后退",
      next: "前进",
      save: "保存",
      prettier: "美化",
      pageFullscreen: "浏览器全屏",
      fullscreen: "屏幕全屏",
      preview: "预览",
      htmlPreview: "html代码预览",
      catalog: "目录",
      github: "源码地址"
    },
    titleItem: {
      h1: "一级标题",
      h2: "二级标题",
      h3: "三级标题",
      h4: "四级标题",
      h5: "五级标题",
      h6: "六级标题"
    },
    imgTitleItem: {
      link: "添加链接",
      upload: "上传图片",
      clip2upload: "裁剪上传"
    },
    linkModalTips: {
      linkTitle: "添加链接",
      imageTitle: "添加图片",
      descLabel: "链接描述：",
      descLabelPlaceHolder: "请输入描述...",
      urlLabel: "链接地址：",
      urlLabelPlaceHolder: "请输入链接...",
      buttonOK: "确定"
    },
    clipModalTips: {
      title: "裁剪图片上传",
      buttonUpload: "上传"
    },
    copyCode: {
      text: "复制代码",
      successTips: "已复制！",
      failTips: "复制失败！"
    },
    mermaid: {
      flow: "流程图",
      sequence: "时序图",
      gantt: "甘特图",
      class: "类图",
      state: "状态图",
      pie: "饼图",
      relationship: "关系图",
      journey: "旅程图"
    },
    katex: {
      inline: "行内公式",
      block: "块级公式"
    },
    footer: {
      markdownTotal: "字数",
      scrollAuto: "同步滚动"
    }
  },
  "en-US": {
    toolbarTips: {
      bold: "bold",
      underline: "underline",
      italic: "italic",
      strikeThrough: "strikeThrough",
      title: "title",
      sub: "subscript",
      sup: "superscript",
      quote: "quote",
      unorderedList: "unordered list",
      orderedList: "ordered list",
      task: "task list",
      codeRow: "inline code",
      code: "block-level code",
      link: "link",
      image: "image",
      table: "table",
      mermaid: "mermaid",
      katex: "formula",
      revoke: "revoke",
      next: "undo revoke",
      save: "save",
      prettier: "prettier",
      pageFullscreen: "fullscreen in page",
      fullscreen: "fullscreen",
      preview: "preview",
      htmlPreview: "html preview",
      catalog: "catalog",
      github: "source code"
    },
    titleItem: {
      h1: "Lv1 Heading",
      h2: "Lv2 Heading",
      h3: "Lv3 Heading",
      h4: "Lv4 Heading",
      h5: "Lv5 Heading",
      h6: "Lv6 Heading"
    },
    imgTitleItem: {
      link: "Add Img Link",
      upload: "Upload Img",
      clip2upload: "Clip Upload"
    },
    linkModalTips: {
      linkTitle: "Add Link",
      imageTitle: "Add Image",
      descLabel: "Desc:",
      descLabelPlaceHolder: "Enter a description...",
      urlLabel: "Link:",
      urlLabelPlaceHolder: "Enter a link...",
      buttonOK: "OK"
    },
    clipModalTips: {
      title: "Crop Image",
      buttonUpload: "Upload"
    },
    copyCode: {
      text: "Copy",
      successTips: "Copied!",
      failTips: "Copy failed!"
    },
    mermaid: {
      flow: "flow",
      sequence: "sequence",
      gantt: "gantt",
      class: "class",
      state: "state",
      pie: "pie",
      relationship: "relationship",
      journey: "journey"
    },
    katex: {
      inline: "inline",
      block: "block"
    },
    footer: {
      markdownTotal: "Word Count",
      scrollAuto: "Scroll Auto"
    }
  }
};
var k = `${e}/mermaid/10.1.0/mermaid.esm.min.mjs`;
var b = {
  js: `${e}/KaTeX/0.16.3/katex.min.js`,
  css: `${e}/KaTeX/0.16.3/katex.min.css`
};
var f = {
  a11y: {
    light: `${e}/highlight.js/11.7.0/styles/a11y-light.min.css`,
    dark: `${e}/highlight.js/11.7.0/styles/a11y-dark.min.css`
  },
  atom: {
    light: `${e}/highlight.js/11.7.0/styles/atom-one-light.min.css`,
    dark: `${e}/highlight.js/11.7.0/styles/atom-one-dark.min.css`
  },
  github: {
    light: `${e}/highlight.js/11.7.0/styles/github.min.css`,
    dark: `${e}/highlight.js/11.7.0/styles/github-dark.min.css`
  },
  gradient: {
    light: `${e}/highlight.js/11.7.0/styles/gradient-light.min.css`,
    dark: `${e}/highlight.js/11.7.0/styles/gradient-dark.min.css`
  },
  kimbie: {
    light: `${e}/highlight.js/11.7.0/styles/kimbie-light.min.css`,
    dark: `${e}/highlight.js/11.7.0/styles/kimbie-dark.min.css`
  },
  paraiso: {
    light: `${e}/highlight.js/11.7.0/styles/paraiso-light.min.css`,
    dark: `${e}/highlight.js/11.7.0/styles/paraiso-dark.min.css`
  },
  qtcreator: {
    light: `${e}/highlight.js/11.7.0/styles/qtcreator-light.min.css`,
    dark: `${e}/highlight.js/11.7.0/styles/qtcreator-dark.min.css`
  },
  stackoverflow: {
    light: `${e}/highlight.js/11.7.0/styles/stackoverflow-light.min.css`,
    dark: `${e}/highlight.js/11.7.0/styles/stackoverflow-dark.min.css`
  }
};
var l = {
  editorExtensions: {},
  editorConfig: {},
  codeMirrorExtensions: (t3, i4) => i4,
  markdownItConfig: () => {
  },
  markdownItPlugins: (t3) => t3,
  iconfontType: "svg"
};
var j = (t3) => {
  if (t3)
    for (const i4 in t3) {
      const s3 = t3[i4];
      s3 && (l[i4] = s3);
    }
};
var v = 170;

// node_modules/@vavt/util/lib/es/index.mjs
var x = (e4, n3 = 200) => {
  let t3 = 0;
  return (...o2) => new Promise((r4) => {
    t3 && (clearTimeout(t3), r4("cancel")), t3 = window.setTimeout(() => {
      e4.apply(void 0, o2), t3 = 0, r4("done");
    }, n3);
  });
};
var C = (e4, n3 = {
  _blank: true,
  nofollow: true
}) => {
  const t3 = document.createElement("a");
  t3.href = e4, n3._blank && (t3.target = "_blank"), n3.nofollow && (t3.rel = "noopener noreferrer"), t3.click();
};
var M = () => {
  let e4 = -1;
  return (t3, o2, r4, c2 = 100) => {
    const s3 = () => {
      r4 && (typeof c2 == "number" ? setTimeout(r4, c2) : r4());
    };
    e4 !== -1 && (cancelAnimationFrame(e4), s3());
    let i4 = t3.scrollTop;
    const l2 = () => {
      e4 = -1;
      const u2 = o2 - i4;
      i4 = i4 + u2 / 5, Math.abs(u2) < 1 ? (t3.scrollTo(0, o2), s3()) : (t3.scrollTo(0, i4), e4 = requestAnimationFrame(l2));
    };
    e4 = requestAnimationFrame(l2);
  };
};
var L = M();
var F = (e4, n3 = 200) => {
  let t3 = 0, o2 = null;
  return (...r4) => {
    const c2 = (s3) => {
      t3 === 0 && (t3 = s3), s3 - t3 >= n3 ? (e4.apply(void 0, o2), o2 = null, t3 = 0) : window.requestAnimationFrame(c2);
    };
    o2 === null && window.requestAnimationFrame(c2), o2 = r4;
  };
};
var $ = (e4) => {
  const n3 = (t3) => {
    const { scrollHeight: o2, scrollWidth: r4, offsetHeight: c2, offsetWidth: s3, scrollLeft: i4, scrollTop: l2 } = e4, u2 = t3.x, S2 = t3.y, p3 = (g4) => {
      const f3 = l2 + S2 - g4.y, m5 = i4 + u2 - g4.x, y2 = o2 - c2, A2 = r4 - s3, d3 = {};
      m5 >= 0 && m5 <= A2 && (d3.left = m5), f3 >= 0 && f3 <= y2 && (d3.top = f3), e4.scroll(d3);
    };
    document.addEventListener("mousemove", p3);
    const v2 = () => {
      document.removeEventListener("mousemove", p3), document.removeEventListener("mouseup", v2);
    };
    document.addEventListener("mouseup", v2);
  };
  return e4.addEventListener("mousedown", n3), () => {
    e4.removeEventListener("mousedown", n3);
  };
};

// node_modules/md-editor-v3/lib/es/chunks/vue-tsx.mjs
var s = ({
  instance: o2,
  ctx: l2,
  props: t3 = {}
}, r4 = "default") => {
  const g4 = (o2 == null ? void 0 : o2.$slots[r4]) || (l2 == null ? void 0 : l2.slots[r4]);
  return (g4 ? g4(o2) : "") || t3[r4];
};

// node_modules/md-editor-v3/lib/es/chunks/index2.mjs
var B = {
  overlay: {
    type: [String, Object],
    default: ""
  },
  visible: {
    type: Boolean,
    default: false
  },
  onChange: {
    type: Function,
    default: () => {
    }
  },
  // 相对滚动的元素选择器
  relative: {
    type: String,
    default: "html"
  }
};
var F2 = defineComponent({
  props: B,
  setup(e4, a2) {
    const i4 = `${a}-dropdown-hidden`, t3 = reactive({
      overlayClass: [i4],
      overlayStyle: {},
      triggerHover: false,
      overlayHover: false
    }), o2 = ref(), n3 = ref(), s3 = () => {
      var p3;
      t3.triggerHover = true;
      const r4 = o2.value, l2 = n3.value;
      if (!r4 || !l2)
        return;
      const u2 = r4.getBoundingClientRect(), f3 = r4.offsetTop, b4 = r4.offsetLeft, H2 = u2.height, L4 = u2.width, w2 = ((p3 = document.querySelector(e4.relative)) == null ? void 0 : p3.scrollLeft) || 0;
      t3.overlayStyle = {
        ...t3.overlayStyle,
        top: f3 + H2 + "px",
        left: b4 - l2.offsetWidth / 2 + L4 / 2 - w2 + "px"
      }, e4.onChange(true);
    }, m5 = () => {
      t3.overlayHover = true;
    };
    watch(() => e4.visible, (r4) => {
      r4 ? t3.overlayClass = t3.overlayClass.filter((l2) => l2 !== i4) : t3.overlayClass.push(i4);
    });
    let h6 = -1;
    const g4 = (r4) => {
      o2.value === r4.target ? t3.triggerHover = false : t3.overlayHover = false, clearTimeout(h6), h6 = window.setTimeout(() => {
        !t3.overlayHover && !t3.triggerHover && e4.onChange(false);
      }, 10);
    };
    return onMounted(() => {
      o2.value.addEventListener("mouseenter", s3), o2.value.addEventListener("mouseleave", g4), n3.value.addEventListener("mouseenter", m5), n3.value.addEventListener("mouseleave", g4);
    }), onBeforeUnmount(() => {
      o2.value.removeEventListener("mouseenter", s3), o2.value.removeEventListener("mouseleave", g4), n3.value.removeEventListener("mouseenter", m5), n3.value.removeEventListener("mouseleave", g4);
    }), () => {
      const r4 = s({
        ctx: a2
      }), l2 = s({
        props: e4,
        ctx: a2
      }, "overlay"), u2 = cloneVNode(r4 instanceof Array ? r4[0] : r4, {
        ref: o2
      }), f3 = createVNode("div", {
        class: [`${a}-dropdown`, t3.overlayClass],
        style: t3.overlayStyle,
        ref: n3
      }, [createVNode("div", {
        class: `${a}-dropdown-overlay`
      }, [l2 instanceof Array ? l2[0] : l2])]);
      return [u2, f3];
    };
  }
});
var I = {
  title: {
    type: String,
    default: ""
  },
  visible: {
    type: Boolean
  },
  // 展示在工具栏的内容，通常是个图标
  trigger: {
    type: [String, Object]
  },
  onChange: {
    type: Function
  },
  // 下拉框中的内容
  overlay: {
    type: [String, Object]
  },
  /**
   * ==没有意义，仅用于规避克隆组件自动嵌入insert方法时，传入的是该组件而产生的waring
   */
  insert: {
    type: Function
  },
  language: {
    type: String
  },
  theme: {
    type: String
  },
  /**
   * ==结束
   */
  default: {
    type: [String, Object]
  }
};
var y = defineComponent({
  name: "DropdownToolbar",
  props: I,
  emits: ["onChange"],
  setup(e4, a2) {
    const i4 = inject("editorId");
    return () => {
      const t3 = s({
        props: e4,
        ctx: a2
      }, "trigger"), o2 = s({
        props: e4,
        ctx: a2
      }, "overlay"), n3 = s({
        props: e4,
        ctx: a2
      });
      return createVNode(F2, {
        relative: `#${i4}-toolbar-wrapper`,
        visible: e4.visible,
        onChange: (s3) => {
          e4.onChange instanceof Function ? e4.onChange(s3) : a2.emit("onChange", s3);
        },
        overlay: o2
      }, {
        default: () => [createVNode("div", {
          class: `${a}-toolbar-item`,
          title: e4.title || ""
        }, [t3, n3])]
      });
    };
  }
});
y.install = (e4) => (e4.component(y.name, y), e4);

// node_modules/md-editor-v3/lib/es/chunks/index4.mjs
var r2 = Object.defineProperty;
var p2 = (o2, s3, t3) => s3 in o2 ? r2(o2, s3, { enumerable: true, configurable: true, writable: true, value: t3 }) : o2[s3] = t3;
var i = (o2, s3, t3) => (p2(o2, typeof s3 != "symbol" ? s3 + "" : s3, t3), t3);
var h3 = class {
  constructor() {
    i(this, "pools", {});
  }
  // 移除事件监听
  remove(s3, t3, n3) {
    const a2 = this.pools[s3] && this.pools[s3][t3];
    a2 && (this.pools[s3][t3] = a2.filter((e4) => e4 !== n3));
  }
  // 清空全部事件，由于单一实例，多次注册会被共享内容
  clear(s3) {
    this.pools[s3] = {};
  }
  // 注册事件监听
  on(s3, t3) {
    return this.pools[s3] || (this.pools[s3] = {}), this.pools[s3][t3.name] || (this.pools[s3][t3.name] = []), this.pools[s3][t3.name].push(t3.callback), this.pools[s3][t3.name].includes(t3.callback);
  }
  // 触发事件
  emit(s3, t3, ...n3) {
    this.pools[s3] || (this.pools[s3] = {});
    const a2 = this.pools[s3][t3];
    a2 && a2.forEach((e4) => {
      try {
        e4(...n3);
      } catch (c2) {
        console.error(`${t3} monitor event exception！`, c2);
      }
    });
  }
};
var C2 = new h3();
var E = "onSave";
var g2 = "changeCatalogVisible";
var A = "changeFullscreen";
var R = "pageFullscreenChanged";
var _ = "fullscreenChanged";
var d2 = "previewChanged";
var L2 = "htmlPreviewChanged";
var N = "catalogVisibleChanged";
var f2 = "textareaFocus";
var S = "buildFinished";
var b2 = "errorCatcher";
var G = "replace";
var H = "uploadImage";
var T = "openModals";
var F3 = "ctrlZ";
var m2 = "ctrlShiftZ";
var I2 = "catalogChanged";
var D = "pushCatalog";
var O = (o2, s3 = "image.png") => {
  const t3 = o2.split(","), n3 = t3[0].match(/:(.*?);/);
  if (n3) {
    const l2 = n3[1], a2 = atob(t3[1]);
    let e4 = a2.length;
    const c2 = new Uint8Array(e4);
    for (; e4--; )
      c2[e4] = a2.charCodeAt(e4);
    return new File([c2], s3, { type: l2 });
  }
  return null;
};
var w = (o2) => {
  if (!o2)
    return o2;
  const s3 = o2.split(`
`), t3 = ['<span rn-wrapper aria-hidden="true">'];
  return s3.forEach(() => {
    t3.push("<span></span>");
  }), t3.push("</span>"), `<span class="code-block">${o2}</span>${t3.join("")}`;
};
var P = (o2, s3) => {
  if (!o2 || !s3)
    return 0;
  const t3 = o2 == null ? void 0 : o2.getBoundingClientRect();
  if (s3 === document.documentElement)
    return t3.top - s3.clientTop;
  const n3 = s3 == null ? void 0 : s3.getBoundingClientRect();
  return t3.top - n3.top;
};
var U = () => `${Date.now().toString(36)}${Math.random().toString(36).substring(2)}`;

// node_modules/md-editor-v3/lib/es/chunks/dom.mjs
var L3 = (e4, d3) => {
  const t3 = (n3) => {
    const o2 = e4.parentElement || document.body, i4 = o2.offsetWidth, m5 = o2.offsetHeight, { clientWidth: u2 } = document.documentElement, { clientHeight: l2 } = document.documentElement, p3 = n3.offsetX, v2 = n3.offsetY, a2 = (f3) => {
      let s3 = f3.x + document.body.scrollLeft - document.body.clientLeft - p3, c2 = f3.y + document.body.scrollTop - document.body.clientTop - v2;
      s3 = s3 < 1 ? 1 : s3 < u2 - i4 - 1 ? s3 : u2 - i4 - 1, c2 = c2 < 1 ? 1 : c2 < l2 - m5 - 1 ? c2 : l2 - m5 - 1, d3 ? d3(s3, c2) : (o2.style.left = `${s3}px`, o2.style.top = `${c2}px`);
    };
    document.addEventListener("mousemove", a2);
    const r4 = () => {
      document.removeEventListener("mousemove", a2), document.removeEventListener("mouseup", r4);
    };
    document.addEventListener("mouseup", r4);
  };
  return e4.addEventListener("mousedown", t3), () => {
    e4.removeEventListener("mousedown", t3);
  };
};
var h4 = (e4, d3 = "") => {
  const t3 = document.getElementById(e4.id), n3 = e4.onload;
  e4.onload = null;
  const o2 = function(i4) {
    typeof n3 == "function" && n3.bind(this)(i4), e4.removeEventListener("load", o2);
  };
  t3 ? d3 !== "" && (t3.addEventListener("load", o2), Reflect.get(window, d3) && t3.dispatchEvent(new Event("load"))) : (e4.addEventListener("load", o2), document.head.appendChild(e4));
};
var b3 = x((e4, d3, t3) => {
  const n3 = document.getElementById(e4);
  n3 && n3.setAttribute(d3, t3);
}, 10);

// node_modules/md-editor-v3/lib/es/chunks/index3.mjs
var T2 = defineComponent({
  props: {
    name: {
      type: String,
      default: ""
    }
  },
  setup(e4) {
    return () => l.iconfontType === "svg" ? createVNode("svg", {
      class: `${a}-icon`,
      "aria-hidden": "true"
    }, [createVNode("use", {
      "xlink:href": `#${a}-icon-${e4.name}`
    }, null)]) : createVNode("i", {
      class: `${a}-iconfont ${a}-icon-${e4.name}`
    }, null);
  }
});
var C3 = defineComponent({
  props: {
    name: {
      type: String,
      default: ""
    }
  },
  setup(e4) {
    const c2 = inject("customIcon");
    return () => {
      const i4 = c2.value[e4.name];
      return typeof i4 == "object" ? typeof i4.component == "object" ? h(i4.component, i4.props) : createVNode("span", {
        innerHTML: i4.component
      }, null) : createVNode(T2, {
        name: e4.name
      }, null);
    };
  }
});
var z = {
  title: {
    type: String,
    default: ""
  },
  visible: {
    type: Boolean,
    default: false
  },
  width: {
    type: String,
    default: "auto"
  },
  height: {
    type: String,
    default: "auto"
  },
  onClose: {
    type: Function
  },
  showAdjust: {
    type: Boolean,
    default: false
  },
  isFullscreen: {
    type: Boolean,
    default: false
  },
  onAdjust: {
    type: Function,
    default: () => {
    }
  }
};
var h5 = defineComponent({
  name: "MdModal",
  props: z,
  emits: ["onClose"],
  setup(e4, c2) {
    const i4 = ref(e4.visible), a2 = ref([`${a}-modal`]), m5 = ref(), r4 = ref();
    let d3 = () => {
    };
    const o2 = reactive({
      initPos: {
        left: "0px",
        top: "0px"
      },
      historyPos: {
        left: "0px",
        top: "0px"
      }
    }), P3 = computed(() => e4.isFullscreen ? {
      width: "100%",
      height: "100%"
    } : {
      width: e4.width,
      height: e4.height
    });
    return onMounted(() => {
      d3 = L3(r4.value, (s3, n3) => {
        o2.initPos.left = s3 + "px", o2.initPos.top = n3 + "px";
      });
    }), onBeforeUnmount(() => {
      d3();
    }), watch(() => e4.isFullscreen, (s3) => {
      s3 ? d3() : d3 = L3(r4.value, (n3, u2) => {
        o2.initPos.left = n3 + "px", o2.initPos.top = u2 + "px";
      });
    }), watch(() => e4.visible, (s3) => {
      s3 ? (a2.value.push("zoom-in"), i4.value = s3, nextTick(() => {
        const n3 = m5.value.offsetWidth / 2, u2 = m5.value.offsetHeight / 2, $2 = document.documentElement.clientWidth / 2, x2 = document.documentElement.clientHeight / 2;
        o2.initPos.left = $2 - n3 + "px", o2.initPos.top = x2 - u2 + "px";
      }), setTimeout(() => {
        a2.value = a2.value.filter((n3) => n3 !== "zoom-in");
      }, 140)) : (a2.value.push("zoom-out"), setTimeout(() => {
        a2.value = a2.value.filter((n3) => n3 !== "zoom-out"), i4.value = s3;
      }, 130));
    }), () => {
      const s3 = s({
        ctx: c2
      }), n3 = s({
        props: e4,
        ctx: c2
      }, "title");
      return createVNode("div", {
        style: {
          display: i4.value ? "block" : "none"
        }
      }, [createVNode("div", {
        class: `${a}-modal-mask`,
        onClick: () => {
          e4.onClose ? e4.onClose() : c2.emit("onClose");
        }
      }, null), createVNode("div", {
        class: a2.value,
        style: {
          ...o2.initPos,
          ...P3.value
        },
        ref: m5
      }, [createVNode("div", {
        class: `${a}-modal-header`,
        ref: r4
      }, [n3 || ""]), createVNode("div", {
        class: `${a}-modal-body`
      }, [s3]), createVNode("div", {
        class: `${a}-modal-func`
      }, [e4.showAdjust && createVNode("div", {
        class: `${a}-modal-adjust`,
        onClick: (u2) => {
          u2.stopPropagation(), e4.isFullscreen ? o2.initPos = o2.historyPos : (o2.historyPos = o2.initPos, o2.initPos = {
            left: "0",
            top: "0"
          }), e4.onAdjust(!e4.isFullscreen);
        }
      }, [createVNode(C3, {
        name: e4.isFullscreen ? "suoxiao" : "fangda"
      }, null)]), createVNode("div", {
        class: `${a}-modal-close`,
        onClick: (u2) => {
          u2.stopPropagation(), e4.onClose ? e4.onClose() : c2.emit("onClose");
        }
      }, [createVNode(C3, {
        name: "close"
      }, null)])])])]);
    };
  }
});
h5.install = (e4) => (e4.component(h5.name, h5), e4);

// node_modules/@codemirror/commands/dist/index.js
var toggleComment = (target) => {
  let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);
  return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
};
function command(f3, option) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let tr = f3(option, state);
    if (!tr)
      return false;
    dispatch(state.update(tr));
    return true;
  };
}
var toggleLineComment = command(
  changeLineComment,
  0
  /* CommentOption.Toggle */
);
var lineComment = command(
  changeLineComment,
  1
  /* CommentOption.Comment */
);
var lineUncomment = command(
  changeLineComment,
  2
  /* CommentOption.Uncomment */
);
var toggleBlockComment = command(
  changeBlockComment,
  0
  /* CommentOption.Toggle */
);
var blockComment = command(
  changeBlockComment,
  1
  /* CommentOption.Comment */
);
var blockUncomment = command(
  changeBlockComment,
  2
  /* CommentOption.Uncomment */
);
var toggleBlockCommentByLine = command(
  (o2, s3) => changeBlockComment(o2, s3, selectedLineRanges(s3)),
  0
  /* CommentOption.Toggle */
);
function getConfig(state, pos) {
  let data = state.languageDataAt("commentTokens", pos);
  return data.length ? data[0] : {};
}
var SearchMargin = 50;
function findBlockComment(state, { open, close }, from, to2) {
  let textBefore = state.sliceDoc(from - SearchMargin, from);
  let textAfter = state.sliceDoc(to2, to2 + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
      close: { pos: to2 + spaceAfter, margin: spaceAfter && 1 }
    };
  }
  let startText, endText;
  if (to2 - from <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from, to2);
  } else {
    startText = state.sliceDoc(from, from + SearchMargin);
    endText = state.sliceDoc(to2 - SearchMargin, to2);
  }
  let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to2 - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function selectedLineRanges(state) {
  let ranges = [];
  for (let r4 of state.selection.ranges) {
    let fromLine = state.doc.lineAt(r4.from);
    let toLine = r4.to <= fromLine.to ? fromLine : state.doc.lineAt(r4.to);
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last].to > fromLine.from)
      ranges[last].to = toLine.to;
    else
      ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
  }
  return ranges;
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
  let tokens = ranges.map((r4) => getConfig(state, r4.from).block);
  if (!tokens.every((c2) => c2))
    return null;
  let comments = ranges.map((r4, i4) => findBlockComment(state, tokens[i4], r4.from, r4.to));
  if (option != 2 && !comments.every((c2) => c2)) {
    return { changes: state.changes(ranges.map((range, i4) => {
      if (comments[i4])
        return [];
      return [{ from: range.from, insert: tokens[i4].open + " " }, { from: range.to, insert: " " + tokens[i4].close }];
    })) };
  } else if (option != 1 && comments.some((c2) => c2)) {
    let changes = [];
    for (let i4 = 0, comment; i4 < comments.length; i4++)
      if (comment = comments[i4]) {
        let token = tokens[i4], { open, close } = comment;
        changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
      }
    return { changes };
  }
  return null;
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
  let lines = [];
  let prevLine = -1;
  for (let { from, to: to2 } of ranges) {
    let startI = lines.length, minIndent = 1e9;
    let token = getConfig(state, from).line;
    if (!token)
      continue;
    for (let pos = from; pos <= to2; ) {
      let line = state.doc.lineAt(pos);
      if (line.from > prevLine && (from == to2 || to2 > line.from)) {
        prevLine = line.from;
        let indent = /^\s*/.exec(line.text)[0].length;
        let empty2 = indent == line.length;
        let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;
        if (indent < line.text.length && indent < minIndent)
          minIndent = indent;
        lines.push({ line, comment, token, indent, empty: empty2, single: false });
      }
      pos = line.to + 1;
    }
    if (minIndent < 1e9) {
      for (let i4 = startI; i4 < lines.length; i4++)
        if (lines[i4].indent < lines[i4].line.text.length)
          lines[i4].indent = minIndent;
    }
    if (lines.length == startI + 1)
      lines[startI].single = true;
  }
  if (option != 2 && lines.some((l2) => l2.comment < 0 && (!l2.empty || l2.single))) {
    let changes = [];
    for (let { line, token, indent, empty: empty2, single } of lines)
      if (single || !empty2)
        changes.push({ from: line.from + indent, insert: token + " " });
    let changeSet = state.changes(changes);
    return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
  } else if (option != 1 && lines.some((l2) => l2.comment >= 0)) {
    let changes = [];
    for (let { line, comment, token } of lines)
      if (comment >= 0) {
        let from = line.from + comment, to2 = from + token.length;
        if (line.text[to2 - line.from] == " ")
          to2++;
        changes.push({ from, to: to2 });
      }
    return { changes };
  }
  return null;
}
var fromHistory = Annotation.define();
var isolateHistory = Annotation.define();
var invertedEffects = Facet.define();
var historyConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (_t2, isAdjacent2) => isAdjacent2
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (a2, b4) => (tr, adj) => a2(tr, adj) || b4(tr, adj)
    });
  }
});
var historyField_ = StateField.define({
  create() {
    return HistoryState.empty;
  },
  update(state, tr) {
    let config = tr.state.facet(historyConfig);
    let fromHist = tr.annotation(fromHistory);
    if (fromHist) {
      let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;
      let other = from == 0 ? state.undone : state.done;
      if (item)
        other = updateBranch(other, other.length, config.minDepth, item);
      else
        other = addSelection(other, tr.startState.selection);
      return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
    }
    let isolate = tr.annotation(isolateHistory);
    if (isolate == "full" || isolate == "before")
      state = state.isolate();
    if (tr.annotation(Transaction.addToHistory) === false)
      return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
    let event = HistEvent.fromTransaction(tr);
    let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
    if (event)
      state = state.addChanges(event, time, userEvent, config, tr);
    else if (tr.selection)
      state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);
    if (isolate == "full" || isolate == "after")
      state = state.isolate();
    return state;
  },
  toJSON(value) {
    return { done: value.done.map((e4) => e4.toJSON()), undone: value.undone.map((e4) => e4.toJSON()) };
  },
  fromJSON(json) {
    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
  }
});
function history(config = {}) {
  return [
    historyField_,
    historyConfig.of(config),
    EditorView.domEventHandlers({
      beforeinput(e4, view) {
        let command2 = e4.inputType == "historyUndo" ? undo : e4.inputType == "historyRedo" ? redo : null;
        if (!command2)
          return false;
        e4.preventDefault();
        return command2(view);
      }
    })
  ];
}
function cmd(side, selection) {
  return function({ state, dispatch }) {
    if (!selection && state.readOnly)
      return false;
    let historyState = state.field(historyField_, false);
    if (!historyState)
      return false;
    let tr = historyState.pop(side, state, selection);
    if (!tr)
      return false;
    dispatch(tr);
    return true;
  };
}
var undo = cmd(0, false);
var redo = cmd(1, false);
var undoSelection = cmd(0, true);
var redoSelection = cmd(1, true);
function depth(side) {
  return function(state) {
    let histState = state.field(historyField_, false);
    if (!histState)
      return 0;
    let branch = side == 0 ? histState.done : histState.undone;
    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
  };
}
var undoDepth = depth(
  0
  /* BranchName.Done */
);
var redoDepth = depth(
  1
  /* BranchName.Undone */
);
var HistEvent = class _HistEvent {
  constructor(changes, effects, mapped, startSelection, selectionsAfter) {
    this.changes = changes;
    this.effects = effects;
    this.mapped = mapped;
    this.startSelection = startSelection;
    this.selectionsAfter = selectionsAfter;
  }
  setSelAfter(after) {
    return new _HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
  }
  toJSON() {
    var _a, _b, _c;
    return {
      changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),
      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s3) => s3.toJSON())
    };
  }
  static fromJSON(json) {
    return new _HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(tr, selection) {
    let effects = none;
    for (let invert of tr.startState.facet(invertedEffects)) {
      let result = invert(tr);
      if (result.length)
        effects = effects.concat(result);
    }
    if (!effects.length && tr.changes.empty)
      return null;
    return new _HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection || tr.startState.selection, none);
  }
  static selection(selections) {
    return new _HistEvent(void 0, none, void 0, void 0, selections);
  }
};
function updateBranch(branch, to2, maxLen, newEvent) {
  let start = to2 + 1 > maxLen + 20 ? to2 - maxLen - 1 : 0;
  let newBranch = branch.slice(start, to2);
  newBranch.push(newEvent);
  return newBranch;
}
function isAdjacent(a2, b4) {
  let ranges = [], isAdjacent2 = false;
  a2.iterChangedRanges((f3, t3) => ranges.push(f3, t3));
  b4.iterChangedRanges((_f, _t2, f3, t3) => {
    for (let i4 = 0; i4 < ranges.length; ) {
      let from = ranges[i4++], to2 = ranges[i4++];
      if (t3 >= from && f3 <= to2)
        isAdjacent2 = true;
    }
  });
  return isAdjacent2;
}
function eqSelectionShape(a2, b4) {
  return a2.ranges.length == b4.ranges.length && a2.ranges.filter((r4, i4) => r4.empty != b4.ranges[i4].empty).length === 0;
}
function conc(a2, b4) {
  return !a2.length ? b4 : !b4.length ? a2 : a2.concat(b4);
}
var none = [];
var MaxSelectionsPerEvent = 200;
function addSelection(branch, selection) {
  if (!branch.length) {
    return [HistEvent.selection([selection])];
  } else {
    let lastEvent = branch[branch.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection))
      return branch;
    sels.push(selection);
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
}
function popSelection(branch) {
  let last = branch[branch.length - 1];
  let newBranch = branch.slice();
  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
  return newBranch;
}
function addMappingToBranch(branch, mapping) {
  if (!branch.length)
    return branch;
  let length = branch.length, selections = none;
  while (length) {
    let event = mapEvent(branch[length - 1], mapping, selections);
    if (event.changes && !event.changes.empty || event.effects.length) {
      let result = branch.slice(0, length);
      result[length - 1] = event;
      return result;
    } else {
      mapping = event.mapped;
      length--;
      selections = event.selectionsAfter;
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none;
}
function mapEvent(event, mapping, extraSelections) {
  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s3) => s3.map(mapping)) : none, extraSelections);
  if (!event.changes)
    return HistEvent.selection(selections);
  let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
  return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
var joinableUserEvent = /^(input\.type|delete)($|\.)/;
var HistoryState = class _HistoryState {
  constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
    this.done = done;
    this.undone = undone;
    this.prevTime = prevTime;
    this.prevUserEvent = prevUserEvent;
  }
  isolate() {
    return this.prevTime ? new _HistoryState(this.done, this.undone) : this;
  }
  addChanges(event, time, userEvent, config, tr) {
    let done = this.done, lastEvent = done[done.length - 1];
    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config.newGroupDelay && config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event
    userEvent == "input.type.compose")) {
      done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));
    } else {
      done = updateBranch(done, done.length, config.minDepth, event);
    }
    return new _HistoryState(done, none, time, userEvent);
  }
  addSelection(selection, time, userEvent, newGroupDelay) {
    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;
    if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection))
      return this;
    return new _HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
  }
  addMapping(mapping) {
    return new _HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
  }
  pop(side, state, onlySelection) {
    let branch = side == 0 ? this.done : this.undone;
    if (branch.length == 0)
      return null;
    let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;
    if (onlySelection && event.selectionsAfter.length) {
      return state.update({
        selection: event.selectionsAfter[event.selectionsAfter.length - 1],
        annotations: fromHistory.of({ side, rest: popSelection(branch), selection }),
        userEvent: side == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    } else if (!event.changes) {
      return null;
    } else {
      let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);
      if (event.mapped)
        rest = addMappingToBranch(rest, event.mapped);
      return state.update({
        changes: event.changes,
        selection: event.startSelection,
        effects: event.effects,
        annotations: fromHistory.of({ side, rest, selection }),
        filter: false,
        userEvent: side == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    }
  }
};
HistoryState.empty = new HistoryState(none, none);
var historyKeymap = [
  { key: "Mod-z", run: undo, preventDefault: true },
  { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
  { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
  { key: "Mod-u", run: undoSelection, preventDefault: true },
  { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
];
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection) {
  return state.update({ selection, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
  let selection = updateSel(state.selection, how);
  if (selection.eq(state.selection))
    return false;
  dispatch(setSel(state, selection));
  return true;
}
function rangeEnd(range, forward) {
  return EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
}
var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
function cursorByGroup(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
var segmenter = typeof Intl != "undefined" && Intl.Segmenter ? new Intl.Segmenter(void 0, { granularity: "word" }) : null;
function interestingNode(state, node, bracketProp) {
  if (node.type.prop(bracketProp))
    return true;
  let len = node.to - node.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
  let pos = syntaxTree(state).resolveInner(start.head);
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
  for (let at2 = start.head; ; ) {
    let next = forward ? pos.childAfter(at2) : pos.childBefore(at2);
    if (!next)
      break;
    if (interestingNode(state, next, bracketProp))
      pos = next;
    else
      at2 = forward ? next.to : next.from;
  }
  let bracket = pos.type.prop(bracketProp), match, newPos;
  if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
    newPos = forward ? match.end.to : match.end.from;
  else
    newPos = forward ? pos.to : pos.from;
  return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
var cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
  return moveSel(view, (range) => {
    if (!range.empty)
      return rangeEnd(range, forward);
    let moved = view.moveVertically(range, forward);
    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
  });
}
var cursorLineUp = (view) => cursorByLine(view, false);
var cursorLineDown = (view) => cursorByLine(view, true);
function pageInfo(view) {
  let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
  let marginTop = 0, marginBottom = 0, height;
  if (selfScroll) {
    for (let source of view.state.facet(EditorView.scrollMargins)) {
      let margins = source(view);
      if (margins === null || margins === void 0 ? void 0 : margins.top)
        marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
      if (margins === null || margins === void 0 ? void 0 : margins.bottom)
        marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
    }
    height = view.scrollDOM.clientHeight - marginTop - marginBottom;
  } else {
    height = (view.dom.ownerDocument.defaultView || window).innerHeight;
  }
  return {
    marginTop,
    marginBottom,
    selfScroll,
    height: Math.max(view.defaultLineHeight, height - 5)
  };
}
function cursorByPage(view, forward) {
  let page = pageInfo(view);
  let { state } = view, selection = updateSel(state.selection, (range) => {
    return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
  });
  if (selection.eq(state.selection))
    return false;
  let effect;
  if (page.selfScroll) {
    let startPos = view.coordsAtPos(state.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
      effect = EditorView.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollTop });
  }
  view.dispatch(setSel(state, selection), { effects: effect });
  return true;
}
var cursorPageUp = (view) => cursorByPage(view, false);
var cursorPageDown = (view) => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
  let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
  if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
    moved = view.moveToLineBoundary(start, forward, false);
  if (!forward && moved.head == line.from && line.length) {
    let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
    if (space && start.head != line.from + space)
      moved = EditorSelection.cursor(line.from + space);
  }
  return moved;
}
var cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
var cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
var cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
var cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend) {
  let found = false, selection = updateSel(state.selection, (range) => {
    let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
    if (!matching || !matching.end)
      return range;
    found = true;
    let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
    return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
  });
  if (!found)
    return false;
  dispatch(setSel(state, selection));
  return true;
}
var cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
function extendSel(view, how) {
  let selection = updateSel(view.state.selection, (range) => {
    let head = how(range);
    return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
  });
  if (selection.eq(view.state.selection))
    return false;
  view.dispatch(setSel(view.state, selection));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, (range) => view.moveByChar(range, forward));
}
var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
function selectByGroup(view, forward) {
  return extendSel(view, (range) => view.moveByGroup(range, forward));
}
var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
var selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward));
}
var selectLineUp = (view) => selectByLine(view, false);
var selectLineDown = (view) => selectByLine(view, true);
function selectByPage(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height));
}
var selectPageUp = (view) => selectByPage(view, false);
var selectPageDown = (view) => selectByPage(view, true);
var selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
var selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
var selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
var selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
var cursorDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: 0 }));
  return true;
};
var cursorDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.doc.length }));
  return true;
};
var selectDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
  return true;
};
var selectDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
  return true;
};
var selectAll = ({ state, dispatch }) => {
  dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
  return true;
};
var selectLine = ({ state, dispatch }) => {
  let ranges = selectedLineBlocks(state).map(({ from, to: to2 }) => EditorSelection.range(from, Math.min(to2 + 1, state.doc.length)));
  dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
  return true;
};
var selectParentSyntax = ({ state, dispatch }) => {
  let selection = updateSel(state.selection, (range) => {
    var _a;
    let stack = syntaxTree(state).resolveStack(range.from, 1);
    for (let cur = stack; cur; cur = cur.next) {
      let { node } = cur;
      if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent))
        return EditorSelection.range(node.to, node.from);
    }
    return range;
  });
  dispatch(setSel(state, selection));
  return true;
};
var simplifySelection = ({ state, dispatch }) => {
  let cur = state.selection, selection = null;
  if (cur.ranges.length > 1)
    selection = EditorSelection.create([cur.main]);
  else if (!cur.main.empty)
    selection = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);
  if (!selection)
    return false;
  dispatch(setSel(state, selection));
  return true;
};
function deleteBy(target, by) {
  if (target.state.readOnly)
    return false;
  let event = "delete.selection", { state } = target;
  let changes = state.changeByRange((range) => {
    let { from, to: to2 } = range;
    if (from == to2) {
      let towards = by(range);
      if (towards < from) {
        event = "delete.backward";
        towards = skipAtomic(target, towards, false);
      } else if (towards > from) {
        event = "delete.forward";
        towards = skipAtomic(target, towards, true);
      }
      from = Math.min(from, towards);
      to2 = Math.max(to2, towards);
    } else {
      from = skipAtomic(target, from, false);
      to2 = skipAtomic(target, to2, true);
    }
    return from == to2 ? { range } : { changes: { from, to: to2 }, range: EditorSelection.cursor(from, from < range.head ? -1 : 1) };
  });
  if (changes.changes.empty)
    return false;
  target.dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: event,
    effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
  }));
  return true;
}
function skipAtomic(target, pos, forward) {
  if (target instanceof EditorView)
    for (let ranges of target.state.facet(EditorView.atomicRanges).map((f3) => f3(target)))
      ranges.between(pos, pos, (from, to2) => {
        if (from < pos && to2 > pos)
          pos = forward ? to2 : from;
      });
  return pos;
}
var deleteByChar = (target, forward) => deleteBy(target, (range) => {
  let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;
  if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
    if (before[before.length - 1] == "	")
      return pos - 1;
    let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
    for (let i4 = 0; i4 < drop && before[before.length - 1 - i4] == " "; i4++)
      pos--;
    targetPos = pos;
  } else {
    targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
      targetPos += forward ? 1 : -1;
    else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))
      targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;
  }
  return targetPos;
});
var deleteCharBackward = (view) => deleteByChar(view, false);
var deleteCharForward = (view) => deleteByChar(view, true);
var deleteByGroup = (target, forward) => deleteBy(target, (range) => {
  let pos = range.head, { state } = target, line = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);
  for (let cat = null; ; ) {
    if (pos == (forward ? line.to : line.from)) {
      if (pos == range.head && line.number != (forward ? state.doc.lines : 1))
        pos += forward ? 1 : -1;
      break;
    }
    let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
    let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
    let nextCat = categorize(nextChar);
    if (cat != null && nextCat != cat)
      break;
    if (nextChar != " " || pos != range.head)
      cat = nextCat;
    pos = next;
  }
  return pos;
});
var deleteGroupBackward = (target) => deleteByGroup(target, false);
var deleteGroupForward = (target) => deleteByGroup(target, true);
var deleteToLineEnd = (view) => deleteBy(view, (range) => {
  let lineEnd = view.lineBlockAt(range.head).to;
  return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);
});
var deleteLineBoundaryBackward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, false).head;
  return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
var deleteLineBoundaryForward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, true).head;
  return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
});
var splitLine = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    return {
      changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
      range: EditorSelection.cursor(range.from)
    };
  });
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
  return true;
};
var transposeChars = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    if (!range.empty || range.from == 0 || range.from == state.doc.length)
      return { range };
    let pos = range.from, line = state.doc.lineAt(pos);
    let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
    let to2 = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
    return {
      changes: { from, to: to2, insert: state.doc.slice(pos, to2).append(state.doc.slice(from, pos)) },
      range: EditorSelection.cursor(to2)
    };
  });
  if (changes.changes.empty)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
  return true;
};
function selectedLineBlocks(state) {
  let blocks = [], upto = -1;
  for (let range of state.selection.ranges) {
    let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
    if (!range.empty && range.to == endLine.from)
      endLine = state.doc.lineAt(range.to - 1);
    if (upto >= startLine.number) {
      let prev = blocks[blocks.length - 1];
      prev.to = endLine.to;
      prev.ranges.push(range);
    } else {
      blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
    }
    upto = endLine.number + 1;
  }
  return blocks;
}
function moveLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [], ranges = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward ? block.to == state.doc.length : block.from == 0)
      continue;
    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
    let size = nextLine.length + 1;
    if (forward) {
      changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
      for (let r4 of block.ranges)
        ranges.push(EditorSelection.range(Math.min(state.doc.length, r4.anchor + size), Math.min(state.doc.length, r4.head + size)));
    } else {
      changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
      for (let r4 of block.ranges)
        ranges.push(EditorSelection.range(r4.anchor - size, r4.head - size));
    }
  }
  if (!changes.length)
    return false;
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    selection: EditorSelection.create(ranges, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
var moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
var moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward)
      changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
    else
      changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
  }
  dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
  return true;
}
var copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
var copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
var deleteLine = (view) => {
  if (view.state.readOnly)
    return false;
  let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to: to2 }) => {
    if (from > 0)
      from--;
    else if (to2 < state.doc.length)
      to2++;
    return { from, to: to2 };
  }));
  let selection = updateSel(state.selection, (range) => view.moveVertically(range, true)).map(changes);
  view.dispatch({ changes, selection, scrollIntoView: true, userEvent: "delete.line" });
  return true;
};
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
    return { from: pos, to: pos };
  let context = syntaxTree(state).resolveInner(pos);
  let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before.to, after.from)))
    return { from: before.to, to: after.from };
  return null;
}
var insertNewlineAndIndent = newlineAndIndent(false);
var insertBlankLine = newlineAndIndent(true);
function newlineAndIndent(atEof) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      let { from, to: to2 } = range, line = state.doc.lineAt(from);
      let explode = !atEof && from == to2 && isBetweenBrackets(state, from);
      if (atEof)
        from = to2 = (to2 <= line.to ? line : state.doc.lineAt(to2)).to;
      let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
      let indent = getIndentation(cx, from);
      if (indent == null)
        indent = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
      while (to2 < line.to && /\s/.test(line.text[to2 - line.from]))
        to2++;
      if (explode)
        ({ from, to: to2 } = explode);
      else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
        from = line.from;
      let insert = ["", indentString(state, indent)];
      if (explode)
        insert.push(indentString(state, cx.lineIndent(line.from, -1)));
      return {
        changes: { from, to: to2, insert: Text.of(insert) },
        range: EditorSelection.cursor(from + 1 + insert[1].length)
      };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
}
function changeBySelectedLine(state, f3) {
  let atLine = -1;
  return state.changeByRange((range) => {
    let changes = [];
    for (let pos = range.from; pos <= range.to; ) {
      let line = state.doc.lineAt(pos);
      if (line.number > atLine && (range.empty || range.to > line.from)) {
        f3(line, changes, range);
        atLine = line.number;
      }
      pos = line.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
    };
  });
}
var indentSelection = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let updated = /* @__PURE__ */ Object.create(null);
  let context = new IndentContext(state, { overrideIndentation: (start) => {
    let found = updated[start];
    return found == null ? -1 : found;
  } });
  let changes = changeBySelectedLine(state, (line, changes2, range) => {
    let indent = getIndentation(context, line.from);
    if (indent == null)
      return;
    if (!/\S/.test(line.text))
      indent = 0;
    let cur = /^\s*/.exec(line.text)[0];
    let norm = indentString(state, indent);
    if (cur != norm || range.from < line.from + cur.length) {
      updated[line.from] = indent;
      changes2.push({ from: line.from, to: line.from + cur.length, insert: norm });
    }
  });
  if (!changes.changes.empty)
    dispatch(state.update(changes, { userEvent: "indent" }));
  return true;
};
var indentMore = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    changes.push({ from: line.from, insert: state.facet(indentUnit) });
  }), { userEvent: "input.indent" }));
  return true;
};
var indentLess = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    let space = /^\s*/.exec(line.text)[0];
    if (!space)
      return;
    let col = countColumn(space, state.tabSize), keep = 0;
    let insert = indentString(state, Math.max(0, col - getIndentUnit(state)));
    while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))
      keep++;
    changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });
  }), { userEvent: "delete.dedent" }));
  return true;
};
var emacsStyleKeymap = [
  { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
  { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
  { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
  { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
  { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
  { key: "Ctrl-d", run: deleteCharForward },
  { key: "Ctrl-h", run: deleteCharBackward },
  { key: "Ctrl-k", run: deleteToLineEnd },
  { key: "Ctrl-Alt-h", run: deleteGroupBackward },
  { key: "Ctrl-o", run: splitLine },
  { key: "Ctrl-t", run: transposeChars },
  { key: "Ctrl-v", run: cursorPageDown }
];
var standardKeymap = [
  { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
  { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
  { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
  { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
  { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
  { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
  { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
  { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
  { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
  { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
  { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
  { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
  { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
  { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
  { key: "Enter", run: insertNewlineAndIndent },
  { key: "Mod-a", run: selectAll },
  { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
  { key: "Delete", run: deleteCharForward },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
  { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
  { mac: "Mod-Backspace", run: deleteLineBoundaryBackward },
  { mac: "Mod-Delete", run: deleteLineBoundaryForward }
].concat(emacsStyleKeymap.map((b4) => ({ mac: b4.key, run: b4.run, shift: b4.shift })));
var defaultKeymap = [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
  { key: "Alt-ArrowUp", run: moveLineUp },
  { key: "Shift-Alt-ArrowUp", run: copyLineUp },
  { key: "Alt-ArrowDown", run: moveLineDown },
  { key: "Shift-Alt-ArrowDown", run: copyLineDown },
  { key: "Escape", run: simplifySelection },
  { key: "Mod-Enter", run: insertBlankLine },
  { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
  { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
  { key: "Mod-[", run: indentLess },
  { key: "Mod-]", run: indentMore },
  { key: "Mod-Alt-\\", run: indentSelection },
  { key: "Shift-Mod-k", run: deleteLine },
  { key: "Shift-Mod-\\", run: cursorMatchingBracket },
  { key: "Mod-/", run: toggleComment },
  { key: "Alt-A", run: toggleBlockComment }
].concat(standardKeymap);
var indentWithTab = { key: "Tab", run: indentMore, shift: indentLess };

// node_modules/crelt/index.js
function crelt() {
  var elt = arguments[0];
  if (typeof elt == "string")
    elt = document.createElement(elt);
  var i4 = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name in next)
      if (Object.prototype.hasOwnProperty.call(next, name)) {
        var value = next[name];
        if (typeof value == "string")
          elt.setAttribute(name, value);
        else if (value != null)
          elt[name] = value;
      }
    i4++;
  }
  for (; i4 < arguments.length; i4++)
    add(elt, arguments[i4]);
  return elt;
}
function add(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child));
  } else if (child == null) {
  } else if (child.nodeType != null) {
    elt.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i4 = 0; i4 < child.length; i4++)
      add(elt, child[i4]);
  } else {
    throw new RangeError("Unsupported child node: " + child);
  }
}

// node_modules/@codemirror/search/dist/index.js
var basicNormalize = typeof String.prototype.normalize == "function" ? (x2) => x2.normalize("NFKD") : (x2) => x2;
var SearchCursor = class {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(text, query, from = 0, to2 = text.length, normalize, test) {
    this.test = test;
    this.value = { from: 0, to: 0 };
    this.done = false;
    this.matches = [];
    this.buffer = "";
    this.bufferPos = 0;
    this.iter = text.iterRange(from, to2);
    this.bufferStart = from;
    this.normalize = normalize ? (x2) => normalize(basicNormalize(x2)) : basicNormalize;
    this.query = this.normalize(query);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      this.bufferStart += this.buffer.length;
      this.iter.next();
      if (this.iter.done)
        return -1;
      this.bufferPos = 0;
      this.buffer = this.iter.value;
    }
    return codePointAt(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    while (this.matches.length)
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let next = this.peek();
      if (next < 0) {
        this.done = true;
        return this;
      }
      let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
      this.bufferPos += codePointSize(next);
      let norm = this.normalize(str);
      for (let i4 = 0, pos = start; ; i4++) {
        let code = norm.charCodeAt(i4);
        let match = this.match(code, pos);
        if (i4 == norm.length - 1) {
          if (match) {
            this.value = match;
            return this;
          }
          break;
        }
        if (pos == start && i4 < str.length && str.charCodeAt(i4) == code)
          pos++;
      }
    }
  }
  match(code, pos) {
    let match = null;
    for (let i4 = 0; i4 < this.matches.length; i4 += 2) {
      let index = this.matches[i4], keep = false;
      if (this.query.charCodeAt(index) == code) {
        if (index == this.query.length - 1) {
          match = { from: this.matches[i4 + 1], to: pos + 1 };
        } else {
          this.matches[i4]++;
          keep = true;
        }
      }
      if (!keep) {
        this.matches.splice(i4, 2);
        i4 -= 2;
      }
    }
    if (this.query.charCodeAt(0) == code) {
      if (this.query.length == 1)
        match = { from: pos, to: pos + 1 };
      else
        this.matches.push(1, pos);
    }
    if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))
      match = null;
    return match;
  }
};
if (typeof Symbol != "undefined")
  SearchCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
var empty = { from: -1, to: -1, match: /.*/.exec("") };
var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
var RegExpCursor = class {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(text, query, options, from = 0, to2 = text.length) {
    this.text = text;
    this.to = to2;
    this.curLine = "";
    this.done = false;
    this.value = empty;
    if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
      return new MultilineRegExpCursor(text, query, options, from, to2);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.test = options === null || options === void 0 ? void 0 : options.test;
    this.iter = text.iter();
    let startLine = text.lineAt(from);
    this.curLineStart = startLine.from;
    this.matchPos = toCharEnd(text, from);
    this.getLine(this.curLineStart);
  }
  getLine(skip) {
    this.iter.next(skip);
    if (this.iter.lineBreak) {
      this.curLine = "";
    } else {
      this.curLine = this.iter.value;
      if (this.curLineStart + this.curLine.length > this.to)
        this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
      this.iter.next();
    }
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1;
    if (this.curLineStart > this.to)
      this.curLine = "";
    else
      this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let off = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = off;
      let match = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (match) {
        let from = this.curLineStart + match.index, to2 = from + match[0].length;
        this.matchPos = toCharEnd(this.text, to2 + (from == to2 ? 1 : 0));
        if (from == this.curLineStart + this.curLine.length)
          this.nextLine();
        if ((from < to2 || from > this.value.to) && (!this.test || this.test(from, to2, match))) {
          this.value = { from, to: to2, match };
          return this;
        }
        off = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) {
        this.nextLine();
        off = 0;
      } else {
        this.done = true;
        return this;
      }
    }
  }
};
var flattened = /* @__PURE__ */ new WeakMap();
var FlattenedDoc = class _FlattenedDoc {
  constructor(from, text) {
    this.from = from;
    this.text = text;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(doc, from, to2) {
    let cached = flattened.get(doc);
    if (!cached || cached.from >= to2 || cached.to <= from) {
      let flat = new _FlattenedDoc(from, doc.sliceString(from, to2));
      flattened.set(doc, flat);
      return flat;
    }
    if (cached.from == from && cached.to == to2)
      return cached;
    let { text, from: cachedFrom } = cached;
    if (cachedFrom > from) {
      text = doc.sliceString(from, cachedFrom) + text;
      cachedFrom = from;
    }
    if (cached.to < to2)
      text += doc.sliceString(cached.to, to2);
    flattened.set(doc, new _FlattenedDoc(cachedFrom, text));
    return new _FlattenedDoc(from, text.slice(from - cachedFrom, to2 - cachedFrom));
  }
};
var MultilineRegExpCursor = class {
  constructor(text, query, options, from, to2) {
    this.text = text;
    this.to = to2;
    this.done = false;
    this.value = empty;
    this.matchPos = toCharEnd(text, from);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.test = options === null || options === void 0 ? void 0 : options.test;
    this.flat = FlattenedDoc.get(text, from, this.chunkEnd(
      from + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(pos) {
    return pos >= this.to ? this.to : this.text.lineAt(pos).to;
  }
  next() {
    for (; ; ) {
      let off = this.re.lastIndex = this.matchPos - this.flat.from;
      let match = this.re.exec(this.flat.text);
      if (match && !match[0] && match.index == off) {
        this.re.lastIndex = off + 1;
        match = this.re.exec(this.flat.text);
      }
      if (match) {
        let from = this.flat.from + match.index, to2 = from + match[0].length;
        if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to2, match))) {
          this.value = { from, to: to2, match };
          this.matchPos = toCharEnd(this.text, to2 + (from == to2 ? 1 : 0));
          return this;
        }
      }
      if (this.flat.to == this.to) {
        this.done = true;
        return this;
      }
      this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
};
if (typeof Symbol != "undefined") {
  RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch (_a) {
    return false;
  }
}
function toCharEnd(text, pos) {
  if (pos >= text.length)
    return pos;
  let line = text.lineAt(pos), next;
  while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
    pos++;
  return pos;
}
function createLineDialog(view) {
  let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);
  let input = crelt("input", { class: "cm-textfield", name: "line", value: line });
  let dom = crelt("form", {
    class: "cm-gotoLine",
    onkeydown: (event) => {
      if (event.keyCode == 27) {
        event.preventDefault();
        view.dispatch({ effects: dialogEffect.of(false) });
        view.focus();
      } else if (event.keyCode == 13) {
        event.preventDefault();
        go2();
      }
    },
    onsubmit: (event) => {
      event.preventDefault();
      go2();
    }
  }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")));
  function go2() {
    let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
    if (!match)
      return;
    let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
    let [, sign, ln, cl, percent] = match;
    let col = cl ? +cl.slice(1) : 0;
    let line2 = ln ? +ln : startLine.number;
    if (ln && percent) {
      let pc = line2 / 100;
      if (sign)
        pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
      line2 = Math.round(state.doc.lines * pc);
    } else if (ln && sign) {
      line2 = line2 * (sign == "-" ? -1 : 1) + startLine.number;
    }
    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line2)));
    let selection = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
    view.dispatch({
      effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection.from, { y: "center" })],
      selection
    });
    view.focus();
  }
  return { dom };
}
var dialogEffect = StateEffect.define();
var dialogField = StateField.define({
  create() {
    return true;
  },
  update(value, tr) {
    for (let e4 of tr.effects)
      if (e4.is(dialogEffect))
        value = e4.value;
    return value;
  },
  provide: (f3) => showPanel.from(f3, (val) => val ? createLineDialog : null)
});
var gotoLine = (view) => {
  let panel = getPanel(view, createLineDialog);
  if (!panel) {
    let effects = [dialogEffect.of(true)];
    if (view.state.field(dialogField, false) == null)
      effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));
    view.dispatch({ effects });
    panel = getPanel(view, createLineDialog);
  }
  if (panel)
    panel.dom.querySelector("input").select();
  return true;
};
var baseTheme$1 = EditorView.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
});
var defaultHighlightOptions = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: false
};
var highlightConfig = Facet.define({
  combine(options) {
    return combineConfig(options, defaultHighlightOptions, {
      highlightWordAroundCursor: (a2, b4) => a2 || b4,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function highlightSelectionMatches(options) {
  let ext = [defaultTheme, matchHighlighter];
  if (options)
    ext.push(highlightConfig.of(options));
  return ext;
}
var matchDeco = Decoration.mark({ class: "cm-selectionMatch" });
var mainMatchDeco = Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function insideWordBoundaries(check, state, from, to2) {
  return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to2 == state.doc.length || check(state.sliceDoc(to2, to2 + 1)) != CharCategory.Word);
}
function insideWord(check, state, from, to2) {
  return check(state.sliceDoc(from, from + 1)) == CharCategory.Word && check(state.sliceDoc(to2 - 1, to2)) == CharCategory.Word;
}
var matchHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.selectionSet || update.docChanged || update.viewportChanged)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let conf = view.state.facet(highlightConfig);
    let { state } = view, sel = state.selection;
    if (sel.ranges.length > 1)
      return Decoration.none;
    let range = sel.main, query, check = null;
    if (range.empty) {
      if (!conf.highlightWordAroundCursor)
        return Decoration.none;
      let word = state.wordAt(range.head);
      if (!word)
        return Decoration.none;
      check = state.charCategorizer(range.head);
      query = state.sliceDoc(word.from, word.to);
    } else {
      let len = range.to - range.from;
      if (len < conf.minSelectionLength || len > 200)
        return Decoration.none;
      if (conf.wholeWords) {
        query = state.sliceDoc(range.from, range.to);
        check = state.charCategorizer(range.head);
        if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to)))
          return Decoration.none;
      } else {
        query = state.sliceDoc(range.from, range.to).trim();
        if (!query)
          return Decoration.none;
      }
    }
    let deco = [];
    for (let part of view.visibleRanges) {
      let cursor = new SearchCursor(state.doc, query, part.from, part.to);
      while (!cursor.next().done) {
        let { from, to: to2 } = cursor.value;
        if (!check || insideWordBoundaries(check, state, from, to2)) {
          if (range.empty && from <= range.from && to2 >= range.to)
            deco.push(mainMatchDeco.range(from, to2));
          else if (from >= range.to || to2 <= range.from)
            deco.push(matchDeco.range(from, to2));
          if (deco.length > conf.maxMatches)
            return Decoration.none;
        }
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v2) => v2.decorations
});
var defaultTheme = EditorView.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
var selectWord = ({ state, dispatch }) => {
  let { selection } = state;
  let newSel = EditorSelection.create(selection.ranges.map((range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);
  if (newSel.eq(selection))
    return false;
  dispatch(state.update({ selection: newSel }));
  return true;
};
function findNextOccurrence(state, query) {
  let { main, ranges } = state.selection;
  let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
  for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
    cursor.next();
    if (cursor.done) {
      if (cycled)
        return null;
      cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
      cycled = true;
    } else {
      if (cycled && ranges.some((r4) => r4.from == cursor.value.from))
        continue;
      if (fullWord) {
        let word2 = state.wordAt(cursor.value.from);
        if (!word2 || word2.from != cursor.value.from || word2.to != cursor.value.to)
          continue;
      }
      return cursor.value;
    }
  }
}
var selectNextOccurrence = ({ state, dispatch }) => {
  let { ranges } = state.selection;
  if (ranges.some((sel) => sel.from === sel.to))
    return selectWord({ state, dispatch });
  let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
  if (state.selection.ranges.some((r4) => state.sliceDoc(r4.from, r4.to) != searchedText))
    return false;
  let range = findNextOccurrence(state, searchedText);
  if (!range)
    return false;
  dispatch(state.update({
    selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
    effects: EditorView.scrollIntoView(range.to)
  }));
  return true;
};
var searchConfigFacet = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      top: false,
      caseSensitive: false,
      literal: false,
      regexp: false,
      wholeWord: false,
      createPanel: (view) => new SearchPanel(view),
      scrollToMatch: (range) => EditorView.scrollIntoView(range)
    });
  }
});
var SearchQuery = class {
  /**
  Create a query object.
  */
  constructor(config) {
    this.search = config.search;
    this.caseSensitive = !!config.caseSensitive;
    this.literal = !!config.literal;
    this.regexp = !!config.regexp;
    this.replace = config.replace || "";
    this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
    this.unquoted = this.unquote(this.search);
    this.wholeWord = !!config.wholeWord;
  }
  /**
  @internal
  */
  unquote(text) {
    return this.literal ? text : text.replace(/\\([nrt\\])/g, (_2, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(other) {
    return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(state, from = 0, to2) {
    let st = state.doc ? state : EditorState.create({ doc: state });
    if (to2 == null)
      to2 = st.doc.length;
    return this.regexp ? regexpCursor(this, st, from, to2) : stringCursor(this, st, from, to2);
  }
};
var QueryType = class {
  constructor(spec) {
    this.spec = spec;
  }
};
function stringCursor(spec, state, from, to2) {
  return new SearchCursor(state.doc, spec.unquoted, from, to2, spec.caseSensitive ? void 0 : (x2) => x2.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
}
function stringWordTest(doc, categorizer) {
  return (from, to2, buf, bufPos) => {
    if (bufPos > from || bufPos + buf.length < to2) {
      bufPos = Math.max(0, from - 2);
      buf = doc.sliceString(bufPos, Math.min(doc.length, to2 + 2));
    }
    return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to2 - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to2 - bufPos)) != CharCategory.Word);
  };
}
var StringQuery = class extends QueryType {
  constructor(spec) {
    super(spec);
  }
  nextMatch(state, curFrom, curTo) {
    let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
    if (cursor.done)
      cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();
    return cursor.done ? null : cursor.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(state, from, to2) {
    for (let pos = to2; ; ) {
      let start = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
      let cursor = stringCursor(this.spec, state, start, pos), range = null;
      while (!cursor.nextOverlapping().done)
        range = cursor.value;
      if (range)
        return range;
      if (start == from)
        return null;
      pos -= 1e4;
    }
  }
  prevMatch(state, curFrom, curTo) {
    return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
  }
  getReplacement(_result) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(state, limit) {
    let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor.value);
    }
    return ranges;
  }
  highlight(state, from, to2, add2) {
    let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to2 + this.spec.unquoted.length, state.doc.length));
    while (!cursor.next().done)
      add2(cursor.value.from, cursor.value.to);
  }
};
function regexpCursor(spec, state, from, to2) {
  return new RegExpCursor(state.doc, spec.search, {
    ignoreCase: !spec.caseSensitive,
    test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
  }, from, to2);
}
function charBefore(str, index) {
  return str.slice(findClusterBreak(str, index, false), index);
}
function charAfter(str, index) {
  return str.slice(index, findClusterBreak(str, index));
}
function regexpWordTest(categorizer) {
  return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
}
var RegExpQuery = class extends QueryType {
  nextMatch(state, curFrom, curTo) {
    let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();
    if (cursor.done)
      cursor = regexpCursor(this.spec, state, 0, curFrom).next();
    return cursor.done ? null : cursor.value;
  }
  prevMatchInRange(state, from, to2) {
    for (let size = 1; ; size++) {
      let start = Math.max(
        from,
        to2 - size * 1e4
        /* FindPrev.ChunkSize */
      );
      let cursor = regexpCursor(this.spec, state, start, to2), range = null;
      while (!cursor.next().done)
        range = cursor.value;
      if (range && (start == from || range.from > start + 10))
        return range;
      if (start == from)
        return null;
    }
  }
  prevMatch(state, curFrom, curTo) {
    return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
  }
  getReplacement(result) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (m5, i4) => i4 == "$" ? "$" : i4 == "&" ? result.match[0] : i4 != "0" && +i4 < result.match.length ? result.match[i4] : m5);
  }
  matchAll(state, limit) {
    let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor.value);
    }
    return ranges;
  }
  highlight(state, from, to2, add2) {
    let cursor = regexpCursor(this.spec, state, Math.max(
      0,
      from - 250
      /* RegExp.HighlightMargin */
    ), Math.min(to2 + 250, state.doc.length));
    while (!cursor.next().done)
      add2(cursor.value.from, cursor.value.to);
  }
};
var setSearchQuery = StateEffect.define();
var togglePanel = StateEffect.define();
var searchState = StateField.define({
  create(state) {
    return new SearchState(defaultQuery(state).create(), null);
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setSearchQuery))
        value = new SearchState(effect.value.create(), value.panel);
      else if (effect.is(togglePanel))
        value = new SearchState(value.query, effect.value ? createSearchPanel : null);
    }
    return value;
  },
  provide: (f3) => showPanel.from(f3, (val) => val.panel)
});
var SearchState = class {
  constructor(query, panel) {
    this.query = query;
    this.panel = panel;
  }
};
var matchMark = Decoration.mark({ class: "cm-searchMatch" });
var selectedMatchMark = Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
var searchHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.decorations = this.highlight(view.state.field(searchState));
  }
  update(update) {
    let state = update.state.field(searchState);
    if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
      this.decorations = this.highlight(state);
  }
  highlight({ query, panel }) {
    if (!panel || !query.spec.valid)
      return Decoration.none;
    let { view } = this;
    let builder = new RangeSetBuilder();
    for (let i4 = 0, ranges = view.visibleRanges, l2 = ranges.length; i4 < l2; i4++) {
      let { from, to: to2 } = ranges[i4];
      while (i4 < l2 - 1 && to2 > ranges[i4 + 1].from - 2 * 250)
        to2 = ranges[++i4].to;
      query.highlight(view.state, from, to2, (from2, to3) => {
        let selected = view.state.selection.ranges.some((r4) => r4.from == from2 && r4.to == to3);
        builder.add(from2, to3, selected ? selectedMatchMark : matchMark);
      });
    }
    return builder.finish();
  }
}, {
  decorations: (v2) => v2.decorations
});
function searchCommand(f3) {
  return (view) => {
    let state = view.state.field(searchState, false);
    return state && state.query.spec.valid ? f3(view, state) : openSearchPanel(view);
  };
}
var findNext = searchCommand((view, { query }) => {
  let { to: to2 } = view.state.selection.main;
  let next = query.nextMatch(view.state, to2, to2);
  if (!next)
    return false;
  let selection = EditorSelection.single(next.from, next.to);
  let config = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection,
    effects: [announceMatch(view, next), config.scrollToMatch(selection.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
var findPrevious = searchCommand((view, { query }) => {
  let { state } = view, { from } = state.selection.main;
  let prev = query.prevMatch(state, from, from);
  if (!prev)
    return false;
  let selection = EditorSelection.single(prev.from, prev.to);
  let config = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection,
    effects: [announceMatch(view, prev), config.scrollToMatch(selection.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
var selectMatches = searchCommand((view, { query }) => {
  let ranges = query.matchAll(view.state, 1e3);
  if (!ranges || !ranges.length)
    return false;
  view.dispatch({
    selection: EditorSelection.create(ranges.map((r4) => EditorSelection.range(r4.from, r4.to))),
    userEvent: "select.search.matches"
  });
  return true;
});
var selectSelectionMatches = ({ state, dispatch }) => {
  let sel = state.selection;
  if (sel.ranges.length > 1 || sel.main.empty)
    return false;
  let { from, to: to2 } = sel.main;
  let ranges = [], main = 0;
  for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to2)); !cur.next().done; ) {
    if (ranges.length > 1e3)
      return false;
    if (cur.value.from == from)
      main = ranges.length;
    ranges.push(EditorSelection.range(cur.value.from, cur.value.to));
  }
  dispatch(state.update({
    selection: EditorSelection.create(ranges, main),
    userEvent: "select.search.matches"
  }));
  return true;
};
var replaceNext = searchCommand((view, { query }) => {
  let { state } = view, { from, to: to2 } = state.selection.main;
  if (state.readOnly)
    return false;
  let next = query.nextMatch(state, from, from);
  if (!next)
    return false;
  let changes = [], selection, replacement;
  let effects = [];
  if (next.from == from && next.to == to2) {
    replacement = state.toText(query.getReplacement(next));
    changes.push({ from: next.from, to: next.to, insert: replacement });
    next = query.nextMatch(state, next.from, next.to);
    effects.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
  }
  if (next) {
    let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
    selection = EditorSelection.single(next.from - off, next.to - off);
    effects.push(announceMatch(view, next));
    effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));
  }
  view.dispatch({
    changes,
    selection,
    effects,
    userEvent: "input.replace"
  });
  return true;
});
var replaceAll = searchCommand((view, { query }) => {
  if (view.state.readOnly)
    return false;
  let changes = query.matchAll(view.state, 1e9).map((match) => {
    let { from, to: to2 } = match;
    return { from, to: to2, insert: query.getReplacement(match) };
  });
  if (!changes.length)
    return false;
  let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
  view.dispatch({
    changes,
    effects: EditorView.announce.of(announceText),
    userEvent: "input.replace.all"
  });
  return true;
});
function createSearchPanel(view) {
  return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
  var _a, _b, _c, _d, _e2;
  let sel = state.selection.main;
  let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
  if (fallback && !selText)
    return fallback;
  let config = state.facet(searchConfigFacet);
  return new SearchQuery({
    search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\n/g, "\\n"),
    caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,
    literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,
    regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,
    wholeWord: (_e2 = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e2 !== void 0 ? _e2 : config.wholeWord
  });
}
function getSearchInput(view) {
  let panel = getPanel(view, createSearchPanel);
  return panel && panel.dom.querySelector("[main-field]");
}
function selectSearchInput(view) {
  let input = getSearchInput(view);
  if (input && input == view.root.activeElement)
    input.select();
}
var openSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (state && state.panel) {
    let searchInput = getSearchInput(view);
    if (searchInput && searchInput != view.root.activeElement) {
      let query = defaultQuery(view.state, state.query.spec);
      if (query.valid)
        view.dispatch({ effects: setSearchQuery.of(query) });
      searchInput.focus();
      searchInput.select();
    }
  } else {
    view.dispatch({ effects: [
      togglePanel.of(true),
      state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
    ] });
  }
  return true;
};
var closeSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (!state || !state.panel)
    return false;
  let panel = getPanel(view, createSearchPanel);
  if (panel && panel.dom.contains(view.root.activeElement))
    view.focus();
  view.dispatch({ effects: togglePanel.of(false) });
  return true;
};
var searchKeymap = [
  { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
  { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: selectSelectionMatches },
  { key: "Mod-Alt-g", run: gotoLine },
  { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
];
var SearchPanel = class {
  constructor(view) {
    this.view = view;
    let query = this.query = view.state.field(searchState).query.spec;
    this.commit = this.commit.bind(this);
    this.searchField = crelt("input", {
      value: query.search,
      placeholder: phrase(view, "Find"),
      "aria-label": phrase(view, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.replaceField = crelt("input", {
      value: query.replace,
      placeholder: phrase(view, "Replace"),
      "aria-label": phrase(view, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.caseField = crelt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: query.caseSensitive,
      onchange: this.commit
    });
    this.reField = crelt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: query.regexp,
      onchange: this.commit
    });
    this.wordField = crelt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: query.wholeWord,
      onchange: this.commit
    });
    function button(name, onclick, content) {
      return crelt("button", { class: "cm-button", name, onclick, type: "button" }, content);
    }
    this.dom = crelt("div", { onkeydown: (e4) => this.keydown(e4), class: "cm-search" }, [
      this.searchField,
      button("next", () => findNext(view), [phrase(view, "next")]),
      button("prev", () => findPrevious(view), [phrase(view, "previous")]),
      button("select", () => selectMatches(view), [phrase(view, "all")]),
      crelt("label", null, [this.caseField, phrase(view, "match case")]),
      crelt("label", null, [this.reField, phrase(view, "regexp")]),
      crelt("label", null, [this.wordField, phrase(view, "by word")]),
      ...view.state.readOnly ? [] : [
        crelt("br"),
        this.replaceField,
        button("replace", () => replaceNext(view), [phrase(view, "replace")]),
        button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
      ],
      crelt("button", {
        name: "close",
        onclick: () => closeSearchPanel(view),
        "aria-label": phrase(view, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let query = new SearchQuery({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    if (!query.eq(this.query)) {
      this.query = query;
      this.view.dispatch({ effects: setSearchQuery.of(query) });
    }
  }
  keydown(e4) {
    if (runScopeHandlers(this.view, e4, "search-panel")) {
      e4.preventDefault();
    } else if (e4.keyCode == 13 && e4.target == this.searchField) {
      e4.preventDefault();
      (e4.shiftKey ? findPrevious : findNext)(this.view);
    } else if (e4.keyCode == 13 && e4.target == this.replaceField) {
      e4.preventDefault();
      replaceNext(this.view);
    }
  }
  update(update) {
    for (let tr of update.transactions)
      for (let effect of tr.effects) {
        if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
          this.setQuery(effect.value);
      }
  }
  setQuery(query) {
    this.query = query;
    this.searchField.value = query.search;
    this.replaceField.value = query.replace;
    this.caseField.checked = query.caseSensitive;
    this.reField.checked = query.regexp;
    this.wordField.checked = query.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(searchConfigFacet).top;
  }
};
function phrase(view, phrase2) {
  return view.state.phrase(phrase2);
}
var AnnounceMargin = 30;
var Break = /[\s\.,:;?!]/;
function announceMatch(view, { from, to: to2 }) {
  let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to2).to;
  let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to2 + AnnounceMargin);
  let text = view.state.sliceDoc(start, end);
  if (start != line.from) {
    for (let i4 = 0; i4 < AnnounceMargin; i4++)
      if (!Break.test(text[i4 + 1]) && Break.test(text[i4])) {
        text = text.slice(i4);
        break;
      }
  }
  if (end != lineEnd) {
    for (let i4 = text.length - 1; i4 > text.length - AnnounceMargin; i4--)
      if (!Break.test(text[i4 - 1]) && Break.test(text[i4])) {
        text = text.slice(0, i4);
        break;
      }
  }
  return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
}
var baseTheme = EditorView.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
var searchExtensions = [
  searchState,
  Prec.low(searchHighlighter),
  baseTheme
];

// node_modules/@codemirror/lint/dist/index.js
var SelectedDiagnostic = class {
  constructor(from, to2, diagnostic) {
    this.from = from;
    this.to = to2;
    this.diagnostic = diagnostic;
  }
};
var LintState = class _LintState {
  constructor(diagnostics, panel, selected) {
    this.diagnostics = diagnostics;
    this.panel = panel;
    this.selected = selected;
  }
  static init(diagnostics, panel, state) {
    let markedDiagnostics = diagnostics;
    let diagnosticFilter = state.facet(lintConfig).markerFilter;
    if (diagnosticFilter)
      markedDiagnostics = diagnosticFilter(markedDiagnostics);
    let ranges = Decoration.set(markedDiagnostics.map((d3) => {
      return d3.from == d3.to || d3.from == d3.to - 1 && state.doc.lineAt(d3.from).to == d3.from ? Decoration.widget({
        widget: new DiagnosticWidget(d3),
        diagnostic: d3
      }).range(d3.from) : Decoration.mark({
        attributes: { class: "cm-lintRange cm-lintRange-" + d3.severity + (d3.markClass ? " " + d3.markClass : "") },
        diagnostic: d3
      }).range(d3.from, d3.to);
    }), true);
    return new _LintState(ranges, panel, findDiagnostic(ranges));
  }
};
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
  let found = null;
  diagnostics.between(after, 1e9, (from, to2, { spec }) => {
    if (diagnostic && spec.diagnostic != diagnostic)
      return;
    found = new SelectedDiagnostic(from, to2, spec.diagnostic);
    return false;
  });
  return found;
}
function hideTooltip(tr, tooltip) {
  let line = tr.startState.doc.lineAt(tooltip.pos);
  return !!(tr.effects.some((e4) => e4.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, line.to));
}
function maybeEnableLint(state, effects) {
  return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));
}
function setDiagnostics(state, diagnostics) {
  return {
    effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
  };
}
var setDiagnosticsEffect = StateEffect.define();
var togglePanel2 = StateEffect.define();
var movePanelSelection = StateEffect.define();
var lintState = StateField.define({
  create() {
    return new LintState(Decoration.none, null, null);
  },
  update(value, tr) {
    if (tr.docChanged) {
      let mapped = value.diagnostics.map(tr.changes), selected = null;
      if (value.selected) {
        let selPos = tr.changes.mapPos(value.selected.from, 1);
        selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
      }
      value = new LintState(mapped, value.panel, selected);
    }
    for (let effect of tr.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        value = LintState.init(effect.value, value.panel, tr.state);
      } else if (effect.is(togglePanel2)) {
        value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
      } else if (effect.is(movePanelSelection)) {
        value = new LintState(value.diagnostics, value.panel, effect.value);
      }
    }
    return value;
  },
  provide: (f3) => [
    showPanel.from(f3, (val) => val.panel),
    EditorView.decorations.from(f3, (s3) => s3.diagnostics)
  ]
});
var activeMark = Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
function lintTooltip(view, pos, side) {
  let { diagnostics } = view.state.field(lintState);
  let found = [], stackStart = 2e8, stackEnd = 0;
  diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to2, { spec }) => {
    if (pos >= from && pos <= to2 && (from == to2 || (pos > from || side > 0) && (pos < to2 || side < 0))) {
      found.push(spec.diagnostic);
      stackStart = Math.min(from, stackStart);
      stackEnd = Math.max(to2, stackEnd);
    }
  });
  let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
  if (diagnosticFilter)
    found = diagnosticFilter(found);
  if (!found.length)
    return null;
  return {
    pos: stackStart,
    end: stackEnd,
    above: view.state.doc.lineAt(stackStart).to < stackEnd,
    create() {
      return { dom: diagnosticsTooltip(view, found) };
    }
  };
}
function diagnosticsTooltip(view, diagnostics) {
  return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d3) => renderDiagnostic(view, d3, false)));
}
var openLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel2.of(true)]) });
  let panel = getPanel(view, LintPanel.open);
  if (panel)
    panel.dom.querySelector(".cm-panel-lint ul").focus();
  return true;
};
var closeLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    return false;
  view.dispatch({ effects: togglePanel2.of(false) });
  return true;
};
var nextDiagnostic = (view) => {
  let field = view.state.field(lintState, false);
  if (!field)
    return false;
  let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
  if (!next.value) {
    next = field.diagnostics.iter(0);
    if (!next.value || next.from == sel.from && next.to == sel.to)
      return false;
  }
  view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
  return true;
};
var lintKeymap = [
  { key: "Mod-Shift-m", run: openLintPanel, preventDefault: true },
  { key: "F8", run: nextDiagnostic }
];
var lintPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.timeout = -1;
    this.set = true;
    let { delay } = view.state.facet(lintConfig);
    this.lintTime = Date.now() + delay;
    this.run = this.run.bind(this);
    this.timeout = setTimeout(this.run, delay);
  }
  run() {
    let now = Date.now();
    if (now < this.lintTime - 10) {
      this.timeout = setTimeout(this.run, this.lintTime - now);
    } else {
      this.set = false;
      let { state } = this.view, { sources } = state.facet(lintConfig);
      Promise.all(sources.map((source) => Promise.resolve(source(this.view)))).then((annotations) => {
        let all = annotations.reduce((a2, b4) => a2.concat(b4));
        if (this.view.state.doc == state.doc)
          this.view.dispatch(setDiagnostics(this.view.state, all));
      }, (error) => {
        logException(this.view.state, error);
      });
    }
  }
  update(update) {
    let config = update.state.facet(lintConfig);
    if (update.docChanged || config != update.startState.facet(lintConfig) || config.needsRefresh && config.needsRefresh(update)) {
      this.lintTime = Date.now() + config.delay;
      if (!this.set) {
        this.set = true;
        this.timeout = setTimeout(this.run, config.delay);
      }
    }
  }
  force() {
    if (this.set) {
      this.lintTime = Date.now();
      this.run();
    }
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
var lintConfig = Facet.define({
  combine(input) {
    return Object.assign({ sources: input.map((i4) => i4.source) }, combineConfig(input.map((i4) => i4.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (a2, b4) => !a2 ? b4 : !b4 ? a2 : (u2) => a2(u2) || b4(u2)
    }));
  }
});
function assignKeys(actions) {
  let assigned = [];
  if (actions)
    actions:
      for (let { name } of actions) {
        for (let i4 = 0; i4 < name.length; i4++) {
          let ch = name[i4];
          if (/[a-zA-Z]/.test(ch) && !assigned.some((c2) => c2.toLowerCase() == ch.toLowerCase())) {
            assigned.push(ch);
            continue actions;
          }
        }
        assigned.push("");
      }
  return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
  var _a;
  let keys = inPanel ? assignKeys(diagnostic.actions) : [];
  return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i4) => {
    let fired = false, click = (e4) => {
      e4.preventDefault();
      if (fired)
        return;
      fired = true;
      let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
      if (found)
        action.apply(view, found.from, found.to);
    };
    let { name } = action, keyIndex = keys[i4] ? name.indexOf(keys[i4]) : -1;
    let nameElt = keyIndex < 0 ? name : [
      name.slice(0, keyIndex),
      crelt("u", name.slice(keyIndex, keyIndex + 1)),
      name.slice(keyIndex + 1)
    ];
    return crelt("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: click,
      onmousedown: click,
      "aria-label": ` Action: ${name}${keyIndex < 0 ? "" : ` (access key "${keys[i4]})"`}.`
    }, nameElt);
  }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
}
var DiagnosticWidget = class extends WidgetType {
  constructor(diagnostic) {
    super();
    this.diagnostic = diagnostic;
  }
  eq(other) {
    return other.diagnostic == this.diagnostic;
  }
  toDOM() {
    return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
};
var PanelItem = class {
  constructor(view, diagnostic) {
    this.diagnostic = diagnostic;
    this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
    this.dom = renderDiagnostic(view, diagnostic, true);
    this.dom.id = this.id;
    this.dom.setAttribute("role", "option");
  }
};
var LintPanel = class _LintPanel {
  constructor(view) {
    this.view = view;
    this.items = [];
    let onkeydown = (event) => {
      if (event.keyCode == 27) {
        closeLintPanel(this.view);
        this.view.focus();
      } else if (event.keyCode == 38 || event.keyCode == 33) {
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      } else if (event.keyCode == 40 || event.keyCode == 34) {
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      } else if (event.keyCode == 36) {
        this.moveSelection(0);
      } else if (event.keyCode == 35) {
        this.moveSelection(this.items.length - 1);
      } else if (event.keyCode == 13) {
        this.view.focus();
      } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);
        for (let i4 = 0; i4 < keys.length; i4++)
          if (keys[i4].toUpperCase().charCodeAt(0) == event.keyCode) {
            let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
            if (found)
              diagnostic.actions[i4].apply(view, found.from, found.to);
          }
      } else {
        return;
      }
      event.preventDefault();
    };
    let onclick = (event) => {
      for (let i4 = 0; i4 < this.items.length; i4++) {
        if (this.items[i4].dom.contains(event.target))
          this.moveSelection(i4);
      }
    };
    this.list = crelt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown,
      onclick
    });
    this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => closeLintPanel(this.view)
    }, "×"));
    this.update();
  }
  get selectedIndex() {
    let selected = this.view.state.field(lintState).selected;
    if (!selected)
      return -1;
    for (let i4 = 0; i4 < this.items.length; i4++)
      if (this.items[i4].diagnostic == selected.diagnostic)
        return i4;
    return -1;
  }
  update() {
    let { diagnostics, selected } = this.view.state.field(lintState);
    let i4 = 0, needsSync = false, newSelectedItem = null;
    diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
      let found = -1, item;
      for (let j2 = i4; j2 < this.items.length; j2++)
        if (this.items[j2].diagnostic == spec.diagnostic) {
          found = j2;
          break;
        }
      if (found < 0) {
        item = new PanelItem(this.view, spec.diagnostic);
        this.items.splice(i4, 0, item);
        needsSync = true;
      } else {
        item = this.items[found];
        if (found > i4) {
          this.items.splice(i4, found - i4);
          needsSync = true;
        }
      }
      if (selected && item.diagnostic == selected.diagnostic) {
        if (!item.dom.hasAttribute("aria-selected")) {
          item.dom.setAttribute("aria-selected", "true");
          newSelectedItem = item;
        }
      } else if (item.dom.hasAttribute("aria-selected")) {
        item.dom.removeAttribute("aria-selected");
      }
      i4++;
    });
    while (i4 < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
      needsSync = true;
      this.items.pop();
    }
    if (this.items.length == 0) {
      this.items.push(new PanelItem(this.view, {
        from: -1,
        to: -1,
        severity: "info",
        message: this.view.state.phrase("No diagnostics")
      }));
      needsSync = true;
    }
    if (newSelectedItem) {
      this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
      this.view.requestMeasure({
        key: this,
        read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
        write: ({ sel, panel }) => {
          let scaleY = panel.height / this.list.offsetHeight;
          if (sel.top < panel.top)
            this.list.scrollTop -= (panel.top - sel.top) / scaleY;
          else if (sel.bottom > panel.bottom)
            this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
        }
      });
    } else if (this.selectedIndex < 0) {
      this.list.removeAttribute("aria-activedescendant");
    }
    if (needsSync)
      this.sync();
  }
  sync() {
    let domPos = this.list.firstChild;
    function rm() {
      let prev = domPos;
      domPos = prev.nextSibling;
      prev.remove();
    }
    for (let item of this.items) {
      if (item.dom.parentNode == this.list) {
        while (domPos != item.dom)
          rm();
        domPos = item.dom.nextSibling;
      } else {
        this.list.insertBefore(item.dom, domPos);
      }
    }
    while (domPos)
      rm();
  }
  moveSelection(selectedIndex) {
    if (this.selectedIndex < 0)
      return;
    let field = this.view.state.field(lintState);
    let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
    if (!selection)
      return;
    this.view.dispatch({
      selection: { anchor: selection.from, head: selection.to },
      scrollIntoView: true,
      effects: movePanelSelection.of(selection)
    });
  }
  static open(view) {
    return new _LintPanel(view);
  }
};
function svg(content, attrs = `viewBox="0 0 40 40"`) {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content)}</svg>')`;
}
function underline(color) {
  return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
}
var baseTheme2 = EditorView.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: underline("#d11") },
  ".cm-lintRange-warning": { backgroundImage: underline("orange") },
  ".cm-lintRange-info": { backgroundImage: underline("#999") },
  ".cm-lintRange-hint": { backgroundImage: underline("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function severityWeight(sev) {
  return sev == "error" ? 4 : sev == "warning" ? 3 : sev == "info" ? 2 : 1;
}
var LintGutterMarker = class extends GutterMarker {
  constructor(diagnostics) {
    super();
    this.diagnostics = diagnostics;
    this.severity = diagnostics.reduce((max, d3) => severityWeight(max) < severityWeight(d3.severity) ? d3.severity : max, "hint");
  }
  toDOM(view) {
    let elt = document.createElement("div");
    elt.className = "cm-lint-marker cm-lint-marker-" + this.severity;
    let diagnostics = this.diagnostics;
    let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;
    if (diagnosticsFilter)
      diagnostics = diagnosticsFilter(diagnostics);
    if (diagnostics.length)
      elt.onmouseover = () => gutterMarkerMouseOver(view, elt, diagnostics);
    return elt;
  }
};
function trackHoverOn(view, marker) {
  let mousemove = (event) => {
    let rect = marker.getBoundingClientRect();
    if (event.clientX > rect.left - 10 && event.clientX < rect.right + 10 && event.clientY > rect.top - 10 && event.clientY < rect.bottom + 10)
      return;
    for (let target = event.target; target; target = target.parentNode) {
      if (target.nodeType == 1 && target.classList.contains("cm-tooltip-lint"))
        return;
    }
    window.removeEventListener("mousemove", mousemove);
    if (view.state.field(lintGutterTooltip))
      view.dispatch({ effects: setLintGutterTooltip.of(null) });
  };
  window.addEventListener("mousemove", mousemove);
}
function gutterMarkerMouseOver(view, marker, diagnostics) {
  function hovered() {
    let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);
    const linePos = view.coordsAtPos(line.from);
    if (linePos) {
      view.dispatch({ effects: setLintGutterTooltip.of({
        pos: line.from,
        above: false,
        create() {
          return {
            dom: diagnosticsTooltip(view, diagnostics),
            getCoords: () => marker.getBoundingClientRect()
          };
        }
      }) });
    }
    marker.onmouseout = marker.onmousemove = null;
    trackHoverOn(view, marker);
  }
  let { hoverTime } = view.state.facet(lintGutterConfig);
  let hoverTimeout = setTimeout(hovered, hoverTime);
  marker.onmouseout = () => {
    clearTimeout(hoverTimeout);
    marker.onmouseout = marker.onmousemove = null;
  };
  marker.onmousemove = () => {
    clearTimeout(hoverTimeout);
    hoverTimeout = setTimeout(hovered, hoverTime);
  };
}
function markersForDiagnostics(doc, diagnostics) {
  let byLine = /* @__PURE__ */ Object.create(null);
  for (let diagnostic of diagnostics) {
    let line = doc.lineAt(diagnostic.from);
    (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);
  }
  let markers = [];
  for (let line in byLine) {
    markers.push(new LintGutterMarker(byLine[line]).range(+line));
  }
  return RangeSet.of(markers, true);
}
var lintGutterExtension = gutter({
  class: "cm-gutter-lint",
  markers: (view) => view.state.field(lintGutterMarkers)
});
var lintGutterMarkers = StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(markers, tr) {
    markers = markers.map(tr.changes);
    let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;
    for (let effect of tr.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        let diagnostics = effect.value;
        if (diagnosticFilter)
          diagnostics = diagnosticFilter(diagnostics || []);
        markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));
      }
    }
    return markers;
  }
});
var setLintGutterTooltip = StateEffect.define();
var lintGutterTooltip = StateField.define({
  create() {
    return null;
  },
  update(tooltip, tr) {
    if (tooltip && tr.docChanged)
      tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), { pos: tr.changes.mapPos(tooltip.pos) });
    return tr.effects.reduce((t3, e4) => e4.is(setLintGutterTooltip) ? e4.value : t3, tooltip);
  },
  provide: (field) => showTooltip.from(field)
});
var lintGutterTheme = EditorView.baseTheme({
  ".cm-gutter-lint": {
    width: "1.4em",
    "& .cm-gutterElement": {
      padding: ".2em"
    }
  },
  ".cm-lint-marker": {
    width: "1em",
    height: "1em"
  },
  ".cm-lint-marker-info": {
    content: svg(`<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>`)
  },
  ".cm-lint-marker-warning": {
    content: svg(`<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>`)
  },
  ".cm-lint-marker-error": {
    content: svg(`<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>`)
  }
});
var lintExtensions = [
  lintState,
  EditorView.decorations.compute([lintState], (state) => {
    let { selected, panel } = state.field(lintState);
    return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
      activeMark.range(selected.from, selected.to)
    ]);
  }),
  hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
  baseTheme2
];
var lintGutterConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      hoverTime: 300,
      markerFilter: null,
      tooltipFilter: null
    });
  }
});

// node_modules/codemirror/dist/index.js
var basicSetup = (() => [
  lineNumbers(),
  highlightActiveLineGutter(),
  highlightSpecialChars(),
  history(),
  foldGutter(),
  drawSelection(),
  dropCursor(),
  EditorState.allowMultipleSelections.of(true),
  indentOnInput(),
  syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
  bracketMatching(),
  closeBrackets(),
  autocompletion(),
  rectangularSelection(),
  crosshairCursor(),
  highlightActiveLine(),
  highlightSelectionMatches(),
  keymap.of([
    ...closeBracketsKeymap,
    ...defaultKeymap,
    ...searchKeymap,
    ...historyKeymap,
    ...foldKeymap,
    ...completionKeymap,
    ...lintKeymap
  ])
])();
var minimalSetup = (() => [
  highlightSpecialChars(),
  history(),
  drawSelection(),
  syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
  keymap.of([
    ...defaultKeymap,
    ...historyKeymap
  ])
])();

// node_modules/@codemirror/language-data/dist/index.js
function legacy(parser) {
  return new LanguageSupport(StreamLanguage.define(parser));
}
function sql(dialectName) {
  return import("./dist-FZAUOJYQ.js").then((m5) => m5.sql({ dialect: m5[dialectName] }));
}
var languages = [
  // New-style language modes
  LanguageDescription.of({
    name: "C",
    extensions: ["c", "h", "ino"],
    load() {
      return import("./dist-EVKMI7F3.js").then((m5) => m5.cpp());
    }
  }),
  LanguageDescription.of({
    name: "C++",
    alias: ["cpp"],
    extensions: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"],
    load() {
      return import("./dist-EVKMI7F3.js").then((m5) => m5.cpp());
    }
  }),
  LanguageDescription.of({
    name: "CQL",
    alias: ["cassandra"],
    extensions: ["cql"],
    load() {
      return sql("Cassandra");
    }
  }),
  LanguageDescription.of({
    name: "CSS",
    extensions: ["css"],
    load() {
      return import("./dist-GXWKFKZC.js").then((m5) => m5.css());
    }
  }),
  LanguageDescription.of({
    name: "HTML",
    alias: ["xhtml"],
    extensions: ["html", "htm", "handlebars", "hbs"],
    load() {
      return import("./dist-MLTC5FV4.js").then((m5) => m5.html());
    }
  }),
  LanguageDescription.of({
    name: "Java",
    extensions: ["java"],
    load() {
      return import("./dist-CT5XKKSW.js").then((m5) => m5.java());
    }
  }),
  LanguageDescription.of({
    name: "JavaScript",
    alias: ["ecmascript", "js", "node"],
    extensions: ["js", "mjs", "cjs"],
    load() {
      return import("./dist-44GX4N7F.js").then((m5) => m5.javascript());
    }
  }),
  LanguageDescription.of({
    name: "JSON",
    alias: ["json5"],
    extensions: ["json", "map"],
    load() {
      return import("./dist-VW3MOIQA.js").then((m5) => m5.json());
    }
  }),
  LanguageDescription.of({
    name: "JSX",
    extensions: ["jsx"],
    load() {
      return import("./dist-44GX4N7F.js").then((m5) => m5.javascript({ jsx: true }));
    }
  }),
  LanguageDescription.of({
    name: "LESS",
    extensions: ["less"],
    load() {
      return import("./dist-7OQ467T3.js").then((m5) => m5.less());
    }
  }),
  LanguageDescription.of({
    name: "MariaDB SQL",
    load() {
      return sql("MariaSQL");
    }
  }),
  LanguageDescription.of({
    name: "Markdown",
    extensions: ["md", "markdown", "mkd"],
    load() {
      return import("./dist-NWC2T3QD.js").then((m5) => m5.markdown());
    }
  }),
  LanguageDescription.of({
    name: "MS SQL",
    load() {
      return sql("MSSQL");
    }
  }),
  LanguageDescription.of({
    name: "MySQL",
    load() {
      return sql("MySQL");
    }
  }),
  LanguageDescription.of({
    name: "PHP",
    extensions: ["php", "php3", "php4", "php5", "php7", "phtml"],
    load() {
      return import("./dist-OUNLHIWW.js").then((m5) => m5.php());
    }
  }),
  LanguageDescription.of({
    name: "PLSQL",
    extensions: ["pls"],
    load() {
      return sql("PLSQL");
    }
  }),
  LanguageDescription.of({
    name: "PostgreSQL",
    load() {
      return sql("PostgreSQL");
    }
  }),
  LanguageDescription.of({
    name: "Python",
    extensions: ["BUILD", "bzl", "py", "pyw"],
    filename: /^(BUCK|BUILD)$/,
    load() {
      return import("./dist-ZYEC7OEG.js").then((m5) => m5.python());
    }
  }),
  LanguageDescription.of({
    name: "Rust",
    extensions: ["rs"],
    load() {
      return import("./dist-WYEOPNDK.js").then((m5) => m5.rust());
    }
  }),
  LanguageDescription.of({
    name: "Sass",
    extensions: ["sass"],
    load() {
      return import("./dist-ABYK7LTO.js").then((m5) => m5.sass({ indented: true }));
    }
  }),
  LanguageDescription.of({
    name: "SCSS",
    extensions: ["scss"],
    load() {
      return import("./dist-ABYK7LTO.js").then((m5) => m5.sass());
    }
  }),
  LanguageDescription.of({
    name: "SQL",
    extensions: ["sql"],
    load() {
      return sql("StandardSQL");
    }
  }),
  LanguageDescription.of({
    name: "SQLite",
    load() {
      return sql("SQLite");
    }
  }),
  LanguageDescription.of({
    name: "TSX",
    extensions: ["tsx"],
    load() {
      return import("./dist-44GX4N7F.js").then((m5) => m5.javascript({ jsx: true, typescript: true }));
    }
  }),
  LanguageDescription.of({
    name: "TypeScript",
    alias: ["ts"],
    extensions: ["ts"],
    load() {
      return import("./dist-44GX4N7F.js").then((m5) => m5.javascript({ typescript: true }));
    }
  }),
  LanguageDescription.of({
    name: "WebAssembly",
    extensions: ["wat", "wast"],
    load() {
      return import("./dist-WZKZLT7N.js").then((m5) => m5.wast());
    }
  }),
  LanguageDescription.of({
    name: "XML",
    alias: ["rss", "wsdl", "xsd"],
    extensions: ["xml", "xsl", "xsd", "svg"],
    load() {
      return import("./dist-DGFY25EN.js").then((m5) => m5.xml());
    }
  }),
  // Legacy modes ported from CodeMirror 5
  LanguageDescription.of({
    name: "APL",
    extensions: ["dyalog", "apl"],
    load() {
      return import("./apl-ULYEK3IM.js").then((m5) => legacy(m5.apl));
    }
  }),
  LanguageDescription.of({
    name: "PGP",
    alias: ["asciiarmor"],
    extensions: ["asc", "pgp", "sig"],
    load() {
      return import("./asciiarmor-LVLJGMHE.js").then((m5) => legacy(m5.asciiArmor));
    }
  }),
  LanguageDescription.of({
    name: "ASN.1",
    extensions: ["asn", "asn1"],
    load() {
      return import("./asn1-LGL33PU5.js").then((m5) => legacy(m5.asn1({})));
    }
  }),
  LanguageDescription.of({
    name: "Asterisk",
    filename: /^extensions\.conf$/i,
    load() {
      return import("./asterisk-XLSGJ724.js").then((m5) => legacy(m5.asterisk));
    }
  }),
  LanguageDescription.of({
    name: "Brainfuck",
    extensions: ["b", "bf"],
    load() {
      return import("./brainfuck-EWJGNWGV.js").then((m5) => legacy(m5.brainfuck));
    }
  }),
  LanguageDescription.of({
    name: "Cobol",
    extensions: ["cob", "cpy"],
    load() {
      return import("./cobol-J2ZRYBGG.js").then((m5) => legacy(m5.cobol));
    }
  }),
  LanguageDescription.of({
    name: "C#",
    alias: ["csharp", "cs"],
    extensions: ["cs"],
    load() {
      return import("./clike-TKJQLYRZ.js").then((m5) => legacy(m5.csharp));
    }
  }),
  LanguageDescription.of({
    name: "Clojure",
    extensions: ["clj", "cljc", "cljx"],
    load() {
      return import("./clojure-SODCBHYJ.js").then((m5) => legacy(m5.clojure));
    }
  }),
  LanguageDescription.of({
    name: "ClojureScript",
    extensions: ["cljs"],
    load() {
      return import("./clojure-SODCBHYJ.js").then((m5) => legacy(m5.clojure));
    }
  }),
  LanguageDescription.of({
    name: "Closure Stylesheets (GSS)",
    extensions: ["gss"],
    load() {
      return import("./css-XDE5AZ25.js").then((m5) => legacy(m5.gss));
    }
  }),
  LanguageDescription.of({
    name: "CMake",
    extensions: ["cmake", "cmake.in"],
    filename: /^CMakeLists\.txt$/,
    load() {
      return import("./cmake-XSZPSUDO.js").then((m5) => legacy(m5.cmake));
    }
  }),
  LanguageDescription.of({
    name: "CoffeeScript",
    alias: ["coffee", "coffee-script"],
    extensions: ["coffee"],
    load() {
      return import("./coffeescript-3YEL2622.js").then((m5) => legacy(m5.coffeeScript));
    }
  }),
  LanguageDescription.of({
    name: "Common Lisp",
    alias: ["lisp"],
    extensions: ["cl", "lisp", "el"],
    load() {
      return import("./commonlisp-SAK77MRA.js").then((m5) => legacy(m5.commonLisp));
    }
  }),
  LanguageDescription.of({
    name: "Cypher",
    extensions: ["cyp", "cypher"],
    load() {
      return import("./cypher-EC3JZD7A.js").then((m5) => legacy(m5.cypher));
    }
  }),
  LanguageDescription.of({
    name: "Cython",
    extensions: ["pyx", "pxd", "pxi"],
    load() {
      return import("./python-G7KELS3E.js").then((m5) => legacy(m5.cython));
    }
  }),
  LanguageDescription.of({
    name: "Crystal",
    extensions: ["cr"],
    load() {
      return import("./crystal-37R557TR.js").then((m5) => legacy(m5.crystal));
    }
  }),
  LanguageDescription.of({
    name: "D",
    extensions: ["d"],
    load() {
      return import("./d-PDDSBZV6.js").then((m5) => legacy(m5.d));
    }
  }),
  LanguageDescription.of({
    name: "Dart",
    extensions: ["dart"],
    load() {
      return import("./clike-TKJQLYRZ.js").then((m5) => legacy(m5.dart));
    }
  }),
  LanguageDescription.of({
    name: "diff",
    extensions: ["diff", "patch"],
    load() {
      return import("./diff-B6HBZJ3I.js").then((m5) => legacy(m5.diff));
    }
  }),
  LanguageDescription.of({
    name: "Dockerfile",
    filename: /^Dockerfile$/,
    load() {
      return import("./dockerfile-6RC7TNRD.js").then((m5) => legacy(m5.dockerFile));
    }
  }),
  LanguageDescription.of({
    name: "DTD",
    extensions: ["dtd"],
    load() {
      return import("./dtd-Z6PLRL6X.js").then((m5) => legacy(m5.dtd));
    }
  }),
  LanguageDescription.of({
    name: "Dylan",
    extensions: ["dylan", "dyl", "intr"],
    load() {
      return import("./dylan-KNJ5TDIG.js").then((m5) => legacy(m5.dylan));
    }
  }),
  LanguageDescription.of({
    name: "EBNF",
    load() {
      return import("./ebnf-R757KWIO.js").then((m5) => legacy(m5.ebnf));
    }
  }),
  LanguageDescription.of({
    name: "ECL",
    extensions: ["ecl"],
    load() {
      return import("./ecl-3CQZHAMF.js").then((m5) => legacy(m5.ecl));
    }
  }),
  LanguageDescription.of({
    name: "edn",
    extensions: ["edn"],
    load() {
      return import("./clojure-SODCBHYJ.js").then((m5) => legacy(m5.clojure));
    }
  }),
  LanguageDescription.of({
    name: "Eiffel",
    extensions: ["e"],
    load() {
      return import("./eiffel-JZFV27PS.js").then((m5) => legacy(m5.eiffel));
    }
  }),
  LanguageDescription.of({
    name: "Elm",
    extensions: ["elm"],
    load() {
      return import("./elm-SZORKKTS.js").then((m5) => legacy(m5.elm));
    }
  }),
  LanguageDescription.of({
    name: "Erlang",
    extensions: ["erl"],
    load() {
      return import("./erlang-QPULI6YR.js").then((m5) => legacy(m5.erlang));
    }
  }),
  LanguageDescription.of({
    name: "Esper",
    load() {
      return import("./sql-NU65DSYM.js").then((m5) => legacy(m5.esper));
    }
  }),
  LanguageDescription.of({
    name: "Factor",
    extensions: ["factor"],
    load() {
      return import("./factor-ID7E2JOC.js").then((m5) => legacy(m5.factor));
    }
  }),
  LanguageDescription.of({
    name: "FCL",
    load() {
      return import("./fcl-LPEHW36V.js").then((m5) => legacy(m5.fcl));
    }
  }),
  LanguageDescription.of({
    name: "Forth",
    extensions: ["forth", "fth", "4th"],
    load() {
      return import("./forth-YRP7YWAT.js").then((m5) => legacy(m5.forth));
    }
  }),
  LanguageDescription.of({
    name: "Fortran",
    extensions: ["f", "for", "f77", "f90", "f95"],
    load() {
      return import("./fortran-WSRYJRWL.js").then((m5) => legacy(m5.fortran));
    }
  }),
  LanguageDescription.of({
    name: "F#",
    alias: ["fsharp"],
    extensions: ["fs"],
    load() {
      return import("./mllike-R53JJBBD.js").then((m5) => legacy(m5.fSharp));
    }
  }),
  LanguageDescription.of({
    name: "Gas",
    extensions: ["s"],
    load() {
      return import("./gas-LVCEKEKT.js").then((m5) => legacy(m5.gas));
    }
  }),
  LanguageDescription.of({
    name: "Gherkin",
    extensions: ["feature"],
    load() {
      return import("./gherkin-AUR7DKBK.js").then((m5) => legacy(m5.gherkin));
    }
  }),
  LanguageDescription.of({
    name: "Go",
    extensions: ["go"],
    load() {
      return import("./go-OOSRO3WE.js").then((m5) => legacy(m5.go));
    }
  }),
  LanguageDescription.of({
    name: "Groovy",
    extensions: ["groovy", "gradle"],
    filename: /^Jenkinsfile$/,
    load() {
      return import("./groovy-76COSJ27.js").then((m5) => legacy(m5.groovy));
    }
  }),
  LanguageDescription.of({
    name: "Haskell",
    extensions: ["hs"],
    load() {
      return import("./haskell-CE3YR64J.js").then((m5) => legacy(m5.haskell));
    }
  }),
  LanguageDescription.of({
    name: "Haxe",
    extensions: ["hx"],
    load() {
      return import("./haxe-ZNRBNIFF.js").then((m5) => legacy(m5.haxe));
    }
  }),
  LanguageDescription.of({
    name: "HXML",
    extensions: ["hxml"],
    load() {
      return import("./haxe-ZNRBNIFF.js").then((m5) => legacy(m5.hxml));
    }
  }),
  LanguageDescription.of({
    name: "HTTP",
    load() {
      return import("./http-T2JJALEY.js").then((m5) => legacy(m5.http));
    }
  }),
  LanguageDescription.of({
    name: "IDL",
    extensions: ["pro"],
    load() {
      return import("./idl-SUVVHYKB.js").then((m5) => legacy(m5.idl));
    }
  }),
  LanguageDescription.of({
    name: "JSON-LD",
    alias: ["jsonld"],
    extensions: ["jsonld"],
    load() {
      return import("./javascript-GYGAWYGH.js").then((m5) => legacy(m5.jsonld));
    }
  }),
  LanguageDescription.of({
    name: "Jinja2",
    extensions: ["j2", "jinja", "jinja2"],
    load() {
      return import("./jinja2-JVFRTNPG.js").then((m5) => legacy(m5.jinja2));
    }
  }),
  LanguageDescription.of({
    name: "Julia",
    extensions: ["jl"],
    load() {
      return import("./julia-P5BNPV5V.js").then((m5) => legacy(m5.julia));
    }
  }),
  LanguageDescription.of({
    name: "Kotlin",
    extensions: ["kt"],
    load() {
      return import("./clike-TKJQLYRZ.js").then((m5) => legacy(m5.kotlin));
    }
  }),
  LanguageDescription.of({
    name: "LiveScript",
    alias: ["ls"],
    extensions: ["ls"],
    load() {
      return import("./livescript-7DGWX3LZ.js").then((m5) => legacy(m5.liveScript));
    }
  }),
  LanguageDescription.of({
    name: "Lua",
    extensions: ["lua"],
    load() {
      return import("./lua-QILP52QG.js").then((m5) => legacy(m5.lua));
    }
  }),
  LanguageDescription.of({
    name: "mIRC",
    extensions: ["mrc"],
    load() {
      return import("./mirc-TDNJOESV.js").then((m5) => legacy(m5.mirc));
    }
  }),
  LanguageDescription.of({
    name: "Mathematica",
    extensions: ["m", "nb", "wl", "wls"],
    load() {
      return import("./mathematica-BGNGEDGW.js").then((m5) => legacy(m5.mathematica));
    }
  }),
  LanguageDescription.of({
    name: "Modelica",
    extensions: ["mo"],
    load() {
      return import("./modelica-QI2MUTLI.js").then((m5) => legacy(m5.modelica));
    }
  }),
  LanguageDescription.of({
    name: "MUMPS",
    extensions: ["mps"],
    load() {
      return import("./mumps-VRX7GAJX.js").then((m5) => legacy(m5.mumps));
    }
  }),
  LanguageDescription.of({
    name: "Mbox",
    extensions: ["mbox"],
    load() {
      return import("./mbox-DX3GM73B.js").then((m5) => legacy(m5.mbox));
    }
  }),
  LanguageDescription.of({
    name: "Nginx",
    filename: /nginx.*\.conf$/i,
    load() {
      return import("./nginx-IO7WIT2V.js").then((m5) => legacy(m5.nginx));
    }
  }),
  LanguageDescription.of({
    name: "NSIS",
    extensions: ["nsh", "nsi"],
    load() {
      return import("./nsis-NXQQZUE6.js").then((m5) => legacy(m5.nsis));
    }
  }),
  LanguageDescription.of({
    name: "NTriples",
    extensions: ["nt", "nq"],
    load() {
      return import("./ntriples-J2542UET.js").then((m5) => legacy(m5.ntriples));
    }
  }),
  LanguageDescription.of({
    name: "Objective-C",
    alias: ["objective-c", "objc"],
    extensions: ["m"],
    load() {
      return import("./clike-TKJQLYRZ.js").then((m5) => legacy(m5.objectiveC));
    }
  }),
  LanguageDescription.of({
    name: "Objective-C++",
    alias: ["objective-c++", "objc++"],
    extensions: ["mm"],
    load() {
      return import("./clike-TKJQLYRZ.js").then((m5) => legacy(m5.objectiveCpp));
    }
  }),
  LanguageDescription.of({
    name: "OCaml",
    extensions: ["ml", "mli", "mll", "mly"],
    load() {
      return import("./mllike-R53JJBBD.js").then((m5) => legacy(m5.oCaml));
    }
  }),
  LanguageDescription.of({
    name: "Octave",
    extensions: ["m"],
    load() {
      return import("./octave-5ZDL2GCW.js").then((m5) => legacy(m5.octave));
    }
  }),
  LanguageDescription.of({
    name: "Oz",
    extensions: ["oz"],
    load() {
      return import("./oz-XG7TTNQJ.js").then((m5) => legacy(m5.oz));
    }
  }),
  LanguageDescription.of({
    name: "Pascal",
    extensions: ["p", "pas"],
    load() {
      return import("./pascal-MYFHTOP2.js").then((m5) => legacy(m5.pascal));
    }
  }),
  LanguageDescription.of({
    name: "Perl",
    extensions: ["pl", "pm"],
    load() {
      return import("./perl-VQXYPFHA.js").then((m5) => legacy(m5.perl));
    }
  }),
  LanguageDescription.of({
    name: "Pig",
    extensions: ["pig"],
    load() {
      return import("./pig-BCICH7HU.js").then((m5) => legacy(m5.pig));
    }
  }),
  LanguageDescription.of({
    name: "PowerShell",
    extensions: ["ps1", "psd1", "psm1"],
    load() {
      return import("./powershell-GGPEUW65.js").then((m5) => legacy(m5.powerShell));
    }
  }),
  LanguageDescription.of({
    name: "Properties files",
    alias: ["ini", "properties"],
    extensions: ["properties", "ini", "in"],
    load() {
      return import("./properties-HVJ2CIBG.js").then((m5) => legacy(m5.properties));
    }
  }),
  LanguageDescription.of({
    name: "ProtoBuf",
    extensions: ["proto"],
    load() {
      return import("./protobuf-DEN7NYGY.js").then((m5) => legacy(m5.protobuf));
    }
  }),
  LanguageDescription.of({
    name: "Puppet",
    extensions: ["pp"],
    load() {
      return import("./puppet-JVSC4BU5.js").then((m5) => legacy(m5.puppet));
    }
  }),
  LanguageDescription.of({
    name: "Q",
    extensions: ["q"],
    load() {
      return import("./q-KIYX2LHF.js").then((m5) => legacy(m5.q));
    }
  }),
  LanguageDescription.of({
    name: "R",
    alias: ["rscript"],
    extensions: ["r", "R"],
    load() {
      return import("./r-RPFUSCGR.js").then((m5) => legacy(m5.r));
    }
  }),
  LanguageDescription.of({
    name: "RPM Changes",
    load() {
      return import("./rpm-5SJYKM46.js").then((m5) => legacy(m5.rpmChanges));
    }
  }),
  LanguageDescription.of({
    name: "RPM Spec",
    extensions: ["spec"],
    load() {
      return import("./rpm-5SJYKM46.js").then((m5) => legacy(m5.rpmSpec));
    }
  }),
  LanguageDescription.of({
    name: "Ruby",
    alias: ["jruby", "macruby", "rake", "rb", "rbx"],
    extensions: ["rb"],
    filename: /^(Gemfile|Rakefile)$/,
    load() {
      return import("./ruby-FI2YE7WM.js").then((m5) => legacy(m5.ruby));
    }
  }),
  LanguageDescription.of({
    name: "SAS",
    extensions: ["sas"],
    load() {
      return import("./sas-GM762KCC.js").then((m5) => legacy(m5.sas));
    }
  }),
  LanguageDescription.of({
    name: "Scala",
    extensions: ["scala"],
    load() {
      return import("./clike-TKJQLYRZ.js").then((m5) => legacy(m5.scala));
    }
  }),
  LanguageDescription.of({
    name: "Scheme",
    extensions: ["scm", "ss"],
    load() {
      return import("./scheme-T5YDUS7I.js").then((m5) => legacy(m5.scheme));
    }
  }),
  LanguageDescription.of({
    name: "Shell",
    alias: ["bash", "sh", "zsh"],
    extensions: ["sh", "ksh", "bash"],
    filename: /^PKGBUILD$/,
    load() {
      return import("./shell-VL3A4D7C.js").then((m5) => legacy(m5.shell));
    }
  }),
  LanguageDescription.of({
    name: "Sieve",
    extensions: ["siv", "sieve"],
    load() {
      return import("./sieve-OCJYJE6R.js").then((m5) => legacy(m5.sieve));
    }
  }),
  LanguageDescription.of({
    name: "Smalltalk",
    extensions: ["st"],
    load() {
      return import("./smalltalk-5ZILILWO.js").then((m5) => legacy(m5.smalltalk));
    }
  }),
  LanguageDescription.of({
    name: "Solr",
    load() {
      return import("./solr-QW266ED2.js").then((m5) => legacy(m5.solr));
    }
  }),
  LanguageDescription.of({
    name: "SML",
    extensions: ["sml", "sig", "fun", "smackspec"],
    load() {
      return import("./mllike-R53JJBBD.js").then((m5) => legacy(m5.sml));
    }
  }),
  LanguageDescription.of({
    name: "SPARQL",
    alias: ["sparul"],
    extensions: ["rq", "sparql"],
    load() {
      return import("./sparql-RFTG5VN2.js").then((m5) => legacy(m5.sparql));
    }
  }),
  LanguageDescription.of({
    name: "Spreadsheet",
    alias: ["excel", "formula"],
    load() {
      return import("./spreadsheet-2M5TH5H6.js").then((m5) => legacy(m5.spreadsheet));
    }
  }),
  LanguageDescription.of({
    name: "Squirrel",
    extensions: ["nut"],
    load() {
      return import("./clike-TKJQLYRZ.js").then((m5) => legacy(m5.squirrel));
    }
  }),
  LanguageDescription.of({
    name: "Stylus",
    extensions: ["styl"],
    load() {
      return import("./stylus-XXJOKFMB.js").then((m5) => legacy(m5.stylus));
    }
  }),
  LanguageDescription.of({
    name: "Swift",
    extensions: ["swift"],
    load() {
      return import("./swift-YWRGOHT3.js").then((m5) => legacy(m5.swift));
    }
  }),
  LanguageDescription.of({
    name: "sTeX",
    load() {
      return import("./stex-LTKBAGMI.js").then((m5) => legacy(m5.stex));
    }
  }),
  LanguageDescription.of({
    name: "LaTeX",
    alias: ["tex"],
    extensions: ["text", "ltx", "tex"],
    load() {
      return import("./stex-LTKBAGMI.js").then((m5) => legacy(m5.stex));
    }
  }),
  LanguageDescription.of({
    name: "SystemVerilog",
    extensions: ["v", "sv", "svh"],
    load() {
      return import("./verilog-UBQYOYOA.js").then((m5) => legacy(m5.verilog));
    }
  }),
  LanguageDescription.of({
    name: "Tcl",
    extensions: ["tcl"],
    load() {
      return import("./tcl-SMJMR5PM.js").then((m5) => legacy(m5.tcl));
    }
  }),
  LanguageDescription.of({
    name: "Textile",
    extensions: ["textile"],
    load() {
      return import("./textile-2M74II6P.js").then((m5) => legacy(m5.textile));
    }
  }),
  LanguageDescription.of({
    name: "TiddlyWiki",
    load() {
      return import("./tiddlywiki-AQEEINGV.js").then((m5) => legacy(m5.tiddlyWiki));
    }
  }),
  LanguageDescription.of({
    name: "Tiki wiki",
    load() {
      return import("./tiki-REZ3BLYS.js").then((m5) => legacy(m5.tiki));
    }
  }),
  LanguageDescription.of({
    name: "TOML",
    extensions: ["toml"],
    load() {
      return import("./toml-KFVLOZEB.js").then((m5) => legacy(m5.toml));
    }
  }),
  LanguageDescription.of({
    name: "Troff",
    extensions: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
    load() {
      return import("./troff-7SUXDHCA.js").then((m5) => legacy(m5.troff));
    }
  }),
  LanguageDescription.of({
    name: "TTCN",
    extensions: ["ttcn", "ttcn3", "ttcnpp"],
    load() {
      return import("./ttcn-76DQYMYZ.js").then((m5) => legacy(m5.ttcn));
    }
  }),
  LanguageDescription.of({
    name: "TTCN_CFG",
    extensions: ["cfg"],
    load() {
      return import("./ttcn-cfg-5FAYLEE7.js").then((m5) => legacy(m5.ttcnCfg));
    }
  }),
  LanguageDescription.of({
    name: "Turtle",
    extensions: ["ttl"],
    load() {
      return import("./turtle-UC2ZT6Q5.js").then((m5) => legacy(m5.turtle));
    }
  }),
  LanguageDescription.of({
    name: "Web IDL",
    extensions: ["webidl"],
    load() {
      return import("./webidl-XOOP74MR.js").then((m5) => legacy(m5.webIDL));
    }
  }),
  LanguageDescription.of({
    name: "VB.NET",
    extensions: ["vb"],
    load() {
      return import("./vb-F6YX2M5G.js").then((m5) => legacy(m5.vb));
    }
  }),
  LanguageDescription.of({
    name: "VBScript",
    extensions: ["vbs"],
    load() {
      return import("./vbscript-N733PLHN.js").then((m5) => legacy(m5.vbScript));
    }
  }),
  LanguageDescription.of({
    name: "Velocity",
    extensions: ["vtl"],
    load() {
      return import("./velocity-5PN2544L.js").then((m5) => legacy(m5.velocity));
    }
  }),
  LanguageDescription.of({
    name: "Verilog",
    extensions: ["v"],
    load() {
      return import("./verilog-UBQYOYOA.js").then((m5) => legacy(m5.verilog));
    }
  }),
  LanguageDescription.of({
    name: "VHDL",
    extensions: ["vhd", "vhdl"],
    load() {
      return import("./vhdl-G27XJ66N.js").then((m5) => legacy(m5.vhdl));
    }
  }),
  LanguageDescription.of({
    name: "XQuery",
    extensions: ["xy", "xquery"],
    load() {
      return import("./xquery-VZRO6YLZ.js").then((m5) => legacy(m5.xQuery));
    }
  }),
  LanguageDescription.of({
    name: "Yacas",
    extensions: ["ys"],
    load() {
      return import("./yacas-YQOKOVRC.js").then((m5) => legacy(m5.yacas));
    }
  }),
  LanguageDescription.of({
    name: "YAML",
    alias: ["yml"],
    extensions: ["yaml", "yml"],
    load() {
      return import("./yaml-J7PQXKTC.js").then((m5) => legacy(m5.yaml));
    }
  }),
  LanguageDescription.of({
    name: "Z80",
    extensions: ["z80"],
    load() {
      return import("./z80-YE6CXGHE.js").then((m5) => legacy(m5.z80));
    }
  }),
  LanguageDescription.of({
    name: "MscGen",
    extensions: ["mscgen", "mscin", "msc"],
    load() {
      return import("./mscgen-HBRJ5PH6.js").then((m5) => legacy(m5.mscgen));
    }
  }),
  LanguageDescription.of({
    name: "Xù",
    extensions: ["xu"],
    load() {
      return import("./mscgen-HBRJ5PH6.js").then((m5) => legacy(m5.xu));
    }
  }),
  LanguageDescription.of({
    name: "MsGenny",
    extensions: ["msgenny"],
    load() {
      return import("./mscgen-HBRJ5PH6.js").then((m5) => legacy(m5.msgenny));
    }
  }),
  LanguageDescription.of({
    name: "Vue",
    extensions: ["vue"],
    load() {
      return import("./dist-XRXDKKR3.js").then((m5) => m5.vue());
    }
  }),
  LanguageDescription.of({
    name: "Angular Template",
    load() {
      return import("./dist-PB2JERMF.js").then((m5) => m5.angular());
    }
  })
];

// node_modules/medium-zoom/dist/medium-zoom.esm.js
var _extends = Object.assign || function(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = arguments[i4];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var isSupported = function isSupported2(node) {
  return node.tagName === "IMG";
};
var isNodeList = function isNodeList2(selector) {
  return NodeList.prototype.isPrototypeOf(selector);
};
var isNode = function isNode2(selector) {
  return selector && selector.nodeType === 1;
};
var isSvg = function isSvg2(image) {
  var source = image.currentSrc || image.src;
  return source.substr(-4).toLowerCase() === ".svg";
};
var getImagesFromSelector = function getImagesFromSelector2(selector) {
  try {
    if (Array.isArray(selector)) {
      return selector.filter(isSupported);
    }
    if (isNodeList(selector)) {
      return [].slice.call(selector).filter(isSupported);
    }
    if (isNode(selector)) {
      return [selector].filter(isSupported);
    }
    if (typeof selector === "string") {
      return [].slice.call(document.querySelectorAll(selector)).filter(isSupported);
    }
    return [];
  } catch (err) {
    throw new TypeError("The provided selector is invalid.\nExpects a CSS selector, a Node element, a NodeList or an array.\nSee: https://github.com/francoischalifour/medium-zoom");
  }
};
var createOverlay = function createOverlay2(background) {
  var overlay = document.createElement("div");
  overlay.classList.add("medium-zoom-overlay");
  overlay.style.background = background;
  return overlay;
};
var cloneTarget = function cloneTarget2(template) {
  var _template$getBounding = template.getBoundingClientRect(), top = _template$getBounding.top, left = _template$getBounding.left, width = _template$getBounding.width, height = _template$getBounding.height;
  var clone = template.cloneNode();
  var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
  clone.removeAttribute("id");
  clone.style.position = "absolute";
  clone.style.top = top + scrollTop + "px";
  clone.style.left = left + scrollLeft + "px";
  clone.style.width = width + "px";
  clone.style.height = height + "px";
  clone.style.transform = "";
  return clone;
};
var createCustomEvent = function createCustomEvent2(type, params) {
  var eventParams = _extends({
    bubbles: false,
    cancelable: false,
    detail: void 0
  }, params);
  if (typeof window.CustomEvent === "function") {
    return new CustomEvent(type, eventParams);
  }
  var customEvent = document.createEvent("CustomEvent");
  customEvent.initCustomEvent(type, eventParams.bubbles, eventParams.cancelable, eventParams.detail);
  return customEvent;
};
var mediumZoom = function mediumZoom2(selector) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var Promise2 = window.Promise || function Promise3(fn) {
    function noop() {
    }
    fn(noop, noop);
  };
  var _handleClick = function _handleClick2(event) {
    var target = event.target;
    if (target === overlay) {
      close();
      return;
    }
    if (images.indexOf(target) === -1) {
      return;
    }
    toggle({ target });
  };
  var _handleScroll = function _handleScroll2() {
    if (isAnimating || !active.original) {
      return;
    }
    var currentScroll = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
    if (Math.abs(scrollTop - currentScroll) > zoomOptions.scrollOffset) {
      setTimeout(close, 150);
    }
  };
  var _handleKeyUp = function _handleKeyUp2(event) {
    var key = event.key || event.keyCode;
    if (key === "Escape" || key === "Esc" || key === 27) {
      close();
    }
  };
  var update = function update2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var newOptions = options2;
    if (options2.background) {
      overlay.style.background = options2.background;
    }
    if (options2.container && options2.container instanceof Object) {
      newOptions.container = _extends({}, zoomOptions.container, options2.container);
    }
    if (options2.template) {
      var template = isNode(options2.template) ? options2.template : document.querySelector(options2.template);
      newOptions.template = template;
    }
    zoomOptions = _extends({}, zoomOptions, newOptions);
    images.forEach(function(image) {
      image.dispatchEvent(createCustomEvent("medium-zoom:update", {
        detail: { zoom }
      }));
    });
    return zoom;
  };
  var clone = function clone2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return mediumZoom2(_extends({}, zoomOptions, options2));
  };
  var attach = function attach2() {
    for (var _len = arguments.length, selectors = Array(_len), _key = 0; _key < _len; _key++) {
      selectors[_key] = arguments[_key];
    }
    var newImages = selectors.reduce(function(imagesAccumulator, currentSelector) {
      return [].concat(imagesAccumulator, getImagesFromSelector(currentSelector));
    }, []);
    newImages.filter(function(newImage) {
      return images.indexOf(newImage) === -1;
    }).forEach(function(newImage) {
      images.push(newImage);
      newImage.classList.add("medium-zoom-image");
    });
    eventListeners.forEach(function(_ref) {
      var type = _ref.type, listener = _ref.listener, options2 = _ref.options;
      newImages.forEach(function(image) {
        image.addEventListener(type, listener, options2);
      });
    });
    return zoom;
  };
  var detach = function detach2() {
    for (var _len2 = arguments.length, selectors = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      selectors[_key2] = arguments[_key2];
    }
    if (active.zoomed) {
      close();
    }
    var imagesToDetach = selectors.length > 0 ? selectors.reduce(function(imagesAccumulator, currentSelector) {
      return [].concat(imagesAccumulator, getImagesFromSelector(currentSelector));
    }, []) : images;
    imagesToDetach.forEach(function(image) {
      image.classList.remove("medium-zoom-image");
      image.dispatchEvent(createCustomEvent("medium-zoom:detach", {
        detail: { zoom }
      }));
    });
    images = images.filter(function(image) {
      return imagesToDetach.indexOf(image) === -1;
    });
    return zoom;
  };
  var on = function on2(type, listener) {
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    images.forEach(function(image) {
      image.addEventListener("medium-zoom:" + type, listener, options2);
    });
    eventListeners.push({ type: "medium-zoom:" + type, listener, options: options2 });
    return zoom;
  };
  var off = function off2(type, listener) {
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    images.forEach(function(image) {
      image.removeEventListener("medium-zoom:" + type, listener, options2);
    });
    eventListeners = eventListeners.filter(function(eventListener) {
      return !(eventListener.type === "medium-zoom:" + type && eventListener.listener.toString() === listener.toString());
    });
    return zoom;
  };
  var open = function open2() {
    var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, target = _ref2.target;
    var _animate = function _animate2() {
      var container = {
        width: document.documentElement.clientWidth,
        height: document.documentElement.clientHeight,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
      var viewportWidth = void 0;
      var viewportHeight = void 0;
      if (zoomOptions.container) {
        if (zoomOptions.container instanceof Object) {
          container = _extends({}, container, zoomOptions.container);
          viewportWidth = container.width - container.left - container.right - zoomOptions.margin * 2;
          viewportHeight = container.height - container.top - container.bottom - zoomOptions.margin * 2;
        } else {
          var zoomContainer = isNode(zoomOptions.container) ? zoomOptions.container : document.querySelector(zoomOptions.container);
          var _zoomContainer$getBou = zoomContainer.getBoundingClientRect(), _width = _zoomContainer$getBou.width, _height = _zoomContainer$getBou.height, _left = _zoomContainer$getBou.left, _top = _zoomContainer$getBou.top;
          container = _extends({}, container, {
            width: _width,
            height: _height,
            left: _left,
            top: _top
          });
        }
      }
      viewportWidth = viewportWidth || container.width - zoomOptions.margin * 2;
      viewportHeight = viewportHeight || container.height - zoomOptions.margin * 2;
      var zoomTarget = active.zoomedHd || active.original;
      var naturalWidth = isSvg(zoomTarget) ? viewportWidth : zoomTarget.naturalWidth || viewportWidth;
      var naturalHeight = isSvg(zoomTarget) ? viewportHeight : zoomTarget.naturalHeight || viewportHeight;
      var _zoomTarget$getBoundi = zoomTarget.getBoundingClientRect(), top = _zoomTarget$getBoundi.top, left = _zoomTarget$getBoundi.left, width = _zoomTarget$getBoundi.width, height = _zoomTarget$getBoundi.height;
      var scaleX = Math.min(Math.max(width, naturalWidth), viewportWidth) / width;
      var scaleY = Math.min(Math.max(height, naturalHeight), viewportHeight) / height;
      var scale = Math.min(scaleX, scaleY);
      var translateX = (-left + (viewportWidth - width) / 2 + zoomOptions.margin + container.left) / scale;
      var translateY = (-top + (viewportHeight - height) / 2 + zoomOptions.margin + container.top) / scale;
      var transform = "scale(" + scale + ") translate3d(" + translateX + "px, " + translateY + "px, 0)";
      active.zoomed.style.transform = transform;
      if (active.zoomedHd) {
        active.zoomedHd.style.transform = transform;
      }
    };
    return new Promise2(function(resolve) {
      if (target && images.indexOf(target) === -1) {
        resolve(zoom);
        return;
      }
      var _handleOpenEnd = function _handleOpenEnd2() {
        isAnimating = false;
        active.zoomed.removeEventListener("transitionend", _handleOpenEnd2);
        active.original.dispatchEvent(createCustomEvent("medium-zoom:opened", {
          detail: { zoom }
        }));
        resolve(zoom);
      };
      if (active.zoomed) {
        resolve(zoom);
        return;
      }
      if (target) {
        active.original = target;
      } else if (images.length > 0) {
        var _images = images;
        active.original = _images[0];
      } else {
        resolve(zoom);
        return;
      }
      active.original.dispatchEvent(createCustomEvent("medium-zoom:open", {
        detail: { zoom }
      }));
      scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
      isAnimating = true;
      active.zoomed = cloneTarget(active.original);
      document.body.appendChild(overlay);
      if (zoomOptions.template) {
        var template = isNode(zoomOptions.template) ? zoomOptions.template : document.querySelector(zoomOptions.template);
        active.template = document.createElement("div");
        active.template.appendChild(template.content.cloneNode(true));
        document.body.appendChild(active.template);
      }
      if (active.original.parentElement && active.original.parentElement.tagName === "PICTURE" && active.original.currentSrc) {
        active.zoomed.src = active.original.currentSrc;
      }
      document.body.appendChild(active.zoomed);
      window.requestAnimationFrame(function() {
        document.body.classList.add("medium-zoom--opened");
      });
      active.original.classList.add("medium-zoom-image--hidden");
      active.zoomed.classList.add("medium-zoom-image--opened");
      active.zoomed.addEventListener("click", close);
      active.zoomed.addEventListener("transitionend", _handleOpenEnd);
      if (active.original.getAttribute("data-zoom-src")) {
        active.zoomedHd = active.zoomed.cloneNode();
        active.zoomedHd.removeAttribute("srcset");
        active.zoomedHd.removeAttribute("sizes");
        active.zoomedHd.removeAttribute("loading");
        active.zoomedHd.src = active.zoomed.getAttribute("data-zoom-src");
        active.zoomedHd.onerror = function() {
          clearInterval(getZoomTargetSize);
          console.warn("Unable to reach the zoom image target " + active.zoomedHd.src);
          active.zoomedHd = null;
          _animate();
        };
        var getZoomTargetSize = setInterval(function() {
          if (active.zoomedHd.complete) {
            clearInterval(getZoomTargetSize);
            active.zoomedHd.classList.add("medium-zoom-image--opened");
            active.zoomedHd.addEventListener("click", close);
            document.body.appendChild(active.zoomedHd);
            _animate();
          }
        }, 10);
      } else if (active.original.hasAttribute("srcset")) {
        active.zoomedHd = active.zoomed.cloneNode();
        active.zoomedHd.removeAttribute("sizes");
        active.zoomedHd.removeAttribute("loading");
        var loadEventListener = active.zoomedHd.addEventListener("load", function() {
          active.zoomedHd.removeEventListener("load", loadEventListener);
          active.zoomedHd.classList.add("medium-zoom-image--opened");
          active.zoomedHd.addEventListener("click", close);
          document.body.appendChild(active.zoomedHd);
          _animate();
        });
      } else {
        _animate();
      }
    });
  };
  var close = function close2() {
    return new Promise2(function(resolve) {
      if (isAnimating || !active.original) {
        resolve(zoom);
        return;
      }
      var _handleCloseEnd = function _handleCloseEnd2() {
        active.original.classList.remove("medium-zoom-image--hidden");
        document.body.removeChild(active.zoomed);
        if (active.zoomedHd) {
          document.body.removeChild(active.zoomedHd);
        }
        document.body.removeChild(overlay);
        active.zoomed.classList.remove("medium-zoom-image--opened");
        if (active.template) {
          document.body.removeChild(active.template);
        }
        isAnimating = false;
        active.zoomed.removeEventListener("transitionend", _handleCloseEnd2);
        active.original.dispatchEvent(createCustomEvent("medium-zoom:closed", {
          detail: { zoom }
        }));
        active.original = null;
        active.zoomed = null;
        active.zoomedHd = null;
        active.template = null;
        resolve(zoom);
      };
      isAnimating = true;
      document.body.classList.remove("medium-zoom--opened");
      active.zoomed.style.transform = "";
      if (active.zoomedHd) {
        active.zoomedHd.style.transform = "";
      }
      if (active.template) {
        active.template.style.transition = "opacity 150ms";
        active.template.style.opacity = 0;
      }
      active.original.dispatchEvent(createCustomEvent("medium-zoom:close", {
        detail: { zoom }
      }));
      active.zoomed.addEventListener("transitionend", _handleCloseEnd);
    });
  };
  var toggle = function toggle2() {
    var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, target = _ref3.target;
    if (active.original) {
      return close();
    }
    return open({ target });
  };
  var getOptions = function getOptions2() {
    return zoomOptions;
  };
  var getImages = function getImages2() {
    return images;
  };
  var getZoomedImage = function getZoomedImage2() {
    return active.original;
  };
  var images = [];
  var eventListeners = [];
  var isAnimating = false;
  var scrollTop = 0;
  var zoomOptions = options;
  var active = {
    original: null,
    zoomed: null,
    zoomedHd: null,
    template: null
    // If the selector is omitted, it's replaced by the options
  };
  if (Object.prototype.toString.call(selector) === "[object Object]") {
    zoomOptions = selector;
  } else if (selector || typeof selector === "string") {
    attach(selector);
  }
  zoomOptions = _extends({
    margin: 0,
    background: "#fff",
    scrollOffset: 40,
    container: null,
    template: null
  }, zoomOptions);
  var overlay = createOverlay(zoomOptions.background);
  document.addEventListener("click", _handleClick);
  document.addEventListener("keyup", _handleKeyUp);
  document.addEventListener("scroll", _handleScroll);
  window.addEventListener("resize", close);
  var zoom = {
    open,
    close,
    toggle,
    update,
    clone,
    attach,
    detach,
    on,
    off,
    getOptions,
    getImages,
    getZoomedImage
  };
  return zoom;
};
function styleInject(css2, ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var insertAt = ref2.insertAt;
  if (!css2 || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css2;
  } else {
    style.appendChild(document.createTextNode(css2));
  }
}
var css = ".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}";
styleInject(css);
var medium_zoom_esm_default = mediumZoom;

// node_modules/md-editor-v3/lib/es/chunks/index.mjs
var import_copy_to_clipboard = __toESM(require_copy_to_clipboard(), 1);
var import_markdown_it = __toESM(require_markdown_it(), 1);

// node_modules/markdown-it-image-figures/dist/markdown-it-images-figures.mjs
var t = /* @__PURE__ */ new Set([true, false, "alt", "title"]);
function e2(t3, e4) {
  return (Array.isArray(t3) ? t3 : []).filter(([t4]) => t4 !== e4);
}
function n2(t3, n3) {
  t3 && t3.attrs && (t3.attrs = e2(t3.attrs, n3));
}
function i2(e4, i4) {
  if (!t.has(e4))
    throw new TypeError(`figcaption must be one of: ${[...t]}.`);
  if ("alt" === e4)
    return i4.content;
  const r4 = i4.attrs.find(([t3]) => "title" === t3);
  return Array.isArray(r4) && r4[1] ? (n2(i4, "title"), r4[1]) : void 0;
}
function r3(t3, r4) {
  r4 = r4 || {}, t3.core.ruler.before("linkify", "image_figures", function(s3) {
    let a2 = 1;
    for (let o2 = 1, c2 = s3.tokens.length; o2 < c2 - 1; ++o2) {
      const l2 = s3.tokens[o2];
      if ("inline" !== l2.type)
        continue;
      if (!l2.children || 1 !== l2.children.length && 3 !== l2.children.length)
        continue;
      if (1 === l2.children.length && "image" !== l2.children[0].type)
        continue;
      if (3 === l2.children.length) {
        const [t4, e4, n3] = l2.children;
        if ("link_open" !== t4.type || "image" !== e4.type || "link_close" !== n3.type)
          continue;
      }
      if (0 !== o2 && "paragraph_open" !== s3.tokens[o2 - 1].type)
        continue;
      if (o2 !== c2 - 1 && "paragraph_close" !== s3.tokens[o2 + 1].type)
        continue;
      const f3 = s3.tokens[o2 - 1];
      let h6;
      if (f3.type = "figure_open", f3.tag = "figure", s3.tokens[o2 + 1].type = "figure_close", s3.tokens[o2 + 1].tag = "figure", r4.dataType && s3.tokens[o2 - 1].attrPush(["data-type", "image"]), r4.link && 1 === l2.children.length) {
        [h6] = l2.children;
        const t4 = new s3.Token("link_open", "a", 1);
        t4.attrPush(["href", h6.attrGet("src")]), l2.children.unshift(t4), l2.children.push(new s3.Token("link_close", "a", -1));
      }
      if (h6 = 1 === l2.children.length ? l2.children[0] : l2.children[1], r4.figcaption) {
        const n3 = i2(r4.figcaption, h6);
        if (n3) {
          const [i4] = t3.parseInline(n3, s3.env);
          l2.children.push(new s3.Token("figcaption_open", "figcaption", 1)), l2.children.push(...i4.children), l2.children.push(new s3.Token("figcaption_close", "figcaption", -1)), h6.attrs && (h6.attrs = e2(h6.attrs, "title"));
        }
      }
      if (r4.copyAttrs && h6.attrs) {
        const t4 = true === r4.copyAttrs ? "" : r4.copyAttrs;
        f3.attrs = h6.attrs.filter(([e4]) => e4.match(t4)).map((t5) => Array.from(t5));
      }
      if (r4.tabindex && (s3.tokens[o2 - 1].attrPush(["tabindex", a2]), a2++), r4.lazy && (h6.attrs.some(([t4]) => "loading" === t4) || h6.attrs.push(["loading", "lazy"])), r4.async && (h6.attrs.some(([t4]) => "decoding" === t4) || h6.attrs.push(["decoding", "async"])), r4.classes && "string" == typeof r4.classes) {
        let t4 = false;
        for (let e4 = 0, n3 = h6.attrs.length; e4 < n3 && !t4; e4++) {
          const n4 = h6.attrs[e4];
          "class" === n4[0] && (n4[1] = `${n4[1]} ${r4.classes}`, t4 = true);
        }
        t4 || h6.attrs.push(["class", r4.classes]);
      }
      if (r4.removeSrc) {
        const t4 = h6.attrs.find(([t5]) => "src" === t5);
        h6.attrs.push(["data-src", t4[1]]), n2(h6, "src");
      }
    }
  });
}

// node_modules/md-editor-v3/lib/es/chunks/index.mjs
var import_markdown_it_task_lists = __toESM(require_markdown_it_task_lists(), 1);

// node_modules/md-editor-v3/node_modules/lru-cache/dist/mjs/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var emitWarning = (msg, type, code, fn) => {
  typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n3) => n3 && n3 === Math.floor(n3) && n3 > 0 && isFinite(n3);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
};
var _constructing;
var _Stack = class _Stack {
  constructor(max, HeapCls) {
    __publicField(this, "heap");
    __publicField(this, "length");
    if (!__privateGet(_Stack, _constructing)) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    __privateSet(_Stack, _constructing, true);
    const s3 = new _Stack(max, HeapCls);
    __privateSet(_Stack, _constructing, false);
    return s3;
  }
  push(n3) {
    this.heap[this.length++] = n3;
  }
  pop() {
    return this.heap[--this.length];
  }
};
_constructing = new WeakMap();
// private constructor
__privateAdd(_Stack, _constructing, false);
var Stack = _Stack;
var _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _initializeTTLTracking, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, _initializeSizeTracking, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, _indexes, indexes_fn, _rindexes, rindexes_fn, _isValidIndex, isValidIndex_fn, _evict, evict_fn, _backgroundFetch, backgroundFetch_fn, _isBackgroundFetch, isBackgroundFetch_fn, _connect, connect_fn, _moveToTail, moveToTail_fn;
var _LRUCache = class _LRUCache {
  constructor(options) {
    __privateAdd(this, _initializeTTLTracking);
    __privateAdd(this, _initializeSizeTracking);
    __privateAdd(this, _indexes);
    __privateAdd(this, _rindexes);
    __privateAdd(this, _isValidIndex);
    __privateAdd(this, _evict);
    __privateAdd(this, _backgroundFetch);
    __privateAdd(this, _isBackgroundFetch);
    __privateAdd(this, _connect);
    __privateAdd(this, _moveToTail);
    // properties coming in from the options of these, only max and maxSize
    // really *need* to be protected. The rest can be modified, as they just
    // set defaults for various methods.
    __privateAdd(this, _max, void 0);
    __privateAdd(this, _maxSize, void 0);
    __privateAdd(this, _dispose, void 0);
    __privateAdd(this, _disposeAfter, void 0);
    __privateAdd(this, _fetchMethod, void 0);
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    __publicField(this, "ttl");
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    __publicField(this, "ttlResolution");
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    __publicField(this, "ttlAutopurge");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    __publicField(this, "updateAgeOnGet");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    __publicField(this, "updateAgeOnHas");
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    __publicField(this, "allowStale");
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    __publicField(this, "noDisposeOnSet");
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    __publicField(this, "noUpdateTTL");
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    __publicField(this, "maxEntrySize");
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    __publicField(this, "sizeCalculation");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    __publicField(this, "noDeleteOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    __publicField(this, "noDeleteOnStaleGet");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    __publicField(this, "allowStaleOnFetchAbort");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    __publicField(this, "allowStaleOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    __publicField(this, "ignoreFetchAbort");
    // computed properties
    __privateAdd(this, _size, void 0);
    __privateAdd(this, _calculatedSize, void 0);
    __privateAdd(this, _keyMap, void 0);
    __privateAdd(this, _keyList, void 0);
    __privateAdd(this, _valList, void 0);
    __privateAdd(this, _next, void 0);
    __privateAdd(this, _prev, void 0);
    __privateAdd(this, _head, void 0);
    __privateAdd(this, _tail, void 0);
    __privateAdd(this, _free, void 0);
    __privateAdd(this, _disposed, void 0);
    __privateAdd(this, _sizes, void 0);
    __privateAdd(this, _starts, void 0);
    __privateAdd(this, _ttls, void 0);
    __privateAdd(this, _hasDispose, void 0);
    __privateAdd(this, _hasFetchMethod, void 0);
    __privateAdd(this, _hasDisposeAfter, void 0);
    // conditionally set private methods related to TTL
    __privateAdd(this, _updateItemAge, () => {
    });
    __privateAdd(this, _statusTTL, () => {
    });
    __privateAdd(this, _setItemTTL, () => {
    });
    /* c8 ignore stop */
    __privateAdd(this, _isStale, () => false);
    __privateAdd(this, _removeItemSize, (_i) => {
    });
    __privateAdd(this, _addItemSize, (_i, _s, _st) => {
    });
    __privateAdd(this, _requireSize, (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    });
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    __privateSet(this, _max, max);
    __privateSet(this, _maxSize, maxSize);
    this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize);
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!__privateGet(this, _maxSize) && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    __privateSet(this, _fetchMethod, fetchMethod);
    __privateSet(this, _hasFetchMethod, !!fetchMethod);
    __privateSet(this, _keyMap, /* @__PURE__ */ new Map());
    __privateSet(this, _keyList, new Array(max).fill(void 0));
    __privateSet(this, _valList, new Array(max).fill(void 0));
    __privateSet(this, _next, new UintArray(max));
    __privateSet(this, _prev, new UintArray(max));
    __privateSet(this, _head, 0);
    __privateSet(this, _tail, 0);
    __privateSet(this, _free, Stack.create(max));
    __privateSet(this, _size, 0);
    __privateSet(this, _calculatedSize, 0);
    if (typeof dispose === "function") {
      __privateSet(this, _dispose, dispose);
    }
    if (typeof disposeAfter === "function") {
      __privateSet(this, _disposeAfter, disposeAfter);
      __privateSet(this, _disposed, []);
    } else {
      __privateSet(this, _disposeAfter, void 0);
      __privateSet(this, _disposed, void 0);
    }
    __privateSet(this, _hasDispose, !!__privateGet(this, _dispose));
    __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter));
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (__privateGet(this, _maxSize) !== 0) {
        if (!isPosInt(__privateGet(this, _maxSize))) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      __privateMethod(this, _initializeSizeTracking, initializeSizeTracking_fn).call(this);
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      __privateMethod(this, _initializeTTLTracking, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize) === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize)) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
      }
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c2) {
    return {
      // properties
      starts: __privateGet(c2, _starts),
      ttls: __privateGet(c2, _ttls),
      sizes: __privateGet(c2, _sizes),
      keyMap: __privateGet(c2, _keyMap),
      keyList: __privateGet(c2, _keyList),
      valList: __privateGet(c2, _valList),
      next: __privateGet(c2, _next),
      prev: __privateGet(c2, _prev),
      get head() {
        return __privateGet(c2, _head);
      },
      get tail() {
        return __privateGet(c2, _tail);
      },
      free: __privateGet(c2, _free),
      // methods
      isBackgroundFetch: (p3) => {
        var _a;
        return __privateMethod(_a = c2, _isBackgroundFetch, isBackgroundFetch_fn).call(_a, p3);
      },
      backgroundFetch: (k3, index, options, context) => {
        var _a;
        return __privateMethod(_a = c2, _backgroundFetch, backgroundFetch_fn).call(_a, k3, index, options, context);
      },
      moveToTail: (index) => {
        var _a;
        return __privateMethod(_a = c2, _moveToTail, moveToTail_fn).call(_a, index);
      },
      indexes: (options) => {
        var _a;
        return __privateMethod(_a = c2, _indexes, indexes_fn).call(_a, options);
      },
      rindexes: (options) => {
        var _a;
        return __privateMethod(_a = c2, _rindexes, rindexes_fn).call(_a, options);
      },
      isStale: (index) => {
        var _a;
        return __privateGet(_a = c2, _isStale).call(_a, index);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return __privateGet(this, _max);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return __privateGet(this, _maxSize);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return __privateGet(this, _calculatedSize);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return __privateGet(this, _size);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return __privateGet(this, _fetchMethod);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return __privateGet(this, _dispose);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return __privateGet(this, _disposeAfter);
  }
  /**
   * Return the remaining TTL time for a given entry key
   */
  getRemainingTTL(key) {
    return __privateGet(this, _keyMap).has(key) ? Infinity : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i4] !== void 0 && __privateGet(this, _keyList)[i4] !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield [__privateGet(this, _keyList)[i4], __privateGet(this, _valList)[i4]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i4 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i4] !== void 0 && __privateGet(this, _keyList)[i4] !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield [__privateGet(this, _keyList)[i4], __privateGet(this, _valList)[i4]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const k3 = __privateGet(this, _keyList)[i4];
      if (k3 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield k3;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i4 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      const k3 = __privateGet(this, _keyList)[i4];
      if (k3 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield k3;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const v2 = __privateGet(this, _valList)[i4];
      if (v2 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield __privateGet(this, _valList)[i4];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i4 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      const v2 = __privateGet(this, _valList)[i4];
      if (v2 !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i4])) {
        yield __privateGet(this, _valList)[i4];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  find(fn, getOptions = {}) {
    for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const v2 = __privateGet(this, _valList)[i4];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      if (fn(value, __privateGet(this, _keyList)[i4], this)) {
        return this.get(__privateGet(this, _keyList)[i4], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   * Does not iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this)) {
      const v2 = __privateGet(this, _valList)[i4];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      fn.call(thisp, value, __privateGet(this, _keyList)[i4], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i4 of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
      const v2 = __privateGet(this, _valList)[i4];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0)
        continue;
      fn.call(thisp, value, __privateGet(this, _keyList)[i4], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i4 of __privateMethod(this, _rindexes, rindexes_fn).call(this, { allowStale: true })) {
      if (__privateGet(this, _isStale).call(this, i4)) {
        this.delete(__privateGet(this, _keyList)[i4]);
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to cache.load()
   */
  dump() {
    const arr = [];
    for (const i4 of __privateMethod(this, _indexes, indexes_fn).call(this, { allowStale: true })) {
      const key = __privateGet(this, _keyList)[i4];
      const v2 = __privateGet(this, _valList)[i4];
      const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2) ? v2.__staleWhileFetching : v2;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
        entry.ttl = __privateGet(this, _ttls)[i4];
        const age = perf.now() - __privateGet(this, _starts)[i4];
        entry.start = Math.floor(Date.now() - age);
      }
      if (__privateGet(this, _sizes)) {
        entry.size = __privateGet(this, _sizes)[i4];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   */
  set(k3, v2, setOptions = {}) {
    var _a, _b, _c;
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = __privateGet(this, _requireSize).call(this, k3, v2, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.delete(k3);
      return this;
    }
    let index = __privateGet(this, _size) === 0 ? void 0 : __privateGet(this, _keyMap).get(k3);
    if (index === void 0) {
      index = __privateGet(this, _size) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size) === __privateGet(this, _max) ? __privateMethod(this, _evict, evict_fn).call(this, false) : __privateGet(this, _size);
      __privateGet(this, _keyList)[index] = k3;
      __privateGet(this, _valList)[index] = v2;
      __privateGet(this, _keyMap).set(k3, index);
      __privateGet(this, _next)[__privateGet(this, _tail)] = index;
      __privateGet(this, _prev)[index] = __privateGet(this, _tail);
      __privateSet(this, _tail, index);
      __privateWrapper(this, _size)._++;
      __privateGet(this, _addItemSize).call(this, index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index);
      const oldVal = __privateGet(this, _valList)[index];
      if (v2 !== oldVal) {
        if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
        } else if (!noDisposeOnSet) {
          if (__privateGet(this, _hasDispose)) {
            (_a = __privateGet(this, _dispose)) == null ? void 0 : _a.call(this, oldVal, k3, "set");
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            (_b = __privateGet(this, _disposed)) == null ? void 0 : _b.push([oldVal, k3, "set"]);
          }
        }
        __privateGet(this, _removeItemSize).call(this, index);
        __privateGet(this, _addItemSize).call(this, index, size, status);
        __privateGet(this, _valList)[index] = v2;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !__privateGet(this, _ttls)) {
      __privateMethod(this, _initializeTTLTracking, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _ttls)) {
      if (!noUpdateTTL) {
        __privateGet(this, _setItemTTL).call(this, index, ttl, start);
      }
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index);
    }
    if (!noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt == null ? void 0 : dt.shift()) {
        (_c = __privateGet(this, _disposeAfter)) == null ? void 0 : _c.call(this, ...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var _a;
    try {
      while (__privateGet(this, _size)) {
        const val = __privateGet(this, _valList)[__privateGet(this, _head)];
        __privateMethod(this, _evict, evict_fn).call(this, true);
        if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
        const dt = __privateGet(this, _disposed);
        let task;
        while (task = dt == null ? void 0 : dt.shift()) {
          (_a = __privateGet(this, _disposeAfter)) == null ? void 0 : _a.call(this, ...task);
        }
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k3, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = __privateGet(this, _keyMap).get(k3);
    if (index !== void 0) {
      const v2 = __privateGet(this, _valList)[index];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2) && v2.__staleWhileFetching === void 0) {
        return false;
      }
      if (!__privateGet(this, _isStale).call(this, index)) {
        if (updateAgeOnHas) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        if (status) {
          status.has = "hit";
          __privateGet(this, _statusTTL).call(this, status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        __privateGet(this, _statusTTL).call(this, status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k3, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = __privateGet(this, _keyMap).get(k3);
    if (index !== void 0 && (allowStale || !__privateGet(this, _isStale).call(this, index))) {
      const v2 = __privateGet(this, _valList)[index];
      return __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2) ? v2.__staleWhileFetching : v2;
    }
  }
  async fetch(k3, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!__privateGet(this, _hasFetchMethod)) {
      if (status)
        status.fetch = "get";
      return this.get(k3, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = __privateGet(this, _keyMap).get(k3);
    if (index === void 0) {
      if (status)
        status.fetch = "miss";
      const p3 = __privateMethod(this, _backgroundFetch, backgroundFetch_fn).call(this, k3, index, options, context);
      return p3.__returned = p3;
    } else {
      const v2 = __privateGet(this, _valList)[index];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2)) {
        const stale = allowStale && v2.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v2.__staleWhileFetching : v2.__returned = v2;
      }
      const isStale = __privateGet(this, _isStale).call(this, index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        if (status)
          __privateGet(this, _statusTTL).call(this, status, index);
        return v2;
      }
      const p3 = __privateMethod(this, _backgroundFetch, backgroundFetch_fn).call(this, k3, index, options, context);
      const hasStale = p3.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p3.__staleWhileFetching : p3.__returned = p3;
    }
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k3, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = __privateGet(this, _keyMap).get(k3);
    if (index !== void 0) {
      const value = __privateGet(this, _valList)[index];
      const fetching = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, value);
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index);
      if (__privateGet(this, _isStale).call(this, index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.delete(k3);
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k3) {
    var _a, _b, _c, _d;
    let deleted = false;
    if (__privateGet(this, _size) !== 0) {
      const index = __privateGet(this, _keyMap).get(k3);
      if (index !== void 0) {
        deleted = true;
        if (__privateGet(this, _size) === 1) {
          this.clear();
        } else {
          __privateGet(this, _removeItemSize).call(this, index);
          const v2 = __privateGet(this, _valList)[index];
          if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2)) {
            v2.__abortController.abort(new Error("deleted"));
          } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
            if (__privateGet(this, _hasDispose)) {
              (_a = __privateGet(this, _dispose)) == null ? void 0 : _a.call(this, v2, k3, "delete");
            }
            if (__privateGet(this, _hasDisposeAfter)) {
              (_b = __privateGet(this, _disposed)) == null ? void 0 : _b.push([v2, k3, "delete"]);
            }
          }
          __privateGet(this, _keyMap).delete(k3);
          __privateGet(this, _keyList)[index] = void 0;
          __privateGet(this, _valList)[index] = void 0;
          if (index === __privateGet(this, _tail)) {
            __privateSet(this, _tail, __privateGet(this, _prev)[index]);
          } else if (index === __privateGet(this, _head)) {
            __privateSet(this, _head, __privateGet(this, _next)[index]);
          } else {
            __privateGet(this, _next)[__privateGet(this, _prev)[index]] = __privateGet(this, _next)[index];
            __privateGet(this, _prev)[__privateGet(this, _next)[index]] = __privateGet(this, _prev)[index];
          }
          __privateWrapper(this, _size)._--;
          __privateGet(this, _free).push(index);
        }
      }
    }
    if (__privateGet(this, _hasDisposeAfter) && ((_c = __privateGet(this, _disposed)) == null ? void 0 : _c.length)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt == null ? void 0 : dt.shift()) {
        (_d = __privateGet(this, _disposeAfter)) == null ? void 0 : _d.call(this, ...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    var _a, _b, _c;
    for (const index of __privateMethod(this, _rindexes, rindexes_fn).call(this, { allowStale: true })) {
      const v2 = __privateGet(this, _valList)[index];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2)) {
        v2.__abortController.abort(new Error("deleted"));
      } else {
        const k3 = __privateGet(this, _keyList)[index];
        if (__privateGet(this, _hasDispose)) {
          (_a = __privateGet(this, _dispose)) == null ? void 0 : _a.call(this, v2, k3, "delete");
        }
        if (__privateGet(this, _hasDisposeAfter)) {
          (_b = __privateGet(this, _disposed)) == null ? void 0 : _b.push([v2, k3, "delete"]);
        }
      }
    }
    __privateGet(this, _keyMap).clear();
    __privateGet(this, _valList).fill(void 0);
    __privateGet(this, _keyList).fill(void 0);
    if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
      __privateGet(this, _ttls).fill(0);
      __privateGet(this, _starts).fill(0);
    }
    if (__privateGet(this, _sizes)) {
      __privateGet(this, _sizes).fill(0);
    }
    __privateSet(this, _head, 0);
    __privateSet(this, _tail, 0);
    __privateGet(this, _free).length = 0;
    __privateSet(this, _calculatedSize, 0);
    __privateSet(this, _size, 0);
    if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt == null ? void 0 : dt.shift()) {
        (_c = __privateGet(this, _disposeAfter)) == null ? void 0 : _c.call(this, ...task);
      }
    }
  }
};
_max = new WeakMap();
_maxSize = new WeakMap();
_dispose = new WeakMap();
_disposeAfter = new WeakMap();
_fetchMethod = new WeakMap();
_size = new WeakMap();
_calculatedSize = new WeakMap();
_keyMap = new WeakMap();
_keyList = new WeakMap();
_valList = new WeakMap();
_next = new WeakMap();
_prev = new WeakMap();
_head = new WeakMap();
_tail = new WeakMap();
_free = new WeakMap();
_disposed = new WeakMap();
_sizes = new WeakMap();
_starts = new WeakMap();
_ttls = new WeakMap();
_hasDispose = new WeakMap();
_hasFetchMethod = new WeakMap();
_hasDisposeAfter = new WeakMap();
_initializeTTLTracking = new WeakSet();
initializeTTLTracking_fn = function() {
  const ttls = new ZeroArray(__privateGet(this, _max));
  const starts = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _ttls, ttls);
  __privateSet(this, _starts, starts);
  __privateSet(this, _setItemTTL, (index, ttl, start = perf.now()) => {
    starts[index] = ttl !== 0 ? start : 0;
    ttls[index] = ttl;
    if (ttl !== 0 && this.ttlAutopurge) {
      const t3 = setTimeout(() => {
        if (__privateGet(this, _isStale).call(this, index)) {
          this.delete(__privateGet(this, _keyList)[index]);
        }
      }, ttl + 1);
      if (t3.unref) {
        t3.unref();
      }
    }
  });
  __privateSet(this, _updateItemAge, (index) => {
    starts[index] = ttls[index] !== 0 ? perf.now() : 0;
  });
  __privateSet(this, _statusTTL, (status, index) => {
    if (ttls[index]) {
      const ttl = ttls[index];
      const start = starts[index];
      status.ttl = ttl;
      status.start = start;
      status.now = cachedNow || getNow();
      status.remainingTTL = status.now + ttl - start;
    }
  });
  let cachedNow = 0;
  const getNow = () => {
    const n3 = perf.now();
    if (this.ttlResolution > 0) {
      cachedNow = n3;
      const t3 = setTimeout(() => cachedNow = 0, this.ttlResolution);
      if (t3.unref) {
        t3.unref();
      }
    }
    return n3;
  };
  this.getRemainingTTL = (key) => {
    const index = __privateGet(this, _keyMap).get(key);
    if (index === void 0) {
      return 0;
    }
    return ttls[index] === 0 || starts[index] === 0 ? Infinity : starts[index] + ttls[index] - (cachedNow || getNow());
  };
  __privateSet(this, _isStale, (index) => {
    return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];
  });
};
_updateItemAge = new WeakMap();
_statusTTL = new WeakMap();
_setItemTTL = new WeakMap();
_isStale = new WeakMap();
_initializeSizeTracking = new WeakSet();
initializeSizeTracking_fn = function() {
  const sizes = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _calculatedSize, 0);
  __privateSet(this, _sizes, sizes);
  __privateSet(this, _removeItemSize, (index) => {
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index]);
    sizes[index] = 0;
  });
  __privateSet(this, _requireSize, (k3, v2, size, sizeCalculation) => {
    if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2)) {
      return 0;
    }
    if (!isPosInt(size)) {
      if (sizeCalculation) {
        if (typeof sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation must be a function");
        }
        size = sizeCalculation(v2, k3);
        if (!isPosInt(size)) {
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
        }
      } else {
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      }
    }
    return size;
  });
  __privateSet(this, _addItemSize, (index, size, status) => {
    sizes[index] = size;
    if (__privateGet(this, _maxSize)) {
      const maxSize = __privateGet(this, _maxSize) - sizes[index];
      while (__privateGet(this, _calculatedSize) > maxSize) {
        __privateMethod(this, _evict, evict_fn).call(this, true);
      }
    }
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index]);
    if (status) {
      status.entrySize = size;
      status.totalCalculatedSize = __privateGet(this, _calculatedSize);
    }
  });
};
_removeItemSize = new WeakMap();
_addItemSize = new WeakMap();
_requireSize = new WeakMap();
_indexes = new WeakSet();
indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i4 = __privateGet(this, _tail); true; ) {
      if (!__privateMethod(this, _isValidIndex, isValidIndex_fn).call(this, i4)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i4)) {
        yield i4;
      }
      if (i4 === __privateGet(this, _head)) {
        break;
      } else {
        i4 = __privateGet(this, _prev)[i4];
      }
    }
  }
};
_rindexes = new WeakSet();
rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i4 = __privateGet(this, _head); true; ) {
      if (!__privateMethod(this, _isValidIndex, isValidIndex_fn).call(this, i4)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i4)) {
        yield i4;
      }
      if (i4 === __privateGet(this, _tail)) {
        break;
      } else {
        i4 = __privateGet(this, _next)[i4];
      }
    }
  }
};
_isValidIndex = new WeakSet();
isValidIndex_fn = function(index) {
  return index !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index]) === index;
};
_evict = new WeakSet();
evict_fn = function(free) {
  var _a, _b;
  const head = __privateGet(this, _head);
  const k3 = __privateGet(this, _keyList)[head];
  const v2 = __privateGet(this, _valList)[head];
  if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2)) {
    v2.__abortController.abort(new Error("evicted"));
  } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
    if (__privateGet(this, _hasDispose)) {
      (_a = __privateGet(this, _dispose)) == null ? void 0 : _a.call(this, v2, k3, "evict");
    }
    if (__privateGet(this, _hasDisposeAfter)) {
      (_b = __privateGet(this, _disposed)) == null ? void 0 : _b.push([v2, k3, "evict"]);
    }
  }
  __privateGet(this, _removeItemSize).call(this, head);
  if (free) {
    __privateGet(this, _keyList)[head] = void 0;
    __privateGet(this, _valList)[head] = void 0;
    __privateGet(this, _free).push(head);
  }
  if (__privateGet(this, _size) === 1) {
    __privateSet(this, _head, __privateSet(this, _tail, 0));
    __privateGet(this, _free).length = 0;
  } else {
    __privateSet(this, _head, __privateGet(this, _next)[head]);
  }
  __privateGet(this, _keyMap).delete(k3);
  __privateWrapper(this, _size)._--;
  return head;
};
_backgroundFetch = new WeakSet();
backgroundFetch_fn = function(k3, index, options, context) {
  const v2 = index === void 0 ? void 0 : __privateGet(this, _valList)[index];
  if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v2)) {
    return v2;
  }
  const ac = new AbortController();
  const { signal } = options;
  signal == null ? void 0 : signal.addEventListener("abort", () => ac.abort(signal.reason), {
    signal: ac.signal
  });
  const fetchOpts = {
    signal: ac.signal,
    options,
    context
  };
  const cb = (v3, updateCache = false) => {
    const { aborted } = ac.signal;
    const ignoreAbort = options.ignoreFetchAbort && v3 !== void 0;
    if (options.status) {
      if (aborted && !updateCache) {
        options.status.fetchAborted = true;
        options.status.fetchError = ac.signal.reason;
        if (ignoreAbort)
          options.status.fetchAbortIgnored = true;
      } else {
        options.status.fetchResolved = true;
      }
    }
    if (aborted && !ignoreAbort && !updateCache) {
      return fetchFail(ac.signal.reason);
    }
    const bf2 = p3;
    if (__privateGet(this, _valList)[index] === p3) {
      if (v3 === void 0) {
        if (bf2.__staleWhileFetching) {
          __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
        } else {
          this.delete(k3);
        }
      } else {
        if (options.status)
          options.status.fetchUpdated = true;
        this.set(k3, v3, fetchOpts.options);
      }
    }
    return v3;
  };
  const eb = (er) => {
    if (options.status) {
      options.status.fetchRejected = true;
      options.status.fetchError = er;
    }
    return fetchFail(er);
  };
  const fetchFail = (er) => {
    const { aborted } = ac.signal;
    const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
    const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
    const noDelete = allowStale || options.noDeleteOnFetchRejection;
    const bf2 = p3;
    if (__privateGet(this, _valList)[index] === p3) {
      const del = !noDelete || bf2.__staleWhileFetching === void 0;
      if (del) {
        this.delete(k3);
      } else if (!allowStaleAborted) {
        __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
      }
    }
    if (allowStale) {
      if (options.status && bf2.__staleWhileFetching !== void 0) {
        options.status.returnedStale = true;
      }
      return bf2.__staleWhileFetching;
    } else if (bf2.__returned === bf2) {
      throw er;
    }
  };
  const pcall = (res, rej) => {
    var _a;
    const fmp = (_a = __privateGet(this, _fetchMethod)) == null ? void 0 : _a.call(this, k3, v2, fetchOpts);
    if (fmp && fmp instanceof Promise) {
      fmp.then((v3) => res(v3), rej);
    }
    ac.signal.addEventListener("abort", () => {
      if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
        res();
        if (options.allowStaleOnFetchAbort) {
          res = (v3) => cb(v3, true);
        }
      }
    });
  };
  if (options.status)
    options.status.fetchDispatched = true;
  const p3 = new Promise(pcall).then(cb, eb);
  const bf = Object.assign(p3, {
    __abortController: ac,
    __staleWhileFetching: v2,
    __returned: void 0
  });
  if (index === void 0) {
    this.set(k3, bf, { ...fetchOpts.options, status: void 0 });
    index = __privateGet(this, _keyMap).get(k3);
  } else {
    __privateGet(this, _valList)[index] = bf;
  }
  return bf;
};
_isBackgroundFetch = new WeakSet();
isBackgroundFetch_fn = function(p3) {
  if (!__privateGet(this, _hasFetchMethod))
    return false;
  const b4 = p3;
  return !!b4 && b4 instanceof Promise && b4.hasOwnProperty("__staleWhileFetching") && b4.__abortController instanceof AbortController;
};
_connect = new WeakSet();
connect_fn = function(p3, n3) {
  __privateGet(this, _prev)[n3] = p3;
  __privateGet(this, _next)[p3] = n3;
};
_moveToTail = new WeakSet();
moveToTail_fn = function(index) {
  if (index !== __privateGet(this, _tail)) {
    if (index === __privateGet(this, _head)) {
      __privateSet(this, _head, __privateGet(this, _next)[index]);
    } else {
      __privateMethod(this, _connect, connect_fn).call(this, __privateGet(this, _prev)[index], __privateGet(this, _next)[index]);
    }
    __privateMethod(this, _connect, connect_fn).call(this, __privateGet(this, _tail), index);
    __privateSet(this, _tail, index);
  }
};
var LRUCache = _LRUCache;
var mjs_default = LRUCache;

// node_modules/md-editor-v3/lib/es/chunks/index.mjs
var Me = (e4, a2) => {
  const l2 = inject("editorId"), { noImgZoomIn: t3 } = e4, n3 = x(() => {
    const r4 = document.querySelectorAll(`#${l2}-preview img`);
    r4.length !== 0 && medium_zoom_esm_default(r4, {
      background: "#00000073"
    });
  });
  onMounted(() => {
    !t3 && n3();
  }), watch([a2, toRef(e4.setting, "preview")], () => {
    !t3 && n3();
  });
};
var Re = Me;
var Be = (e4, a2) => {
  if (typeof a2[e4] == "string")
    return a2[e4];
  const l2 = `<i class="${a}-iconfont ${a}-icon-${e4}"></i>`;
  switch (l.iconfontType) {
    case "svg":
      return `<svg class="${a}-icon" aria-hidden="true"><use xlink:href="#${a}-icon-${e4}"></use></svg>`;
    default:
      return l2;
  }
};
var Le = (e4, a2) => {
  const l2 = inject("editorId"), t3 = inject("usedLanguageText"), n3 = inject("customIcon"), r4 = () => {
    document.querySelectorAll(`#${l2}-preview pre`).forEach((u2) => {
      var b4, y2;
      let s3 = -1;
      (b4 = u2.querySelector(".copy-button")) == null || b4.remove();
      const o2 = ((y2 = t3.value.copyCode) == null ? void 0 : y2.text) || "复制代码", d3 = document.createElement("span");
      d3.setAttribute("class", "copy-button"), d3.dataset.tips = o2, d3.innerHTML = Be("copy", n3.value), d3.addEventListener("click", () => {
        var v2, k3;
        clearTimeout(s3);
        const m5 = u2.querySelector("code").innerText, h6 = (0, import_copy_to_clipboard.default)(e4.formatCopiedText(m5)), f3 = ((v2 = t3.value.copyCode) == null ? void 0 : v2.successTips) || "已复制！", w2 = ((k3 = t3.value.copyCode) == null ? void 0 : k3.failTips) || "已复制！";
        d3.dataset.tips = h6 ? f3 : w2, s3 = window.setTimeout(() => {
          d3.dataset.tips = o2;
        }, 1500);
      }), u2.appendChild(d3);
    });
  }, i4 = () => {
    nextTick(r4);
  }, c2 = (u2) => {
    u2 && nextTick(r4);
  };
  watch(() => a2.value, i4), watch(() => e4.setting.preview, c2), watch(() => e4.setting.htmlPreview, c2), watch(() => t3.value, r4), onMounted(r4);
};
var Ne = Le;
var Oe = (e4) => {
  var r4;
  const a2 = (r4 = l.editorExtensions) == null ? void 0 : r4.highlight, l2 = a2 == null ? void 0 : a2.instance, t3 = inject("highlight"), n3 = shallowRef(l2);
  return onMounted(() => {
    if (!e4.noHighlight && !n3.value) {
      const i4 = document.createElement("script");
      i4.src = t3.value.js, i4.onload = () => {
        n3.value = window.hljs;
      }, i4.id = `${a}-hljs`, h4(i4, "hljs");
      const c2 = document.createElement("link");
      c2.rel = "stylesheet", c2.href = t3.value.css, c2.id = `${a}-hlCss`, h4(c2);
    }
  }), watch(
    () => t3.value.css,
    (i4) => {
      b3(`${a}-hlCss`, "href", i4);
    }
  ), n3;
};
var Ue = Oe;
var je = (e4) => {
  const a2 = inject("theme"), { editorExtensions: l2 } = l, t3 = l2 == null ? void 0 : l2.mermaid, n3 = shallowRef(t3 == null ? void 0 : t3.instance), r4 = shallowRef(-1), i4 = new mjs_default({
    max: 1e3,
    // 缓存10分钟
    ttl: 6e5
  }), c2 = () => {
    const s3 = n3.value;
    !e4.noMermaid && s3 && (s3.initialize({
      startOnLoad: false,
      theme: a2.value === "dark" ? "dark" : "default"
    }), r4.value = r4.value + 1);
  };
  return watch(
    () => a2.value,
    () => {
      i4.clear(), c2();
    }
  ), onMounted(() => {
    if (!e4.noMermaid && !(t3 != null && t3.instance)) {
      const s3 = (t3 == null ? void 0 : t3.js) || k;
      if (/\.mjs/.test(s3))
        import(
          /* @vite-ignore */
          /* webpackIgnore: true */
          s3
        ).then((o2) => {
          n3.value = o2.default, c2();
        });
      else {
        const o2 = document.createElement("script");
        o2.id = `${a}-mermaid`, o2.src = s3, o2.onload = () => {
          n3.value = window.mermaid, c2();
        }, h4(o2, "mermaid");
      }
    }
  }), { mermaidRef: n3, reRenderRef: r4, replaceMermaid: () => {
    nextTick(() => {
      if (!e4.noMermaid && n3.value) {
        const s3 = document.querySelectorAll(
          `div.${a}-mermaid`
        ), o2 = document.createElement("div");
        o2.style.width = document.body.offsetWidth + "px", o2.style.height = document.body.offsetHeight + "px", o2.style.position = "fixed", o2.style.zIndex = "-10000", o2.style.top = "-10000";
        let d3 = s3.length;
        d3 > 0 && document.body.appendChild(o2), s3.forEach(async (b4) => {
          let y2 = i4.get(b4.innerText);
          if (!y2) {
            const h6 = U(), f3 = n3.value.renderAsync || n3.value.render;
            let w2 = "";
            try {
              w2 = await f3(h6, b4.innerText, o2);
            } catch {
            }
            y2 = typeof w2 == "string" ? w2 : w2.svg, i4.set(b4.innerText, y2);
          }
          const m5 = document.createElement("p");
          m5.className = `${a}-mermaid`, m5.setAttribute("data-processed", ""), m5.innerHTML = y2, b4.dataset.line !== void 0 && (m5.dataset.line = b4.dataset.line), b4.replaceWith(m5), --d3 === 0 && o2.remove();
        });
      }
    });
  } };
};
var Ge = je;
var De = (e4) => {
  var n3;
  const a2 = (n3 = l.editorExtensions) == null ? void 0 : n3.katex, l2 = a2 == null ? void 0 : a2.instance, t3 = shallowRef(l2);
  return onMounted(() => {
    if (!e4.noKatex && !t3.value) {
      const r4 = document.createElement("script");
      r4.src = (a2 == null ? void 0 : a2.js) || b.js, r4.onload = () => {
        t3.value = window.katex;
      }, r4.id = `${a}-katex`;
      const i4 = document.createElement("link");
      i4.rel = "stylesheet", i4.href = (a2 == null ? void 0 : a2.css) || b.css, i4.id = `${a}-katexCss`, h4(r4, "katex"), h4(i4);
    }
  }), t3;
};
var Ve = De;
var ze = (e4, a2) => {
  const l2 = e4.renderer.rules.fence.bind(e4.renderer.rules);
  e4.renderer.rules.fence = (t3, n3, r4, i4, c2) => {
    const u2 = t3[n3], s3 = u2.content.trim();
    if (u2.info === "mermaid") {
      let o2;
      return t3[n3].map && t3[n3].level === 0 && (o2 = t3[n3].map[0], t3[n3].attrSet("data-line", String(o2))), `<div class="${a}-mermaid" ${o2 !== void 0 ? "data-line=" + o2 : ""} data-mermaid-theme=${a2.themeRef.value}>${s3}</div>`;
    }
    return l2(t3, n3, r4, i4, c2);
  };
};
var We = ze;
var Q = (e4, a2) => {
  let l2 = true, t3 = true;
  const n3 = e4.posMax, r4 = a2 > 0 ? e4.src.charCodeAt(a2 - 1) : -1, i4 = a2 + 1 <= n3 ? e4.src.charCodeAt(a2 + 1) : -1;
  return (r4 === 32 || r4 === 9 || i4 >= 48 && i4 <= 57) && (t3 = false), (i4 === 32 || i4 === 9) && (l2 = false), {
    can_open: l2,
    can_close: t3
  };
};
var Ke = (e4, a2) => {
  let l2, t3, n3, r4;
  if (e4.src[e4.pos] !== "$")
    return false;
  if (n3 = Q(e4, e4.pos), !n3.can_open)
    return a2 || (e4.pending += "$"), e4.pos += 1, true;
  const i4 = e4.pos + 1;
  for (l2 = i4; (l2 = e4.src.indexOf("$", l2)) !== -1; ) {
    for (r4 = l2 - 1; e4.src[r4] === "\\"; )
      r4 -= 1;
    if ((l2 - r4) % 2 == 1)
      break;
    l2 += 1;
  }
  return l2 === -1 ? (a2 || (e4.pending += "$"), e4.pos = i4, true) : l2 - i4 === 0 ? (a2 || (e4.pending += "$$"), e4.pos = i4 + 1, true) : (n3 = Q(e4, l2), n3.can_close ? (a2 || (t3 = e4.push("math_inline", "math", 0), t3.markup = "$", t3.content = e4.src.slice(i4, l2)), e4.pos = l2 + 1, true) : (a2 || (e4.pending += "$"), e4.pos = i4, true));
};
var qe = (e4, a2, l2, t3) => {
  let n3, r4, i4, c2, u2 = false, s3 = e4.bMarks[a2] + e4.tShift[a2], o2 = e4.eMarks[a2];
  if (s3 + 2 > o2 || e4.src.slice(s3, s3 + 2) !== "$$")
    return false;
  if (s3 += 2, n3 = e4.src.slice(s3, o2), t3)
    return true;
  for (n3.trim().slice(-2) === "$$" && (n3 = n3.trim().slice(0, -2), u2 = true), i4 = a2; !u2 && (i4++, !(i4 >= l2 || (s3 = e4.bMarks[i4] + e4.tShift[i4], o2 = e4.eMarks[i4], s3 < o2 && e4.tShift[i4] < e4.blkIndent))); )
    e4.src.slice(s3, o2).trim().slice(-2) === "$$" && (c2 = e4.src.slice(0, o2).lastIndexOf("$$"), r4 = e4.src.slice(s3, c2), u2 = true);
  e4.line = i4 + 1;
  const d3 = e4.push("math_block", "math", 0);
  return d3.block = true, d3.content = (n3 && n3.trim() ? n3 + `
` : "") + e4.getLines(a2 + 1, i4, e4.tShift[a2], true) + (r4 && r4.trim() ? r4 : ""), d3.map = [a2, e4.line], d3.markup = "$$", true;
};
var Ze = (e4, a2) => {
  const l2 = (n3) => {
    if (a2.katexRef.value) {
      const r4 = a2.katexRef.value.renderToString(n3, {
        throwOnError: false
      });
      return `<span class="${a}-katex-inline" data-processed>${r4}</span>`;
    } else
      return `<span class="${a}-katex-inline">${n3}</span>`;
  }, t3 = (n3, r4) => {
    if (a2.katexRef.value) {
      const i4 = a2.katexRef.value.renderToString(n3, {
        throwOnError: false,
        displayMode: true
      });
      return `<p class="${a}-katex-block" data-line=${r4} data-processed>${i4}</p>`;
    } else
      return `<p class="${a}-katex-block" data-line=${r4}>${n3}</p>`;
  };
  e4.inline.ruler.after("escape", "math_inline", Ke), e4.block.ruler.after("blockquote", "math_block", qe, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  }), e4.renderer.rules.math_inline = (n3, r4) => l2(n3[r4].content), e4.renderer.rules.math_block = (n3, r4) => t3(n3[r4].content, n3[r4].map[0]) + `
`;
};
var Je = Ze;
var Xe = (e4, a2) => {
  a2 = a2 || {};
  const l2 = 3, t3 = a2.marker || "!", n3 = t3.charCodeAt(0), r4 = t3.length;
  let i4 = "", c2 = "";
  const u2 = (o2, d3, b4, y2, m5) => {
    const h6 = o2[d3];
    return h6.type === "admonition_open" ? (o2[d3].attrPush([
      "class",
      `${a}-admonition ${a}-admonition-${h6.info}`
    ]), o2[d3].attrSet("data-line", String(o2[d3].map[0]))) : h6.type === "admonition_title_open" && o2[d3].attrPush(["class", `${a}-admonition-title`]), m5.renderToken(o2, d3, b4);
  }, s3 = (o2) => {
    const d3 = o2.trim().split(" ", 2);
    c2 = "", i4 = d3[0], d3.length > 1 && (c2 = o2.substring(i4.length + 2)), (c2 === "" || !c2) && (c2 = i4);
  };
  e4.block.ruler.before(
    "code",
    "admonition",
    (o2, d3, b4, y2) => {
      let m5, h6, f3, w2 = false, v2 = o2.bMarks[d3] + o2.tShift[d3], k3 = o2.eMarks[d3];
      if (n3 !== o2.src.charCodeAt(v2))
        return false;
      for (m5 = v2 + 1; m5 <= k3 && t3[(m5 - v2) % r4] === o2.src[m5]; m5++)
        ;
      const $2 = Math.floor((m5 - v2) / r4);
      if ($2 !== l2)
        return false;
      m5 -= (m5 - v2) % r4;
      const E2 = o2.src.slice(v2, m5), T3 = o2.src.slice(m5, k3);
      if (s3(T3), y2)
        return true;
      for (h6 = d3; h6++, !(h6 >= b4 || (v2 = o2.bMarks[h6] + o2.tShift[h6], k3 = o2.eMarks[h6], v2 < k3 && o2.sCount[h6] < o2.blkIndent)); )
        if (n3 === o2.src.charCodeAt(v2) && !(o2.sCount[h6] - o2.blkIndent >= 4)) {
          for (m5 = v2 + 1; m5 <= k3 && t3[(m5 - v2) % r4] === o2.src[m5]; m5++)
            ;
          if (!(Math.floor((m5 - v2) / r4) < $2) && (m5 -= (m5 - v2) % r4, m5 = o2.skipSpaces(m5), !(m5 < k3))) {
            w2 = true;
            break;
          }
        }
      const x2 = o2.parentType, B2 = o2.lineMax;
      return o2.parentType = "root", o2.lineMax = h6, f3 = o2.push("admonition_open", "div", 1), f3.markup = E2, f3.block = true, f3.info = i4, f3.map = [d3, h6], f3 = o2.push("admonition_title_open", "p", 1), f3.markup = E2 + " " + i4, f3.map = [d3, h6], f3 = o2.push("inline", "", 0), f3.content = c2, f3.map = [d3, o2.line - 1], f3.children = [], f3 = o2.push("admonition_title_close", "p", -1), f3.markup = E2 + " " + i4, o2.md.block.tokenize(o2, d3 + 1, h6), f3 = o2.push("admonition_close", "div", -1), f3.markup = o2.src.slice(v2, m5), f3.block = true, o2.parentType = x2, o2.lineMax = B2, o2.line = h6 + (w2 ? 1 : 0), true;
    },
    {
      alt: ["paragraph", "reference", "blockquote", "list"]
    }
  ), e4.renderer.rules.admonition_open = u2, e4.renderer.rules.admonition_title_open = u2, e4.renderer.rules.admonition_title_close = u2, e4.renderer.rules.admonition_close = u2;
};
var Qe = Xe;
var Ye = (e4, a2) => {
  e4.renderer.rules.heading_open = (l2, t3) => {
    var c2;
    const n3 = l2[t3], r4 = ((c2 = l2[t3 + 1].children) == null ? void 0 : c2.reduce((u2, s3) => u2 + (s3.content || ""), "")) || "", i4 = n3.markup.length;
    return a2.headsRef.value.push({
      text: r4,
      level: i4
    }), n3.map && n3.level === 0 && (n3.attrSet("data-line", String(n3.map[0])), n3.attrSet(
      "id",
      a2.mdHeadingId(r4, i4, a2.headsRef.value.length)
    )), e4.renderer.renderToken(l2, t3, a2);
  }, e4.renderer.rules.heading_close = (l2, t3, n3, r4, i4) => i4.renderToken(l2, t3, n3);
};
var et = Ye;
var tt = (e4, a2) => {
  const l2 = e4.renderer.rules.fence, t3 = e4.utils.unescapeAll, n3 = /\[(\w*)(?::([\w ]*))?\]/;
  function r4(s3) {
    return s3.info ? t3(s3.info).trim() : "";
  }
  function i4(s3) {
    const o2 = r4(s3), [d3 = null, b4 = ""] = (n3.exec(o2) || []).slice(1);
    return [d3, b4];
  }
  function c2(s3) {
    const o2 = r4(s3);
    return o2 ? o2.split(/(\s+)/g)[0] : "";
  }
  const u2 = (s3, o2, d3, b4, y2) => {
    if (s3[o2].hidden)
      return "";
    const [m5, h6] = i4(s3[o2]);
    if (m5 === null)
      return l2(s3, o2, d3, b4, y2);
    let f3, w2, v2, k3, $2 = "", E2 = "";
    for (let T3 = o2; T3 < s3.length && (f3 = s3[T3], [w2, v2] = i4(f3), w2 === m5); T3++)
      f3.info = f3.info.replace(n3, ""), f3.hidden = true, k3 = T3 - o2 > 0 ? "" : " checked", $2 += `<li><input type="radio" name="label-group-${a2.editorId}-${o2}"${k3}><label for="group-${a2.editorId}-${o2}-tab-${T3 - o2}" onclick="this.previousElementSibling.click()">${v2 || c2(f3)}</label></li>
`, E2 += `<input type="radio" id="group-${a2.editorId}-${o2}-tab-${T3 - o2}" name="group-${a2.editorId}-${o2}"${k3}>
` + l2(s3, T3, d3, b4, y2);
    return `<div class="code-tabs">
<ul>
` + $2 + `</ul>
` + E2 + "</div>";
  };
  e4.renderer.rules.fence = u2;
};
var nt = tt;
var ot = (e4) => {
  [
    "paragraph_open",
    "table_open",
    "ordered_list_open",
    "bullet_list_open",
    "blockquote_open",
    "hr",
    "html_block",
    "fence"
  ].forEach((a2) => {
    const l2 = e4.renderer.rules[a2];
    l2 ? e4.renderer.rules[a2] = (t3, n3, r4, i4, c2) => {
      let u2;
      const s3 = l2(t3, n3, r4, i4, c2);
      return t3[n3].map && t3[n3].level === 0 && !/^<!--/.test(s3) ? (u2 = t3[n3].map[0], s3.replace(/^(<[^>]*)/, `$1 data-line="${u2}"`)) : s3;
    } : e4.renderer.rules[a2] = (t3, n3, r4, i4, c2) => {
      let u2;
      return t3[n3].map && t3[n3].level === 0 && (u2 = t3[n3].map[0], t3[n3].attrSet("data-line", String(u2))), c2.renderToken(t3, n3, r4);
    };
  });
};
var rt = (e4, a2) => {
  const { editorConfig: l2, markdownItConfig: t3, markdownItPlugins: n3 } = l, r4 = inject("editorId"), i4 = inject("showCodeRowNumber"), c2 = inject("theme"), u2 = ref([]), s3 = Ue(e4), o2 = Ve(e4), { reRenderRef: d3, replaceMermaid: b4 } = Ge(e4), y2 = (0, import_markdown_it.default)({
    html: true,
    breaks: true
  });
  t3(y2);
  const m5 = [
    {
      type: "katex",
      plugin: Je,
      options: { katexRef: o2 }
    },
    {
      type: "image",
      plugin: r3,
      options: { figcaption: true, classes: "md-zoom" }
    },
    {
      type: "admonition",
      plugin: Qe,
      options: {}
    },
    {
      type: "taskList",
      plugin: import_markdown_it_task_lists.default,
      options: {}
    },
    {
      type: "heading",
      plugin: et,
      options: { mdHeadingId: e4.mdHeadingId, headsRef: u2 }
    },
    {
      type: "codeTabs",
      plugin: nt,
      options: { editorId: r4 }
    }
  ];
  e4.noMermaid || m5.push({
    type: "mermaid",
    plugin: We,
    options: { themeRef: c2 }
  }), n3(m5).forEach(($2) => {
    y2.use($2.plugin, $2.options);
  });
  const h6 = y2.options.highlight;
  y2.set({
    highlight: ($2, E2, T3) => {
      if (h6) {
        const L4 = h6($2, E2, T3);
        if (L4)
          return L4;
      }
      let x2;
      !e4.noHighlight && s3.value ? s3.value.getLanguage(E2) ? x2 = s3.value.highlight($2, {
        language: E2,
        ignoreIllegals: true
      }).value : x2 = s3.value.highlightAuto($2).value : x2 = y2.utils.escapeHtml($2);
      const B2 = i4 ? w(x2.replace(/^\n+|\n+$/g, "")) : `<span class="code-block">${x2.replace(/^\n+|\n+$/g, "")}</span>`;
      return `<pre><code class="language-${E2}" language=${E2}>${B2}</code></pre>`;
    }
  }), ot(y2);
  const f3 = ref(e4.sanitize(y2.render(e4.modelValue))), w2 = () => {
    C2.emit(r4, S, f3.value), e4.onHtmlChanged(f3.value), e4.onGetCatalog(u2.value), C2.emit(r4, I2, u2.value), b4();
  };
  onMounted(w2);
  const v2 = x(
    async () => {
      u2.value = [], f3.value = e4.sanitize(y2.render(e4.modelValue)), w2();
    },
    (l2 == null ? void 0 : l2.renderDelay) !== void 0 ? l2 == null ? void 0 : l2.renderDelay : a2 ? 0 : 500
  ), k3 = computed(() => (e4.noKatex || o2.value) && (e4.noHighlight || s3.value));
  return watch([toRef(e4, "modelValue"), k3, d3], v2), onMounted(() => {
    C2.on(r4, {
      name: D,
      callback() {
        C2.emit(r4, I2, u2.value);
      }
    });
  }), { html: f3 };
};
var at = rt;
var le = {
  modelValue: {
    type: String,
    default: ""
  },
  setting: {
    type: Object,
    default: () => ({})
  },
  onHtmlChanged: {
    type: Function,
    default: () => {
    }
  },
  onGetCatalog: {
    type: Function,
    default: () => {
    }
  },
  mdHeadingId: {
    type: Function,
    default: () => ""
  },
  noMermaid: {
    type: Boolean,
    default: false
  },
  sanitize: {
    type: Function,
    default: (e4) => e4
  },
  // 不使用该函数功能
  noKatex: {
    type: Boolean,
    default: false
  },
  formatCopiedText: {
    type: Function,
    default: (e4) => e4
  },
  noHighlight: {
    type: Boolean,
    default: false
  },
  previewOnly: {
    type: Boolean,
    default: false
  },
  noImgZoomIn: {
    type: Boolean
  }
};
var wt = {
  ...le,
  onChange: {
    type: Function,
    default: () => {
    }
  },
  placeholder: {
    type: String,
    default: ""
  },
  scrollAuto: {
    type: Boolean
  },
  autofocus: {
    type: Boolean
  },
  disabled: {
    type: Boolean
  },
  readonly: {
    type: Boolean
  },
  maxlength: {
    type: Number
  },
  autoDetectCode: {
    type: Boolean
  },
  /**
   * 输入框失去焦点时触发事件
   */
  onBlur: {
    type: Function,
    default: () => {
    }
  },
  /**
   * 输入框获得焦点时触发事件
   */
  onFocus: {
    type: Function,
    default: () => {
    }
  },
  noPrettier: {
    type: Boolean
  },
  completions: {
    type: Array
  },
  catalogVisible: {
    type: Boolean
  },
  theme: {
    type: String,
    default: "light"
  },
  onInput: {
    type: Function
  },
  onDrop: {
    type: Function,
    default: () => {
    }
  },
  inputBoxWitdh: {
    type: String
  },
  onInputBoxWitdhChange: {
    type: Function
  }
};
var lt = defineComponent({
  name: "ContentPreview",
  props: le,
  setup(e4) {
    const a2 = inject("editorId"), l2 = inject("previewTheme"), t3 = inject("showCodeRowNumber"), {
      html: n3
    } = at(e4, e4.previewOnly);
    return Ne(e4, n3), Re(e4, n3), () => createVNode(Fragment, null, [createVNode("div", {
      id: `${a2}-preview-wrapper`,
      class: `${a}-preview-wrapper`,
      "data-show": e4.setting.preview,
      key: "content-preview-wrapper"
    }, [createVNode("article", {
      id: `${a2}-preview`,
      class: [`${a}-preview`, `${l2 == null ? void 0 : l2.value}-theme`, t3 && `${a}-scrn`],
      innerHTML: n3.value
    }, null)]), !e4.previewOnly && createVNode("div", {
      id: `${a2}-html-wrapper`,
      class: `${a}-preview-wrapper`,
      "data-show": e4.setting.htmlPreview,
      key: "html-preview-wrapper"
    }, [createVNode("div", {
      class: `${a}-html`
    }, [n3.value])])]);
  }
});
var kt = (e4, a2) => {
  const { editorId: l2 } = e4, t3 = reactive({
    // 是否已编译成html
    buildFinished: false,
    // 存储当前最新的html
    html: ""
  });
  watch(
    () => e4.modelValue,
    () => {
      t3.buildFinished = false;
    }
  ), onMounted(() => {
    C2.on(l2, {
      name: S,
      callback(n3) {
        t3.buildFinished = true, t3.html = n3;
      }
    }), C2.on(l2, {
      name: E,
      callback() {
        const n3 = new Promise((r4) => {
          if (t3.buildFinished)
            r4(t3.html);
          else {
            const i4 = (c2) => {
              r4(c2), C2.remove(l2, S, i4);
            };
            C2.on(l2, {
              name: S,
              callback: i4
            });
          }
        });
        e4.onSave ? e4.onSave(e4.modelValue, n3) : a2.emit("onSave", e4.modelValue, n3);
      }
    });
  });
};
var ie = (e4) => {
  var n3, r4;
  const { editorId: a2 } = e4, l2 = (r4 = (n3 = l) == null ? void 0 : n3.editorExtensions) == null ? void 0 : r4.highlight;
  provide("editorId", a2), provide(
    "theme",
    computed(() => e4.theme)
  ), provide(
    "language",
    computed(() => e4.language)
  ), provide(
    "highlight",
    computed(() => {
      const i4 = {
        ...f,
        ...l2 == null ? void 0 : l2.css
      }, c2 = e4.codeStyleReverse && e4.codeStyleReverseList.includes(e4.previewTheme) ? "dark" : e4.theme;
      return {
        js: (l2 == null ? void 0 : l2.js) || c,
        css: i4[e4.codeTheme] ? i4[e4.codeTheme][c2] : f.atom[c2]
      };
    })
  ), provide("showCodeRowNumber", e4.showCodeRowNumber);
  const t3 = computed(() => {
    var c2, u2;
    const i4 = {
      ...u,
      ...(u2 = (c2 = l) == null ? void 0 : c2.editorConfig) == null ? void 0 : u2.languageUserDefined
    };
    return i4[e4.language] ? i4[e4.language] : u["zh-CN"];
  });
  provide("usedLanguageText", t3), provide(
    "previewTheme",
    computed(() => e4.previewTheme)
  ), provide(
    "customIcon",
    computed(() => e4.customIcon)
  );
};
var $t = (e4) => {
  ie(e4), provide("tabWidth", e4.tabWidth);
};
var ce = (e4) => {
  onMounted(() => {
    var a2, l2;
    if (!e4.noIconfont)
      if (l.iconfontType === "svg") {
        const t3 = document.createElement("script");
        t3.src = ((a2 = l.editorExtensions) == null ? void 0 : a2.iconfont) || r, t3.id = `${a}-icon`, h4(t3);
      } else {
        const t3 = document.createElement("link");
        t3.rel = "stylesheet", t3.href = ((l2 = l.editorExtensions) == null ? void 0 : l2.iconfontClass) || n, t3.id = `${a}-icon-class`, h4(t3);
      }
  });
};
var Ct = (e4) => {
  var c2, u2, s3, o2, d3, b4;
  const { noPrettier: a2, noUploadImg: l2 } = e4, { editorExtensions: t3 } = l, n3 = a2 || !!((u2 = (c2 = l.editorExtensions) == null ? void 0 : c2.prettier) != null && u2.prettierInstance), r4 = a2 || !!((o2 = (s3 = l.editorExtensions) == null ? void 0 : s3.prettier) != null && o2.parserMarkdownInstance), i4 = l2 || !!((b4 = (d3 = l.editorExtensions) == null ? void 0 : d3.cropper) != null && b4.instance);
  onMounted(() => {
    var w2, v2, k3, $2;
    const y2 = document.createElement("script"), m5 = document.createElement("script");
    y2.src = ((w2 = t3 == null ? void 0 : t3.prettier) == null ? void 0 : w2.standaloneJs) || d.main, y2.id = `${a}-prettier`, m5.src = ((v2 = t3 == null ? void 0 : t3.prettier) == null ? void 0 : v2.parserMarkdownJs) || d.markdown, m5.id = `${a}-prettierMD`;
    const h6 = document.createElement("link");
    h6.rel = "stylesheet", h6.href = ((k3 = t3 == null ? void 0 : t3.cropper) == null ? void 0 : k3.css) || h2.css, h6.id = `${a}-cropperCss`;
    const f3 = document.createElement("script");
    f3.src = (($2 = t3 == null ? void 0 : t3.cropper) == null ? void 0 : $2.js) || h2.js, f3.id = `${a}-cropper`, i4 || (h4(h6), h4(f3)), n3 || h4(y2), r4 || h4(m5);
  }), ce(e4);
};
var It = (e4, a2) => {
  const { editorId: l2 } = e4;
  onMounted(() => {
    C2.on(l2, {
      name: b2,
      callback: (t3) => {
        e4.onError instanceof Function ? e4.onError(t3) : a2.emit("onError", t3);
      }
    });
  });
};
var St = (e4, a2) => {
  const { editorId: l2 } = e4, t3 = reactive({
    pageFullscreen: e4.pageFullscreen,
    fullscreen: false,
    preview: e4.preview,
    htmlPreview: e4.preview ? false : e4.htmlPreview
  }), n3 = (c2, u2) => {
    t3[c2] = u2 === void 0 ? !t3[c2] : u2, c2 === "preview" && t3.preview ? t3.htmlPreview = false : c2 === "htmlPreview" && t3.htmlPreview && (t3.preview = false);
  };
  let r4 = "";
  const i4 = () => {
    t3.pageFullscreen || t3.fullscreen ? document.body.style.overflow = "hidden" : document.body.style.overflow = r4;
  };
  return watch(() => [t3.pageFullscreen, t3.fullscreen], i4), onMounted(() => {
    C2.on(l2, {
      name: H,
      callback(c2, u2) {
        const s3 = (o2) => {
          C2.emit(l2, G, "image", {
            desc: "",
            urls: o2
          }), u2 && u2();
        };
        e4.onUploadImg ? e4.onUploadImg(c2, s3) : a2.emit("onUploadImg", c2, s3);
      }
    }), r4 = document.body.style.overflow, i4();
  }), [t3, n3];
};
var Et = (e4) => {
  const { editorId: a2 } = e4, l2 = ref(false);
  return onMounted(() => {
    C2.on(a2, {
      name: g2,
      callback: (n3) => {
        n3 === void 0 ? l2.value = !l2.value : l2.value = n3;
      }
    });
  }), computed(() => !e4.toolbarsExclude.includes("catalog") && e4.toolbars.includes("catalog") && l2.value);
};
var Pt = (e4, a2, l2, t3, n3) => {
  const { editorId: r4 } = e4;
  watch(
    () => t3.pageFullscreen,
    (c2) => {
      C2.emit(r4, R, c2);
    }
  ), watch(
    () => t3.fullscreen,
    (c2) => {
      C2.emit(r4, _, c2);
    }
  ), watch(
    () => t3.preview,
    (c2) => {
      C2.emit(r4, d2, c2);
    }
  ), watch(
    () => t3.htmlPreview,
    (c2) => {
      C2.emit(r4, L2, c2);
    }
  ), watch(l2, (c2) => {
    C2.emit(r4, N, c2);
  });
  const i4 = {
    on(c2, u2) {
      switch (c2) {
        case "pageFullscreen": {
          C2.on(r4, {
            name: R,
            callback(s3) {
              u2(s3);
            }
          });
          break;
        }
        case "fullscreen": {
          C2.on(r4, {
            name: _,
            callback(s3) {
              u2(s3);
            }
          });
          break;
        }
        case "preview": {
          C2.on(r4, {
            name: d2,
            callback(s3) {
              u2(s3);
            }
          });
          break;
        }
        case "htmlPreview": {
          C2.on(r4, {
            name: L2,
            callback(s3) {
              u2(s3);
            }
          });
          break;
        }
        case "catalog": {
          C2.on(r4, {
            name: N,
            callback(s3) {
              u2(s3);
            }
          });
          break;
        }
      }
    },
    togglePageFullscreen(c2) {
      n3("pageFullscreen", c2);
    },
    toggleFullscreen(c2) {
      C2.emit(r4, A, c2);
    },
    togglePreview(c2) {
      n3("preview", c2);
    },
    toggleHtmlPreview(c2) {
      n3("htmlPreview", c2);
    },
    toggleCatalog(c2) {
      C2.emit(r4, g2, c2);
    },
    triggerSave() {
      C2.emit(r4, E);
    },
    insert(c2) {
      C2.emit(r4, G, "universal", { generate: c2 });
    },
    focus(c2) {
      C2.emit(r4, f2, c2);
    }
  };
  a2.expose(i4);
};
var it = (e4) => e4;
var se = {
  /**
   * markdown content.
   *
   * @default ''
   */
  modelValue: {
    type: String,
    default: ""
  },
  /**
   * 主题，支持light和dark
   *
   * @default 'light'
   */
  theme: {
    type: String,
    default: "light"
  },
  /**
   * 外层类名
   *
   * @default ''
   */
  class: {
    type: String,
    default: ""
  },
  /**
   * 预设语言名称
   *
   * @default 'zh-CN'
   */
  language: {
    type: String,
    default: "zh-CN"
  },
  /**
   * html变化事件
   */
  onHtmlChanged: {
    type: Function
  },
  /**
   * 获取目录结构
   */
  onGetCatalog: {
    type: Function
  },
  /**
   * 编辑器唯一标识
   *
   * @default 'md-editor-v3'
   */
  editorId: {
    type: String,
    default: o
  },
  /**
   * 预览中代码是否显示行号
   *
   * @default false
   */
  showCodeRowNumber: {
    type: Boolean,
    default: false
  },
  /**
   * 预览内容样式
   *
   * @default 'default'
   */
  previewTheme: {
    type: String,
    default: "default"
  },
  /**
   * 编辑器样式
   */
  style: {
    type: Object,
    default: () => ({})
  },
  /**
   * 标题的id生成方式
   *
   * @default (text: string) => text
   */
  mdHeadingId: {
    type: Function,
    default: it
  },
  /**
   *
   * 不能保证文本正确的情况，在marked编译md文本后通过该方法处理
   * 推荐DOMPurify、sanitize-html
   *
   * @default (text: string) => text
   */
  sanitize: {
    type: Function,
    default: (e4) => e4
  },
  /**
   * 不使用该mermaid
   *
   * @default false
   */
  noMermaid: {
    type: Boolean,
    default: false
  },
  /**
   * 不使用katex
   *
   * @default false
   */
  noKatex: {
    type: Boolean,
    default: false
  },
  /**
   * 代码主题
   *
   * @default 'atom'
   */
  codeTheme: {
    type: String,
    default: "atom"
  },
  /**
   * 不插入iconfont链接
   *
   * @default false
   */
  noIconfont: {
    type: Boolean
  },
  /**
   * 复制代码格式化方法
   *
   * @default (text) => text
   */
  formatCopiedText: {
    type: Function,
    default: (e4) => e4
  },
  /**
   * 某些预览主题的代码模块背景是暗色系
   * 将这个属性设置为true，会自动在该主题下的light模式下使用暗色系的代码风格
   *
   * @default true
   */
  codeStyleReverse: {
    type: Boolean,
    default: true
  },
  /**
   * 需要自动调整的预览主题
   *
   * @default ['default', 'mk-cute']
   */
  codeStyleReverseList: {
    type: Array,
    default: ["default", "mk-cute"]
  },
  noHighlight: {
    type: Boolean,
    default: false
  },
  /**
   * 是否关闭编辑器默认的放大缩小功能
   */
  noImgZoomIn: {
    type: Boolean,
    default: false
  },
  /**
   * 自定义的图标
   */
  customIcon: {
    type: Object,
    default: {}
  }
};
var Tt = {
  ...se,
  /**
   * input回调事件
   */
  onChange: {
    type: Function
  },
  /**
   * input回调事件
   */
  onSave: {
    type: Function
  },
  /**
   * 上传图片事件
   */
  onUploadImg: {
    type: Function
  },
  /**
   * 是否页面内全屏
   *
   * @default false
   */
  pageFullscreen: {
    type: Boolean,
    default: false
  },
  /**
   * 是否展开预览
   *
   * @default true
   */
  preview: {
    type: Boolean,
    default: true
  },
  /**
   * 是否展开html预览
   *
   * @default false
   */
  htmlPreview: {
    type: Boolean,
    default: false
  },
  /**
   * 仅预览模式，不显示toolbar和编辑框
   *
   * @4.0.0开始移除该设置，使用组件MdPreview替换
   *
   * @default false
   */
  // previewOnly: {
  //   type: Boolean as PropType<boolean>,
  //   default: false
  // },
  /**
   * 工具栏选择显示
   *
   * @default allToolbar
   */
  toolbars: {
    type: Array,
    default: m
  },
  /**
   * 工具栏选择不显示
   *
   * @default []
   */
  toolbarsExclude: {
    type: Array,
    default: []
  },
  /**
   * 格式化md
   *
   * @default true
   */
  noPrettier: {
    type: Boolean,
    default: false
  },
  /**
   * 一个tab等于空格数
   *
   * @default 2
   */
  tabWidth: {
    type: Number,
    default: 2
  },
  /**
   * 表格预设格子数
   *
   * @default [6, 4]
   */
  tableShape: {
    type: Array,
    default: () => [6, 4]
  },
  /**
   * 空提示
   *
   * @default ''
   */
  placeholder: {
    type: String,
    default: ""
  },
  /**
   * 自定义的工具栏列表
   */
  defToolbars: {
    type: [String, Object]
  },
  /**
   * 内部错误捕获
   */
  onError: {
    type: Function
  },
  /**
   * 页脚列表显示顺序
   */
  footers: {
    type: Array,
    default: p
  },
  /**
   * 是否默认激活输入框和预览框同步滚动
   *
   * @default true
   */
  scrollAuto: {
    type: Boolean,
    default: true
  },
  /**
   * 自定义的也叫工具组件列表
   */
  defFooters: {
    type: [String, Object]
  },
  /**
   * 是否禁用上传图片
   *
   * @default false
   */
  noUploadImg: {
    type: Boolean
  },
  /**
   * 文本区域自动获得焦点
   *
   * @default false
   */
  autoFocus: {
    type: Boolean
  },
  /**
   * 禁用文本区域
   *
   * @default false
   */
  disabled: {
    type: Boolean
  },
  /**
   * 文本区域为只读
   *
   * @default false
   */
  readOnly: {
    type: Boolean
  },
  /**
   * 文本区域允许的最大字符数
   */
  maxLength: {
    type: Number
  },
  /**
   * 是否启用自动识别粘贴代码类别
   * 目前支持 vscode 复制的代码识别
   *
   * @default false
   */
  autoDetectCode: {
    type: Boolean
  },
  /**
   * 输入框失去焦点时触发事件
   */
  onBlur: {
    type: Function
  },
  /**
   * 输入框获得焦点时触发事件
   */
  onFocus: {
    type: Function
  },
  /**
   * @codemirror/autocomplete匹配关键词的方法列表
   *
   * 它会被像下面这样嵌入编辑器
   *
   * import { autocompletion } from '@codemirror/autocomplete';
   * autocompletion({
   *   override: [...completions]
   * })
   */
  completions: {
    type: Array
  },
  /**
   * 是否在工具栏下面显示对应的文字名称
   *
   * @default false
   */
  showToolbarName: {
    type: Boolean,
    default: false
  },
  /**
   * 字符输入事件
   */
  onInput: {
    type: Function
  },
  onDrop: {
    type: Function
  },
  /**
   * 输入框的默认宽度
   *
   * @example '100px'/'50%'
   * @default '50%
   */
  inputBoxWitdh: {
    type: String,
    default: "50%"
  },
  /**
   * 输入框宽度变化事件
   */
  onInputBoxWitdhChange: {
    type: Function
  }
};
var ue = ["onHtmlChanged", "onGetCatalog"];
var _t = [
  ...ue,
  "onChange",
  "onSave",
  "onUploadImg",
  "onError",
  "update:modelValue",
  "onBlur",
  "onFocus",
  "onInput",
  "onDrop",
  "onInputBoxWitdhChange"
];
var ct = defineComponent({
  name: "MdPreview",
  props: se,
  emits: ue,
  setup(e4, a2) {
    const {
      editorId: l2,
      noKatex: t3,
      noMermaid: n3,
      noHighlight: r4
    } = e4;
    return ie(e4), ce(e4), onBeforeUnmount(() => {
      C2.clear(l2);
    }), () => createVNode("div", {
      id: l2,
      class: [a, e4.class, e4.theme === "dark" && `${a}-dark`, `${a}-previewOnly`],
      style: e4.style
    }, [createVNode(lt, {
      modelValue: e4.modelValue,
      onHtmlChanged: (i4) => {
        e4.onHtmlChanged ? e4.onHtmlChanged(i4) : a2.emit("onHtmlChanged", i4);
      },
      onGetCatalog: (i4) => {
        e4.onGetCatalog ? e4.onGetCatalog(i4) : a2.emit("onGetCatalog", i4);
      },
      mdHeadingId: e4.mdHeadingId,
      noMermaid: n3,
      sanitize: e4.sanitize,
      noKatex: t3,
      formatCopiedText: e4.formatCopiedText,
      noHighlight: r4,
      noImgZoomIn: e4.noImgZoomIn,
      previewOnly: true
    }, null)]);
  }
});
var N2 = ct;
N2.install = (e4) => (e4.component(N2.name, N2), e4);

// node_modules/md-editor-v3/lib/es/MdCatalog.mjs
var N3 = {
  tocItem: {
    type: Object,
    default: () => ({})
  },
  mdHeadingId: {
    type: Function,
    default: () => {
    }
  },
  scrollElement: {
    type: [String, Object],
    default: ""
  },
  onClick: {
    type: Function,
    default: () => {
    }
  },
  scrollElementOffsetTop: {
    type: Number,
    default: 0
  }
};
var C4 = defineComponent({
  props: N3,
  setup(l2) {
    return () => {
      const {
        tocItem: n3,
        mdHeadingId: d3,
        scrollElement: o2,
        onClick: m5,
        scrollElementOffsetTop: v2
      } = l2;
      return createVNode("div", {
        class: [`${a}-catalog-link`, n3.active && `${a}-catalog-active`],
        onClick: (s3) => {
          m5(s3, n3), s3.stopPropagation();
          const E2 = d3(n3.text, n3.level, n3.index), a2 = document.getElementById(E2), t3 = o2 instanceof Element ? o2 : document.querySelector(o2);
          if (a2 && t3) {
            let e4 = a2.offsetParent, c2 = a2.offsetTop;
            if (t3.contains(e4))
              for (; e4 && t3 != e4; )
                c2 += e4 == null ? void 0 : e4.offsetTop, e4 = e4 == null ? void 0 : e4.offsetParent;
            t3 == null || t3.scrollTo({
              top: c2 - v2,
              behavior: "smooth"
            });
          }
        }
      }, [createVNode("span", {
        title: n3.text
      }, [n3.text]), createVNode("div", {
        class: `${a}-catalog-wrapper`
      }, [n3.children && n3.children.map((s3) => createVNode(C4, {
        mdHeadingId: d3,
        key: `${n3.text}-link-${s3.level}-${s3.text}`,
        tocItem: s3,
        scrollElement: o2,
        onClick: m5,
        scrollElementOffsetTop: v2
      }, null))])]);
    };
  }
});
var M2 = C4;
var F4 = {
  /**
   * 编辑器的Id，务必与需要绑定的编辑器Id相同
   */
  editorId: {
    type: String
  },
  class: {
    type: String,
    default: ""
  },
  mdHeadingId: {
    type: Function,
    default: (l2) => l2
  },
  /**
   * 指定滚动的容器，选择器需带上对应的符号，默认预览框
   * 元素必须定位！！！！！！
   *
   * 默认：#md-editor-preview-wrapper
   */
  scrollElement: {
    type: [String, Object]
  },
  theme: {
    type: String,
    default: "light"
  },
  /**
   * 高亮标题相对滚动容器顶部偏移量，即距离该值时，高亮当前目录菜单项
   *
   * 默认：20px
   */
  offsetTop: {
    type: Number,
    default: 20
  },
  /**
   * 滚动区域的固定顶部高度
   *
   * 默认：0
   */
  scrollElementOffsetTop: {
    type: Number,
    default: 0
  },
  onClick: {
    type: Function
  },
  onActive: {
    type: Function
  }
};
var P2 = defineComponent({
  name: "MdCatalog",
  props: F4,
  emits: ["onClick", "onActive"],
  setup(l2, n3) {
    const d3 = l2.editorId, o2 = reactive({
      list: [],
      show: false,
      scrollElement: l2.scrollElement || `#${d3}-preview-wrapper`
    }), m5 = shallowRef(), v2 = computed(() => {
      const t3 = [];
      return o2.list.forEach((e4, c2) => {
        const {
          text: g4,
          level: h6
        } = e4, i4 = {
          level: h6,
          text: g4,
          index: c2 + 1,
          active: m5.value === e4
        };
        if (t3.length === 0)
          t3.push(i4);
        else {
          let r4 = t3[t3.length - 1];
          if (i4.level > r4.level)
            for (let f3 = r4.level + 1; f3 <= 6; f3++) {
              const {
                children: p3
              } = r4;
              if (!p3) {
                r4.children = [i4];
                break;
              }
              if (r4 = p3[p3.length - 1], i4.level <= r4.level) {
                p3.push(i4);
                break;
              }
            }
          else
            t3.push(i4);
        }
      }), t3;
    }), s3 = () => o2.scrollElement instanceof HTMLElement ? o2.scrollElement : document.querySelector(o2.scrollElement), E2 = (t3) => {
      if (t3.length === 0)
        return o2.list = [], false;
      const {
        activeHead: e4
      } = t3.reduce((c2, g4, h6) => {
        const i4 = document.getElementById(l2.mdHeadingId(g4.text, g4.level, h6 + 1));
        if (i4 instanceof HTMLElement) {
          const r4 = s3(), f3 = P(i4, r4);
          if (f3 < l2.offsetTop && f3 > c2.minTop)
            return {
              activeHead: g4,
              minTop: f3
            };
        }
        return c2;
      }, {
        activeHead: t3[0],
        minTop: Number.MIN_SAFE_INTEGER
      });
      m5.value = e4, o2.list = t3;
    }, a2 = () => {
      E2(o2.list);
    };
    return watch(() => m5.value, (t3) => {
      const e4 = t3 ? {
        ...t3
      } : void 0;
      l2.onActive ? l2.onActive(e4) : n3.emit("onActive", e4);
    }), onMounted(() => {
      const t3 = s3(), e4 = t3 === document.documentElement ? window : t3;
      e4 == null || e4.addEventListener("scroll", a2), C2.on(d3, {
        name: I2,
        callback: (c2) => {
          e4 == null || e4.removeEventListener("scroll", a2), E2(c2), e4 == null || e4.addEventListener("scroll", a2);
        }
      }), C2.emit(d3, D);
    }), onBeforeUnmount(() => {
      var e4;
      const t3 = s3();
      (e4 = t3 === document.documentElement ? window : t3) == null || e4.removeEventListener("scroll", a2);
    }), () => createVNode("div", {
      class: `${a}-catalog${l2.theme === "dark" ? "-dark" : ""} ${l2.class}`
    }, [v2.value.map((t3) => createVNode(M2, {
      mdHeadingId: l2.mdHeadingId,
      tocItem: t3,
      key: `link-${t3.level}-${t3.text}`,
      scrollElement: o2.scrollElement,
      onClick: (e4, c2) => {
        l2.onClick ? l2.onClick(e4, c2) : n3.emit("onClick", e4, c2);
      },
      scrollElementOffsetTop: l2.scrollElementOffsetTop
    }, null))]);
  }
});
var k2 = P2;
k2.install = (l2) => (l2.component(k2.name, k2), l2);

// node_modules/md-editor-v3/lib/es/NormalToolbar.mjs
var m3 = {
  title: {
    type: String,
    default: ""
  },
  // 展示在工具栏的内容，通常是个图标
  trigger: {
    type: [String, Object]
  },
  onClick: {
    type: Function
  },
  /**
   * ==没有意义，仅用于规避克隆组件自动嵌入insert方法时，传入的是该组件而产生的waring
   */
  insert: {
    type: Function
  },
  language: {
    type: String
  },
  theme: {
    type: String
  }
  /**
   * ==结束
   */
};
var e3 = defineComponent({
  name: "NormalToolbar",
  props: m3,
  emits: ["onClick"],
  setup(t3, n3) {
    return () => {
      const o2 = s({
        props: t3,
        ctx: n3
      }, "trigger");
      return createVNode("div", {
        class: `${a}-toolbar-item`,
        title: t3.title,
        onClick: (i4) => {
          t3.onClick instanceof Function ? t3.onClick(i4) : n3.emit("onClick", i4);
        }
      }, [o2]);
    };
  }
});
e3.install = (t3) => (t3.component(e3.name, e3), t3);

// node_modules/md-editor-v3/lib/es/ModalToolbar.mjs
function m4(t3) {
  return typeof t3 == "function" || Object.prototype.toString.call(t3) === "[object Object]" && !isVNode(t3);
}
var g3 = {
  title: {
    type: String,
    default: ""
  },
  modalTitle: {
    type: String,
    default: ""
  },
  visible: {
    type: Boolean
  },
  width: {
    type: String,
    default: "auto"
  },
  height: {
    type: String,
    default: "auto"
  },
  // 展示在工具栏的内容，通常是个图标
  trigger: {
    type: [String, Object]
  },
  onClick: {
    type: Function
  },
  onClose: {
    type: Function
  },
  /**
   * 显示全屏按钮
   */
  showAdjust: {
    type: Boolean,
    default: false
  },
  isFullscreen: {
    type: Boolean,
    default: false
  },
  onAdjust: {
    type: Function
  },
  /**
   * ==没有意义，仅用于规避克隆组件自动嵌入insert方法时，传入的是该组件而产生的waring
   */
  insert: {
    type: Function
  },
  language: {
    type: String
  },
  theme: {
    type: String
  }
  /**
   * ==结束
   */
};
var i3 = defineComponent({
  name: "ModalToolbar",
  props: g3,
  emits: ["onClick", "onClose", "onAdjust"],
  setup(t3, e4) {
    return () => {
      const u2 = s({
        props: t3,
        ctx: e4
      }, "trigger"), n3 = s({
        props: t3,
        ctx: e4
      }, "default");
      return createVNode(Fragment, null, [createVNode("div", {
        class: `${a}-toolbar-item`,
        title: t3.title,
        onClick: () => {
          t3.onClick instanceof Function ? t3.onClick() : e4.emit("onClick");
        }
      }, [u2]), createVNode(h5, {
        width: t3.width,
        height: t3.height,
        title: t3.modalTitle,
        visible: t3.visible,
        onClose: () => {
          t3.onClose instanceof Function ? t3.onClose() : e4.emit("onClose");
        },
        showAdjust: t3.showAdjust,
        isFullscreen: t3.isFullscreen,
        onAdjust: (l2) => {
          t3.onAdjust instanceof Function ? t3.onAdjust(l2) : e4.emit("onAdjust", l2);
        }
      }, m4(n3) ? n3 : {
        default: () => [n3]
      })]);
    };
  }
});
i3.install = (t3) => (t3.component(i3.name, i3), t3);

// node_modules/md-editor-v3/lib/es/MdEditor.mjs
var import_copy_to_clipboard2 = __toESM(require_copy_to_clipboard(), 1);
var import_markdown_it2 = __toESM(require_markdown_it(), 1);
var import_markdown_it_task_lists2 = __toESM(require_markdown_it_task_lists(), 1);
var Ft = Object.defineProperty;
var Rt = (e4, o2, l2) => o2 in e4 ? Ft(e4, o2, { enumerable: true, configurable: true, writable: true, value: l2 }) : e4[o2] = l2;
var q = (e4, o2, l2) => (Rt(e4, typeof o2 != "symbol" ? o2 + "" : o2, l2), l2);
var Al = defineComponent({
  setup() {
    return () => createVNode("div", {
      class: `${a}-divider`
    }, null);
  }
});
var Ml = {
  noPrettier: {
    type: Boolean
  },
  // 工具栏选择显示
  toolbars: {
    type: Array,
    default: () => []
  },
  // 工具栏选择不显示
  toolbarsExclude: {
    type: Array,
    default: () => []
  },
  setting: {
    type: Object,
    default: () => ({})
  },
  screenfull: {
    type: Object,
    default: null
  },
  screenfullJs: {
    type: String,
    default: ""
  },
  updateSetting: {
    type: Function,
    default: () => {
    }
  },
  tableShape: {
    type: Array,
    default: () => [6, 4]
  },
  defToolbars: {
    type: Object
  },
  noUploadImg: {
    type: Boolean
  },
  /**
   * 是否在工具栏下面显示对应的文字名称
   *
   * @default false
   */
  showToolbarName: {
    type: Boolean
  }
};
var Ll = (e4) => {
  var u2, s3, h6, w2;
  const o2 = inject("editorId");
  let l2 = (s3 = (u2 = l.editorExtensions) == null ? void 0 : u2.screenfull) == null ? void 0 : s3.instance;
  const a2 = (w2 = (h6 = l.editorExtensions) == null ? void 0 : h6.screenfull) == null ? void 0 : w2.js, i4 = ref(false), r4 = (C5) => {
    if (!l2) {
      C2.emit(o2, b2, {
        name: "fullscreen",
        message: "fullscreen is undefined"
      });
      return;
    }
    l2.isEnabled ? (i4.value = true, (C5 === void 0 ? !l2.isFullscreen : C5) ? l2.request() : l2.exit()) : console.error("browser does not support screenfull!");
  }, m5 = () => {
    l2 && l2.isEnabled && l2.on("change", () => {
      (i4.value || e4.setting.fullscreen) && (i4.value = false, e4.updateSetting("fullscreen"));
    });
  }, g4 = () => {
    l2 = window.screenfull, m5();
  };
  return onMounted(() => {
    if (m5(), !l2) {
      const C5 = document.createElement("script");
      C5.src = a2 || g, C5.onload = g4, C5.id = `${a}-screenfull`, h4(C5, "screenfull");
    }
  }), onMounted(() => {
    C2.on(o2, {
      name: A,
      callback: r4
    });
  }), { fullscreenHandler: r4 };
};
var Il = {
  tableShape: {
    type: Array,
    default: () => [6, 4]
  },
  onSelected: {
    type: Function,
    default: () => {
    }
  }
};
var Dl = defineComponent({
  name: "TableShape",
  props: Il,
  setup(e4) {
    const o2 = reactive({
      x: -1,
      y: -1
    });
    return () => createVNode("div", {
      class: `${a}-table-shape`,
      onMouseleave: () => {
        o2.x = -1, o2.y = -1;
      }
    }, [new Array(e4.tableShape[1]).fill("").map((l2, a2) => createVNode("div", {
      class: `${a}-table-shape-row`,
      key: `table-shape-row-${a2}`
    }, [new Array(e4.tableShape[0]).fill("").map((i4, r4) => createVNode("div", {
      class: `${a}-table-shape-col`,
      key: `table-shape-col-${r4}`,
      onMouseenter: () => {
        o2.x = a2, o2.y = r4;
      },
      onClick: () => {
        e4.onSelected(o2);
      }
    }, [createVNode("div", {
      class: [`${a}-table-shape-col-default`, a2 <= o2.x && r4 <= o2.y && `${a}-table-shape-col-include`]
    }, null)]))]))]);
  }
});
var El = Dl;
var Hl = {
  type: {
    type: String,
    default: "link"
  },
  visible: {
    type: Boolean,
    default: false
  },
  onCancel: {
    type: Function,
    default: () => {
    }
  },
  onOk: {
    type: Function,
    default: () => {
    }
  }
};
var Nl = defineComponent({
  props: Hl,
  setup(e4) {
    const o2 = inject("usedLanguageText"), l2 = inject("editorId"), a2 = computed(() => {
      var r4, m5;
      switch (e4.type) {
        case "link":
          return (r4 = o2.value.linkModalTips) == null ? void 0 : r4.linkTitle;
        case "image":
          return (m5 = o2.value.linkModalTips) == null ? void 0 : m5.imageTitle;
        default:
          return "";
      }
    }), i4 = reactive({
      desc: "",
      url: ""
    });
    return watch(() => e4.visible, (r4) => {
      r4 || setTimeout(() => {
        i4.desc = "", i4.url = "";
      }, 200);
    }), () => createVNode(h5, {
      title: a2.value,
      visible: e4.visible,
      onClose: e4.onCancel
    }, {
      default: () => {
        var r4, m5, g4, u2, s3;
        return [createVNode("div", {
          class: `${a}-form-item`
        }, [createVNode("label", {
          class: `${a}-label`,
          for: `link-desc-${l2}`
        }, [(r4 = o2.value.linkModalTips) == null ? void 0 : r4.descLabel]), createVNode("input", {
          placeholder: (m5 = o2.value.linkModalTips) == null ? void 0 : m5.descLabelPlaceHolder,
          class: `${a}-input`,
          id: `link-desc-${l2}`,
          type: "text",
          value: i4.desc,
          onChange: (h6) => {
            i4.desc = h6.target.value;
          },
          autocomplete: "off"
        }, null)]), createVNode("div", {
          class: `${a}-form-item`
        }, [createVNode("label", {
          class: `${a}-label`,
          for: `link-url-${l2}`
        }, [(g4 = o2.value.linkModalTips) == null ? void 0 : g4.urlLabel]), createVNode("input", {
          placeholder: (u2 = o2.value.linkModalTips) == null ? void 0 : u2.urlLabelPlaceHolder,
          class: `${a}-input`,
          id: `link-url-${l2}`,
          type: "text",
          value: i4.url,
          onChange: (h6) => {
            i4.url = h6.target.value;
          },
          autocomplete: "off"
        }, null)]), createVNode("div", {
          class: `${a}-form-item`
        }, [createVNode("button", {
          class: [`${a}-btn`, `${a}-btn-row`],
          type: "button",
          onClick: () => {
            e4.onOk(i4), i4.desc = "", i4.url = "";
          }
        }, [(s3 = o2.value.linkModalTips) == null ? void 0 : s3.buttonOK])])];
      }
    });
  }
});
var Bl = {
  visible: {
    type: Boolean,
    default: false
  },
  onCancel: {
    type: Function,
    default: () => {
    }
  },
  onOk: {
    type: Function,
    default: () => {
    }
  }
};
var Ol = defineComponent({
  props: Bl,
  setup(e4) {
    var h6, w2, C5;
    const o2 = inject("usedLanguageText"), l2 = inject("editorId");
    let a2 = (C5 = (w2 = (h6 = l) == null ? void 0 : h6.editorExtensions) == null ? void 0 : w2.cropper) == null ? void 0 : C5.instance;
    const i4 = ref(), r4 = ref(), m5 = ref(), g4 = reactive({
      cropperInited: false,
      imgSelected: false,
      imgSrc: "",
      // 是否全屏
      isFullscreen: false
    });
    let u2 = null;
    watch(() => e4.visible, () => {
      e4.visible && !g4.cropperInited && (a2 = a2 || window.Cropper, i4.value.onchange = () => {
        if (!a2) {
          C2.emit(l2, b2, {
            name: "Cropper",
            message: "Cropper is undefined"
          });
          return;
        }
        const d3 = i4.value.files || [];
        if (g4.imgSelected = true, (d3 == null ? void 0 : d3.length) > 0) {
          const k3 = new FileReader();
          k3.onload = (f3) => {
            g4.imgSrc = f3.target.result, nextTick(() => {
              u2 = new a2(r4.value, {
                viewMode: 2,
                preview: `.${a}-clip-preview-target`
                // aspectRatio: 16 / 9,
              });
            });
          }, k3.readAsDataURL(d3[0]);
        }
      });
    }), watch(() => [g4.imgSelected], () => {
      m5.value.style = "";
    }), watch(() => g4.isFullscreen, () => {
      nextTick(() => {
        u2 == null || u2.destroy(), m5.value.style = "", r4.value && (u2 = new a2(r4.value, {
          viewMode: 2,
          preview: `.${a}-clip-preview-target`
          // aspectRatio: 16 / 9,
        }));
      });
    });
    const s3 = () => {
      u2.clear(), u2.destroy(), u2 = null, i4.value.value = "", g4.imgSelected = false;
    };
    return () => {
      var d3;
      return createVNode(h5, {
        class: `${a}-modal-clip`,
        title: (d3 = o2.value.clipModalTips) == null ? void 0 : d3.title,
        visible: e4.visible,
        onClose: e4.onCancel,
        showAdjust: true,
        isFullscreen: g4.isFullscreen,
        onAdjust: (k3) => {
          g4.isFullscreen = k3;
        },
        width: "668px",
        height: "421px"
      }, {
        default: () => {
          var k3, f3;
          return [createVNode("div", {
            class: `${a}-form-item ${a}-clip`
          }, [createVNode("div", {
            class: `${a}-clip-main`
          }, [g4.imgSelected ? createVNode("div", {
            class: `${a}-clip-cropper`
          }, [createVNode("img", {
            src: g4.imgSrc,
            ref: r4,
            style: {
              display: "none"
            },
            alt: ""
          }, null), createVNode("div", {
            class: `${a}-clip-delete`,
            onClick: s3
          }, [createVNode(C3, {
            name: "delete"
          }, null)])]) : createVNode("div", {
            class: `${a}-clip-upload`,
            onClick: () => {
              i4.value.click();
            }
          }, [createVNode(C3, {
            name: "upload"
          }, null)])]), createVNode("div", {
            class: `${a}-clip-preview`
          }, [createVNode("div", {
            class: `${a}-clip-preview-target`,
            ref: m5
          }, null)])]), createVNode("div", {
            class: `${a}-form-item`
          }, [createVNode("button", {
            class: `${a}-btn`,
            type: "button",
            onClick: () => {
              if (u2) {
                const b4 = u2.getCroppedCanvas();
                C2.emit(l2, H, [O(b4.toDataURL("image/png"))], e4.onOk), s3();
              }
            }
          }, [((k3 = o2.value.clipModalTips) == null ? void 0 : k3.buttonUpload) || ((f3 = o2.value.linkModalTips) == null ? void 0 : f3.buttonOK)])]), createVNode("input", {
            ref: i4,
            accept: "image/*",
            type: "file",
            multiple: false,
            style: {
              display: "none"
            }
          }, null)];
        }
      });
    };
  }
});
var Vl = {
  type: {
    type: String,
    default: "link"
  },
  linkVisible: {
    type: Boolean,
    default: false
  },
  clipVisible: {
    type: Boolean,
    default: false
  },
  onCancel: {
    type: Function,
    default: () => {
    }
  },
  onOk: {
    type: Function,
    default: () => {
    }
  }
};
var Fl = defineComponent({
  props: Vl,
  setup(e4) {
    return () => createVNode(Fragment, null, [createVNode(Nl, {
      type: e4.type,
      visible: e4.linkVisible,
      onOk: e4.onOk,
      onCancel: e4.onCancel
    }, null), createVNode(Ol, {
      visible: e4.clipVisible,
      onOk: e4.onOk,
      onCancel: e4.onCancel
    }, null)]);
  }
});
var Rl = defineComponent({
  name: "MDEditorToolbar",
  props: Ml,
  setup(e4) {
    const o2 = inject("editorId"), l2 = inject("usedLanguageText"), a2 = inject("theme"), i4 = inject("language"), {
      fullscreenHandler: r4
    } = Ll(e4), m5 = `${o2}-toolbar-wrapper`, g4 = ref(), u2 = reactive({
      title: false,
      catalog: false,
      // 图片上传下拉
      image: false,
      // 表格预选
      table: false,
      // mermaid
      mermaid: false,
      katex: false
    }), s3 = (b4, $2) => {
      C2.emit(o2, G, b4, $2);
    }, h6 = reactive({
      type: "link",
      linkVisible: false,
      clipVisible: false
    }), w2 = ref();
    onMounted(() => {
      C2.on(o2, {
        name: T,
        callback(b4) {
          h6.type = b4, h6.linkVisible = true;
        }
      });
    });
    const C5 = computed(() => {
      const b4 = e4.toolbars.filter((I3) => !e4.toolbarsExclude.includes(I3)), $2 = b4.indexOf("="), T3 = $2 === -1 ? b4 : b4.slice(0, $2 + 1), S2 = $2 === -1 ? [] : b4.slice($2, Number.MAX_SAFE_INTEGER);
      return [T3, S2];
    }), d3 = ref(), k3 = () => {
      C2.emit(o2, H, Array.from(d3.value.files || [])), d3.value.value = "";
    };
    onMounted(() => {
      d3.value.addEventListener("change", k3);
    });
    const f3 = (b4) => {
      var $2, T3, S2, I3, D2, oe, ae, M3, L4, _2, W, O2, N4, B2, V, K, j2, de, ne, J, Z, ie2, X, F5, R2, re, me, Ae, Me2, Le2, Ie, De2, Ee, He, Ne2, Be2, Oe2, Ve2, Fe2, Re2, Pe, We2, Ue2, _e2, qe2, ze2, Ge2, Ke2, je2, Ze2, Xe2, Ye2, Je2, Qe2, et2, tt2, lt2, ot2, at2, nt2, it2, rt2, st, ct2, ut, dt, mt;
      if (m.includes(b4))
        switch (b4) {
          case "-":
            return createVNode(Al, null, null);
          case "bold":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: ($2 = l2.value.toolbarTips) == null ? void 0 : $2.bold,
              onClick: () => {
                s3("bold");
              }
            }, [createVNode(C3, {
              name: "bold"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(T3 = l2.value.toolbarTips) == null ? void 0 : T3.bold])]);
          case "underline":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (S2 = l2.value.toolbarTips) == null ? void 0 : S2.underline,
              onClick: () => {
                s3("underline");
              }
            }, [createVNode(C3, {
              name: "underline"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(I3 = l2.value.toolbarTips) == null ? void 0 : I3.underline])]);
          case "italic":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (D2 = l2.value.toolbarTips) == null ? void 0 : D2.italic,
              onClick: () => {
                s3("italic");
              }
            }, [createVNode(C3, {
              name: "italic"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(oe = l2.value.toolbarTips) == null ? void 0 : oe.italic])]);
          case "strikeThrough":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (ae = l2.value.toolbarTips) == null ? void 0 : ae.strikeThrough,
              onClick: () => {
                s3("strikeThrough");
              }
            }, [createVNode(C3, {
              name: "strike-through"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(M3 = l2.value.toolbarTips) == null ? void 0 : M3.strikeThrough])]);
          case "title":
            return createVNode(F2, {
              relative: `#${m5}`,
              visible: u2.title,
              onChange: (p3) => {
                u2.title = p3;
              },
              overlay: createVNode("ul", {
                class: `${a}-menu`,
                onClick: () => {
                  u2.title = false;
                }
              }, [createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-title`,
                onClick: () => {
                  s3("h1");
                }
              }, [(L4 = l2.value.titleItem) == null ? void 0 : L4.h1]), createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-title`,
                onClick: () => {
                  s3("h2");
                }
              }, [(_2 = l2.value.titleItem) == null ? void 0 : _2.h2]), createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-title`,
                onClick: () => {
                  s3("h3");
                }
              }, [(W = l2.value.titleItem) == null ? void 0 : W.h3]), createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-title`,
                onClick: () => {
                  s3("h4");
                }
              }, [(O2 = l2.value.titleItem) == null ? void 0 : O2.h4]), createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-title`,
                onClick: () => {
                  s3("h5");
                }
              }, [(N4 = l2.value.titleItem) == null ? void 0 : N4.h5]), createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-title`,
                onClick: () => {
                  s3("h6");
                }
              }, [(B2 = l2.value.titleItem) == null ? void 0 : B2.h6])])
            }, {
              default: () => {
                var p3, E2;
                return [createVNode("div", {
                  class: `${a}-toolbar-item`,
                  title: (p3 = l2.value.toolbarTips) == null ? void 0 : p3.title
                }, [createVNode(C3, {
                  name: "title"
                }, null), e4.showToolbarName && createVNode("div", {
                  class: `${a}-toolbar-item-name`
                }, [(E2 = l2.value.toolbarTips) == null ? void 0 : E2.title])])];
              }
            });
          case "sub":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (V = l2.value.toolbarTips) == null ? void 0 : V.sub,
              onClick: () => {
                s3("sub");
              }
            }, [createVNode(C3, {
              name: "sub"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(K = l2.value.toolbarTips) == null ? void 0 : K.sub])]);
          case "sup":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (j2 = l2.value.toolbarTips) == null ? void 0 : j2.sup,
              onClick: () => {
                s3("sup");
              }
            }, [createVNode(C3, {
              name: "sup"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(de = l2.value.toolbarTips) == null ? void 0 : de.sup])]);
          case "quote":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (ne = l2.value.toolbarTips) == null ? void 0 : ne.quote,
              onClick: () => {
                s3("quote");
              }
            }, [createVNode(C3, {
              name: "quote"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(J = l2.value.toolbarTips) == null ? void 0 : J.quote])]);
          case "unorderedList":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (Z = l2.value.toolbarTips) == null ? void 0 : Z.unorderedList,
              onClick: () => {
                s3("unorderedList");
              }
            }, [createVNode(C3, {
              name: "unordered-list"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(ie2 = l2.value.toolbarTips) == null ? void 0 : ie2.unorderedList])]);
          case "orderedList":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (X = l2.value.toolbarTips) == null ? void 0 : X.orderedList,
              onClick: () => {
                s3("orderedList");
              }
            }, [createVNode(C3, {
              name: "ordered-list"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(F5 = l2.value.toolbarTips) == null ? void 0 : F5.orderedList])]);
          case "task":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (R2 = l2.value.toolbarTips) == null ? void 0 : R2.task,
              onClick: () => {
                s3("task");
              }
            }, [createVNode(C3, {
              name: "task"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(re = l2.value.toolbarTips) == null ? void 0 : re.task])]);
          case "codeRow":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (me = l2.value.toolbarTips) == null ? void 0 : me.codeRow,
              onClick: () => {
                s3("codeRow");
              }
            }, [createVNode(C3, {
              name: "code-row"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(Ae = l2.value.toolbarTips) == null ? void 0 : Ae.codeRow])]);
          case "code":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (Me2 = l2.value.toolbarTips) == null ? void 0 : Me2.code,
              onClick: () => {
                s3("code");
              }
            }, [createVNode(C3, {
              name: "code"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(Le2 = l2.value.toolbarTips) == null ? void 0 : Le2.code])]);
          case "link":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (Ie = l2.value.toolbarTips) == null ? void 0 : Ie.link,
              onClick: () => {
                h6.type = "link", h6.linkVisible = true;
              }
            }, [createVNode(C3, {
              name: "link"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(De2 = l2.value.toolbarTips) == null ? void 0 : De2.link])]);
          case "image":
            return e4.noUploadImg ? createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (Ee = l2.value.toolbarTips) == null ? void 0 : Ee.image,
              onClick: () => {
                h6.type = "image", h6.linkVisible = true;
              }
            }, [createVNode(C3, {
              name: "image"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(He = l2.value.toolbarTips) == null ? void 0 : He.image])]) : createVNode(F2, {
              relative: `#${m5}`,
              visible: u2.image,
              onChange: (p3) => {
                u2.image = p3;
              },
              overlay: createVNode("ul", {
                class: `${a}-menu`,
                onClick: () => {
                  u2.title = false;
                }
              }, [createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-image`,
                onClick: () => {
                  h6.type = "image", h6.linkVisible = true;
                }
              }, [(Ne2 = l2.value.imgTitleItem) == null ? void 0 : Ne2.link]), createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-image`,
                onClick: () => {
                  d3.value.click();
                }
              }, [(Be2 = l2.value.imgTitleItem) == null ? void 0 : Be2.upload]), createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-image`,
                onClick: () => {
                  h6.clipVisible = true;
                }
              }, [(Oe2 = l2.value.imgTitleItem) == null ? void 0 : Oe2.clip2upload])])
            }, {
              default: () => {
                var p3, E2;
                return [createVNode("div", {
                  class: `${a}-toolbar-item`,
                  title: (p3 = l2.value.toolbarTips) == null ? void 0 : p3.image
                }, [createVNode(C3, {
                  name: "image"
                }, null), e4.showToolbarName && createVNode("div", {
                  class: `${a}-toolbar-item-name`
                }, [(E2 = l2.value.toolbarTips) == null ? void 0 : E2.image])])];
              }
            });
          case "table":
            return createVNode(F2, {
              relative: `#${m5}`,
              visible: u2.table,
              onChange: (p3) => {
                u2.table = p3;
              },
              key: "bar-table",
              overlay: createVNode(El, {
                tableShape: e4.tableShape,
                onSelected: (p3) => {
                  s3("table", {
                    selectedShape: p3
                  });
                }
              }, null)
            }, {
              default: () => {
                var p3, E2;
                return [createVNode("div", {
                  class: `${a}-toolbar-item`,
                  title: (p3 = l2.value.toolbarTips) == null ? void 0 : p3.table
                }, [createVNode(C3, {
                  name: "table"
                }, null), e4.showToolbarName && createVNode("div", {
                  class: `${a}-toolbar-item-name`
                }, [(E2 = l2.value.toolbarTips) == null ? void 0 : E2.table])])];
              }
            });
          case "revoke":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (Ve2 = l2.value.toolbarTips) == null ? void 0 : Ve2.revoke,
              onClick: () => {
                C2.emit(o2, F3);
              }
            }, [createVNode(C3, {
              name: "revoke"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(Fe2 = l2.value.toolbarTips) == null ? void 0 : Fe2.revoke])]);
          case "next":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (Re2 = l2.value.toolbarTips) == null ? void 0 : Re2.next,
              onClick: () => {
                C2.emit(o2, m2);
              }
            }, [createVNode(C3, {
              name: "next"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(Pe = l2.value.toolbarTips) == null ? void 0 : Pe.next])]);
          case "save":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (We2 = l2.value.toolbarTips) == null ? void 0 : We2.save,
              onClick: () => {
                C2.emit(o2, E);
              }
            }, [createVNode(C3, {
              name: "baocun"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(Ue2 = l2.value.toolbarTips) == null ? void 0 : Ue2.save])]);
          case "prettier":
            return e4.noPrettier ? "" : createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (_e2 = l2.value.toolbarTips) == null ? void 0 : _e2.prettier,
              onClick: () => {
                s3("prettier");
              }
            }, [createVNode(C3, {
              name: "prettier"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(qe2 = l2.value.toolbarTips) == null ? void 0 : qe2.prettier])]);
          case "pageFullscreen":
            return !e4.setting.fullscreen && createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (ze2 = l2.value.toolbarTips) == null ? void 0 : ze2.pageFullscreen,
              onClick: () => {
                e4.updateSetting("pageFullscreen");
              }
            }, [createVNode(C3, {
              name: e4.setting.pageFullscreen ? "suoxiao" : "fangda"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(Ge2 = l2.value.toolbarTips) == null ? void 0 : Ge2.pageFullscreen])]);
          case "fullscreen":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (Ke2 = l2.value.toolbarTips) == null ? void 0 : Ke2.fullscreen,
              onClick: () => {
                r4();
              }
            }, [createVNode(C3, {
              name: e4.setting.fullscreen ? "fullscreen-exit" : "fullscreen"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(je2 = l2.value.toolbarTips) == null ? void 0 : je2.fullscreen])]);
          case "preview":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (Ze2 = l2.value.toolbarTips) == null ? void 0 : Ze2.preview,
              onClick: () => {
                e4.updateSetting("preview");
              }
            }, [createVNode(C3, {
              name: "preview"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(Xe2 = l2.value.toolbarTips) == null ? void 0 : Xe2.preview])]);
          case "htmlPreview":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (Ye2 = l2.value.toolbarTips) == null ? void 0 : Ye2.htmlPreview,
              onClick: () => {
                e4.updateSetting("htmlPreview");
              }
            }, [createVNode(C3, {
              name: "coding"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(Je2 = l2.value.toolbarTips) == null ? void 0 : Je2.htmlPreview])]);
          case "catalog":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (Qe2 = l2.value.toolbarTips) == null ? void 0 : Qe2.catalog,
              onClick: () => {
                C2.emit(o2, g2);
              },
              key: "bar-catalog"
            }, [createVNode(C3, {
              name: "catalog"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(et2 = l2.value.toolbarTips) == null ? void 0 : et2.catalog])]);
          case "github":
            return createVNode("div", {
              class: `${a}-toolbar-item`,
              title: (tt2 = l2.value.toolbarTips) == null ? void 0 : tt2.github,
              onClick: () => C("https://github.com/imzbf/md-editor-v3")
            }, [createVNode(C3, {
              name: "github"
            }, null), e4.showToolbarName && createVNode("div", {
              class: `${a}-toolbar-item-name`
            }, [(lt2 = l2.value.toolbarTips) == null ? void 0 : lt2.github])]);
          case "mermaid":
            return createVNode(F2, {
              relative: `#${m5}`,
              visible: u2.mermaid,
              onChange: (p3) => {
                u2.mermaid = p3;
              },
              overlay: createVNode("ul", {
                class: `${a}-menu`,
                onClick: () => {
                  u2.mermaid = false;
                }
              }, [createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-mermaid`,
                onClick: () => {
                  s3("flow");
                }
              }, [(ot2 = l2.value.mermaid) == null ? void 0 : ot2.flow]), createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-mermaid`,
                onClick: () => {
                  s3("sequence");
                }
              }, [(at2 = l2.value.mermaid) == null ? void 0 : at2.sequence]), createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-mermaid`,
                onClick: () => {
                  s3("gantt");
                }
              }, [(nt2 = l2.value.mermaid) == null ? void 0 : nt2.gantt]), createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-mermaid`,
                onClick: () => {
                  s3("class");
                }
              }, [(it2 = l2.value.mermaid) == null ? void 0 : it2.class]), createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-mermaid`,
                onClick: () => {
                  s3("state");
                }
              }, [(rt2 = l2.value.mermaid) == null ? void 0 : rt2.state]), createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-mermaid`,
                onClick: () => {
                  s3("pie");
                }
              }, [(st = l2.value.mermaid) == null ? void 0 : st.pie]), createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-mermaid`,
                onClick: () => {
                  s3("relationship");
                }
              }, [(ct2 = l2.value.mermaid) == null ? void 0 : ct2.relationship]), createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-mermaid`,
                onClick: () => {
                  s3("journey");
                }
              }, [(ut = l2.value.mermaid) == null ? void 0 : ut.journey])]),
              key: "bar-mermaid"
            }, {
              default: () => {
                var p3, E2;
                return [createVNode("div", {
                  class: `${a}-toolbar-item`,
                  title: (p3 = l2.value.toolbarTips) == null ? void 0 : p3.mermaid
                }, [createVNode(C3, {
                  name: "mermaid"
                }, null), e4.showToolbarName && createVNode("div", {
                  class: `${a}-toolbar-item-name`
                }, [(E2 = l2.value.toolbarTips) == null ? void 0 : E2.mermaid])])];
              }
            });
          case "katex":
            return createVNode(F2, {
              relative: `#${m5}`,
              visible: u2.katex,
              onChange: (p3) => {
                u2.katex = p3;
              },
              overlay: createVNode("ul", {
                class: `${a}-menu`,
                onClick: () => {
                  u2.katex = false;
                }
              }, [createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-katex`,
                onClick: () => {
                  s3("katexInline");
                }
              }, [(dt = l2.value.katex) == null ? void 0 : dt.inline]), createVNode("li", {
                class: `${a}-menu-item ${a}-menu-item-katex`,
                onClick: () => {
                  s3("katexBlock");
                }
              }, [(mt = l2.value.katex) == null ? void 0 : mt.block])]),
              key: "bar-katex"
            }, {
              default: () => {
                var p3, E2;
                return [createVNode("div", {
                  class: `${a}-toolbar-item`,
                  title: (p3 = l2.value.toolbarTips) == null ? void 0 : p3.katex
                }, [createVNode(C3, {
                  name: "formula"
                }, null), e4.showToolbarName && createVNode("div", {
                  class: `${a}-toolbar-item-name`
                }, [(E2 = l2.value.toolbarTips) == null ? void 0 : E2.katex])])];
              }
            });
        }
      else if (e4.defToolbars instanceof Array) {
        const p3 = e4.defToolbars[b4];
        return p3 ? cloneVNode(p3, {
          theme: a2.value,
          language: i4.value,
          insert(ke) {
            C2.emit(o2, G, "universal", {
              generate: ke
            });
          }
        }) : "";
      } else if (e4.defToolbars && e4.defToolbars.children instanceof Array) {
        const p3 = e4.defToolbars.children[b4];
        return p3 ? cloneVNode(p3, {
          theme: a2.value,
          language: i4.value,
          insert(ke) {
            C2.emit(o2, G, "universal", {
              generate: ke
            });
          }
        }) : "";
      } else
        return "";
    };
    return watch(() => e4.toolbars, () => {
      nextTick(() => {
        g4.value && $(g4.value);
      });
    }, {
      immediate: true
    }), () => {
      const b4 = C5.value[0].map((T3) => f3(T3)), $2 = C5.value[1].map((T3) => f3(T3));
      return createVNode(Fragment, null, [e4.toolbars.length > 0 && createVNode("div", {
        class: `${a}-toolbar-wrapper`,
        ref: g4,
        id: m5
      }, [createVNode("div", {
        class: [`${a}-toolbar`, e4.showToolbarName && `${a}-stn`]
      }, [createVNode("div", {
        class: `${a}-toolbar-left`,
        ref: w2
      }, [b4]), createVNode("div", {
        class: `${a}-toolbar-right`
      }, [$2])])]), createVNode("input", {
        ref: d3,
        accept: "image/*",
        type: "file",
        multiple: true,
        style: {
          display: "none"
        }
      }, null), createVNode(Fl, {
        linkVisible: h6.linkVisible,
        clipVisible: h6.clipVisible,
        type: h6.type,
        onCancel: () => {
          h6.linkVisible = false, h6.clipVisible = false;
        },
        onOk: (T3) => {
          T3 && s3(h6.type, {
            desc: T3.desc,
            url: T3.url
          }), h6.linkVisible = false, h6.clipVisible = false;
        }
      }, null)]);
    };
  }
});
var Pl = (e4, o2) => {
  const l2 = x(() => {
    e4.removeEventListener("scroll", a2), e4.addEventListener("scroll", a2), o2.removeEventListener("scroll", a2), o2.addEventListener("scroll", a2);
  }, 50), a2 = (i4) => {
    const r4 = e4.clientHeight, m5 = o2.clientHeight, g4 = e4.scrollHeight, u2 = o2.scrollHeight, s3 = (g4 - r4) / (u2 - m5);
    i4.target === e4 ? (o2.removeEventListener("scroll", a2), o2.scrollTo({
      top: e4.scrollTop / s3
      // behavior: 'smooth'
    }), l2()) : (e4.removeEventListener("scroll", a2), e4.scrollTo({
      top: o2.scrollTop * s3
      // behavior: 'smooth'
    }), l2());
  };
  return [
    () => {
      l2().finally(() => {
        e4.dispatchEvent(new Event("scroll"));
      });
    },
    () => {
      e4.removeEventListener("scroll", a2), o2.removeEventListener("scroll", a2);
    }
  ];
};
var Wl = (e4, o2, l2) => {
  const { view: a2 } = l2, i4 = M(), r4 = (C5) => a2.lineBlockAt(a2.state.doc.line(C5).from).top, m5 = (C5) => a2.lineBlockAt(a2.state.doc.line(C5).from).height;
  let g4 = [];
  const u2 = () => {
    g4 = [];
    const C5 = Array.from(o2.querySelectorAll("[data-line]")).map(
      (b4) => Number(b4.dataset.line) + 1
    ), { lines: d3 } = a2.state.doc;
    let k3 = 1, f3 = C5.shift() ?? d3;
    for (let b4 = 1; b4 <= d3; b4++)
      b4 === f3 && (k3 = b4, f3 = C5.shift() || d3 + 1), g4.push({
        start: k3,
        end: f3 - 1
      });
  };
  let s3 = 0, h6 = 0;
  const w2 = F((C5) => {
    var $2, T3, S2, I3, D2, oe, ae;
    if (!(($2 = o2.firstElementChild) != null && $2.firstElementChild))
      return;
    const d3 = a2.lineBlockAtHeight(a2.scrollDOM.scrollTop), { number: k3 } = a2.state.doc.lineAt(d3.from);
    if (k3 > g4.length || a2.state.doc.lines < g4[g4.length - 1].end)
      return;
    let f3 = +getComputedStyle(o2).paddingTop.replace("px", "");
    const b4 = +getComputedStyle(o2).paddingBottom.replace("px", "");
    if (C5.target === e4) {
      if (h6 !== 0)
        return;
      s3++;
      const M3 = g4[k3 - 1];
      let L4 = r4(M3.end) + m5(M3.end), _2 = 0;
      const W = r4(M3.start), O2 = o2.querySelector(`[data-line="${M3.start - 1}"]`) || ((T3 = o2.firstElementChild) == null ? void 0 : T3.firstElementChild), N4 = o2.querySelector(`[data-line="${M3.end}"]`) || ((S2 = o2.lastElementChild) == null ? void 0 : S2.lastElementChild);
      let B2 = 0, V = 0;
      W === 0 ? O2 === N4 ? (f3 = 0, L4 = a2.contentDOM.offsetHeight - a2.scrollDOM.offsetHeight, _2 = a2.scrollDOM.scrollTop / L4, B2 = N4.offsetTop + N4.offsetHeight - o2.clientHeight) : (_2 = a2.scrollDOM.scrollTop / L4, B2 = N4.offsetTop) : L4 > a2.scrollDOM.scrollHeight - a2.scrollDOM.clientHeight ? (_2 = (a2.scrollDOM.scrollTop - W) / (a2.scrollDOM.scrollHeight - a2.scrollDOM.clientHeight - W), V = O2.offsetTop, B2 = o2.scrollHeight - o2.clientHeight - V + 10) : (_2 = (a2.scrollDOM.scrollTop - W) / (L4 - W), V = O2.offsetTop, B2 = N4.offsetTop - V);
      const K = V - f3 + B2 * _2;
      i4(o2, K, () => {
        s3--;
      });
    } else {
      if (s3 !== 0)
        return;
      h6++;
      const M3 = Array.from(
        o2.querySelectorAll("[data-line]")
      ), L4 = o2.scrollTop, _2 = o2.scrollHeight;
      let W = M3.length === 0 ? 1 : Math.ceil(
        Number(M3[M3.length - 1].dataset.line) * (L4 / _2)
      ), O2 = (I3 = o2.firstElementChild) == null ? void 0 : I3.firstElementChild;
      for (let F5 = W; F5 >= 0; F5--) {
        const R2 = o2.querySelector(`[data-line="${F5}"]`);
        if (R2 && R2.offsetTop <= L4) {
          O2 = R2, W = F5;
          break;
        }
      }
      let N4 = (D2 = o2.firstElementChild) == null ? void 0 : D2.firstElementChild, B2 = (oe = o2.firstElementChild) == null ? void 0 : oe.lastElementChild;
      for (; M3.length > 0; ) {
        const F5 = M3.indexOf(O2);
        if (F5 + 1 >= M3.length)
          break;
        const R2 = M3[F5 + 1];
        if (F5 === -1) {
          B2 = R2;
          break;
        }
        const re = O2.offsetTop;
        if (re > L4) {
          if (F5 === 0) {
            N4 = O2, B2 = R2;
            break;
          }
          O2 = M3[F5 - 1];
          continue;
        }
        const me = R2.offsetTop;
        if (re <= L4 && me > L4) {
          N4 = O2, B2 = R2;
          break;
        }
        O2 = R2;
      }
      const V = N4.offsetTop;
      let K = B2.offsetTop, j2 = 0;
      const { start: de, end: ne } = g4[Number(N4.dataset.line || 0)], J = r4(de);
      let Z = r4(ne);
      const ie2 = m5(ne);
      let X = 0;
      N4 === ((ae = o2.firstElementChild) == null ? void 0 : ae.firstElementChild) ? (N4 === B2 ? (K = B2.offsetHeight - o2.offsetHeight + f3 + b4, X = a2.contentDOM.offsetHeight - a2.scrollDOM.offsetHeight) : X = Z + ie2 - J, j2 = Math.max(L4 / K, 0)) : Z > a2.scrollDOM.scrollHeight - a2.scrollDOM.clientHeight ? (j2 = Math.max(
        (L4 - V) / (o2.scrollHeight - V - o2.clientHeight),
        0
      ), Z = r4(a2.state.doc.lines) + m5(a2.state.doc.lines), X = 8 + Z - J - e4.clientHeight) : (j2 = Math.max(
        (L4 - V) / (K - V),
        0
      ), X = Z + ie2 - J), i4(e4, J + X * j2, () => {
        h6--;
      });
    }
  }, 10);
  return [
    () => {
      u2(), e4.addEventListener("scroll", w2), o2.addEventListener("scroll", w2), e4.dispatchEvent(new Event("scroll"));
    },
    () => {
      g4 = [], e4.removeEventListener("scroll", w2), o2.removeEventListener("scroll", w2);
    }
  ];
};
var Ul = (e4, o2, l2) => {
  const a2 = inject("editorId");
  let i4 = () => {
  }, r4 = () => {
  };
  const m5 = () => {
    i4();
    const g4 = document.querySelector(
      `#${a2} .cm-scroller`
    ), u2 = document.querySelector(
      `[id="${a2}-preview-wrapper"][data-show="true"]`
    ), s3 = document.querySelector(
      `[id="${a2}-html-wrapper"][data-show="true"]`
    );
    (u2 || s3) && ([r4, i4] = (u2 ? Wl : Pl)(
      g4,
      u2 || s3,
      l2.value
    )), e4.scrollAuto && r4();
  };
  watch(
    [
      o2,
      toRef(e4.setting, "preview"),
      toRef(e4.setting, "htmlPreview"),
      toRef(e4.setting, "fullscreen"),
      toRef(e4.setting, "pageFullscreen")
    ],
    () => {
      nextTick(m5);
    }
  ), watch(
    () => e4.scrollAuto,
    (g4) => {
      g4 ? r4() : i4();
    }
  ), onMounted(m5);
};
var _l = Ul;
var ql = (e4, o2, l2) => {
  var h6, w2, C5, d3, k3, f3;
  let a2 = "", i4 = 0, r4 = 0, m5 = true, g4 = false;
  const u2 = o2.getSelectedText(), s3 = (h6 = l.editorConfig) == null ? void 0 : h6.mermaidTemplate;
  if (/^h[1-6]{1}$/.test(e4)) {
    const b4 = e4.replace(/^h(\d)/, ($2, T3) => new Array(Number(T3)).fill("#", 0, T3).join(""));
    a2 = `${b4} ${u2}`, i4 = b4.length + 1;
  } else if (e4 === "prettier") {
    const b4 = window.prettier || ((C5 = (w2 = l.editorExtensions) == null ? void 0 : w2.prettier) == null ? void 0 : C5.prettierInstance), $2 = [
      ((d3 = window.prettierPlugins) == null ? void 0 : d3.markdown) || ((f3 = (k3 = l.editorExtensions) == null ? void 0 : k3.prettier) == null ? void 0 : f3.parserMarkdownInstance)
    ];
    !b4 || $2[0] === void 0 ? (C2.emit(l2.editorId, b2, {
      name: "prettier",
      message: "prettier is undefined"
    }), a2 = o2.getValue()) : a2 = b4.format(o2.getValue(), {
      parser: "markdown",
      plugins: $2
    }), m5 = false, g4 = true;
  } else
    switch (e4) {
      case "bold": {
        a2 = `**${u2}**`, i4 = 2, r4 = -2;
        break;
      }
      case "underline": {
        a2 = `<u>${u2}</u>`, i4 = 3, r4 = -4;
        break;
      }
      case "italic": {
        a2 = `*${u2}*`, i4 = 1, r4 = -1;
        break;
      }
      case "strikeThrough": {
        a2 = `~~${u2}~~`, i4 = 2, r4 = -2;
        break;
      }
      case "sub": {
        a2 = `<sub>${u2}</sub>`, i4 = 5, r4 = -6;
        break;
      }
      case "sup": {
        a2 = `<sup>${u2}</sup>`, i4 = 5, r4 = -6;
        break;
      }
      case "codeRow": {
        a2 = "`" + u2 + "`", i4 = 1, r4 = -1;
        break;
      }
      case "quote": {
        a2 = `> ${u2}`, i4 = 2;
        break;
      }
      case "orderedList": {
        a2 = `1. ${u2}`, i4 = 3;
        break;
      }
      case "unorderedList": {
        a2 = `- ${u2}`, i4 = 2;
        break;
      }
      case "task": {
        a2 = `- [ ] ${u2}`, i4 = 6;
        break;
      }
      case "code": {
        const b4 = l2.text || u2 || "", $2 = l2.mode || "language";
        a2 = `\`\`\`${$2}
${b4}
\`\`\`
`, i4 = 3, r4 = 3 + $2.length - a2.length;
        break;
      }
      case "table": {
        a2 = "|";
        const { selectedShape: b4 = { x: 1, y: 1 } } = l2, { x: $2, y: T3 } = b4;
        for (let S2 = 0; S2 <= T3; S2++)
          a2 += " col |";
        a2 += `
|`;
        for (let S2 = 0; S2 <= T3; S2++)
          a2 += " - |";
        for (let S2 = 0; S2 <= $2; S2++) {
          a2 += `
|`;
          for (let I3 = 0; I3 <= T3; I3++)
            a2 += " content |";
        }
        i4 = 2, r4 = 5 - a2.length;
        break;
      }
      case "link": {
        const { desc: b4, url: $2 } = l2;
        a2 = `[${b4}](${$2})`, m5 = false;
        break;
      }
      case "image": {
        const { desc: b4, url: $2, urls: T3 } = l2;
        T3 instanceof Array ? a2 = T3.reduce((S2, I3) => S2 + `![${b4}](${I3})
`, "") : a2 = `![${b4}](${$2})
`, m5 = false;
        break;
      }
      case "flow": {
        a2 = `\`\`\`mermaid
${(s3 == null ? void 0 : s3.flow) || `flowchart TD 
  Start --> Stop`}
\`\`\`
`, i4 = 3, r4 = 10 - a2.length;
        break;
      }
      case "sequence": {
        a2 = `\`\`\`mermaid
${(s3 == null ? void 0 : s3.sequence) || `sequenceDiagram
  A->>B: hello!
  B-->>A: hi!
  A-)B: bye!`}
\`\`\`
`, i4 = 3, r4 = 10 - a2.length;
        break;
      }
      case "gantt": {
        a2 = `\`\`\`mermaid
${(s3 == null ? void 0 : s3.gantt) || `gantt
title A Gantt Diagram
dateFormat  YYYY-MM-DD
section Section
A task  :a1, 2014-01-01, 30d
Another task  :after a1, 20d`}
\`\`\`
`, i4 = 3, r4 = 10 - a2.length;
        break;
      }
      case "class": {
        a2 = `\`\`\`mermaid
${(s3 == null ? void 0 : s3.class) || `classDiagram
  class Animal
  Vehicle <|-- Car`}
\`\`\`
`, i4 = 3, r4 = 10 - a2.length;
        break;
      }
      case "state": {
        a2 = `\`\`\`mermaid
${(s3 == null ? void 0 : s3.state) || `stateDiagram-v2
  s1 --> s2`}
\`\`\`
`, i4 = 3, r4 = 10 - a2.length;
        break;
      }
      case "pie": {
        a2 = `\`\`\`mermaid
${(s3 == null ? void 0 : s3.pie) || `pie title Pets adopted by volunteers
  "Dogs" : 386
  "Cats" : 85
  "Rats" : 15`}
\`\`\`
`, i4 = 3, r4 = 10 - a2.length;
        break;
      }
      case "relationship": {
        a2 = `\`\`\`mermaid
${(s3 == null ? void 0 : s3.relationship) || `erDiagram
  CAR ||--o{ NAMED-DRIVER : allows
  PERSON ||--o{ NAMED-DRIVER : is`}
\`\`\`
`, i4 = 3, r4 = 10 - a2.length;
        break;
      }
      case "journey": {
        a2 = `\`\`\`mermaid
${(s3 == null ? void 0 : s3.journey) || `journey
  title My working day
  section Go to work
    Make tea: 5: Me
    Go upstairs: 3: Me
    Do work: 1: Me, Cat
  section Go home
    Go downstairs: 5: Me
    Sit down: 5: Me`}
\`\`\`
`, i4 = 3, r4 = 10 - a2.length;
        break;
      }
      case "katexInline": {
        a2 = "$$", i4 = 1, r4 = -1;
        break;
      }
      case "katexBlock": {
        a2 = `$$

$$
`, i4 = 3, r4 = -4;
        break;
      }
      case "universal": {
        const { generate: b4 } = l2, $2 = b4(u2);
        a2 = $2.targetValue, m5 = $2.select, i4 = $2.deviationStart, r4 = $2.deviationEnd;
      }
    }
  return {
    text: a2,
    options: {
      // 是否选中
      select: m5,
      // 选中时，开始位置的偏移量
      deviationStart: i4,
      // 结束的偏移量
      deviationEnd: r4,
      // 是否整个替换
      replaceAll: g4
    }
  };
};
var zl = "#e5c07b";
var ht = "var(--md-color)";
var Gl = "#56b6c2";
var Kl = "#ffffff";
var ce2 = "var(--md-color)";
var bt = "#e5c07b";
var jl = "#e5c07b";
var Zl = "var(--md-color)";
var vt = "#d19a66";
var Xl = "#c678dd";
var Yl = "#21252b";
var Jl = "#2c313a";
var kt2 = "var(--md-bk-color)";
var $e = "var(--md-bk-color)";
var Ql = "#ceedfa33";
var Ct2 = "#528bff";
var eo = EditorView.theme(
  {
    "&": {
      color: ce2,
      backgroundColor: kt2
    },
    ".cm-content": {
      caretColor: Ct2
    },
    ".cm-cursor, .cm-dropCursor": { borderLeftColor: Ct2 },
    "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: Ql },
    ".cm-panels": { backgroundColor: Yl, color: ce2 },
    ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
    ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
    ".cm-searchMatch": {
      backgroundColor: "#72a1ff59",
      outline: "1px solid #457dff"
    },
    ".cm-searchMatch.cm-searchMatch-selected": {
      backgroundColor: "#6199ff2f"
    },
    ".cm-activeLine": { backgroundColor: "#ceedfa33" },
    ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
    "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
      backgroundColor: "#bad0f847"
    },
    ".cm-gutters": {
      backgroundColor: kt2,
      color: ce2,
      borderRight: "1px solid",
      borderColor: "var(--md-border-color)"
    },
    ".cm-activeLineGutter": {
      backgroundColor: Jl
    },
    ".cm-foldPlaceholder": {
      backgroundColor: "transparent",
      border: "none",
      color: "#ddd"
    },
    ".cm-tooltip": {
      border: "1px solid var(--md-border-color)",
      backgroundColor: $e
    },
    ".cm-tooltip .cm-tooltip-arrow:before": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    },
    ".cm-tooltip .cm-tooltip-arrow:after": {
      borderTopColor: $e,
      borderBottomColor: $e
    },
    ".cm-tooltip-autocomplete": {
      "& > ul > li[aria-selected]": {
        color: ce2
      }
    }
  },
  { dark: true }
);
var to = HighlightStyle.define([
  { tag: tags.keyword, color: Xl },
  { tag: [tags.name, tags.deleted, tags.character, tags.propertyName, tags.macroName], color: ht },
  { tag: [tags.function(tags.variableName), tags.labelName], color: jl },
  { tag: [tags.color, tags.constant(tags.name), tags.standard(tags.name)], color: vt },
  { tag: [tags.definition(tags.name), tags.separator], color: ce2 },
  {
    tag: [
      tags.typeName,
      tags.className,
      tags.number,
      tags.changed,
      tags.annotation,
      tags.modifier,
      tags.self,
      tags.namespace
    ],
    color: zl
  },
  {
    tag: [
      tags.operator,
      tags.operatorKeyword,
      tags.url,
      tags.escape,
      tags.regexp,
      tags.link,
      tags.special(tags.string)
    ],
    color: Gl
  },
  { tag: [tags.meta, tags.comment], color: bt },
  { tag: tags.strong, fontWeight: "bold" },
  { tag: tags.emphasis, fontStyle: "italic" },
  { tag: tags.strikethrough, textDecoration: "line-through" },
  { tag: tags.link, color: bt, textDecoration: "underline" },
  { tag: tags.heading, fontWeight: "bold", color: ht },
  { tag: [tags.atom, tags.bool, tags.special(tags.variableName)], color: vt },
  { tag: [tags.processingInstruction, tags.string, tags.inserted], color: Zl },
  { tag: tags.invalid, color: Kl }
]);
var $t2 = [
  eo,
  syntaxHighlighting(to)
];
var lo = "#e5c07b";
var pt = "#3f4a54";
var oo = "#56b6c2";
var ao = "#fff";
var ue2 = "#3f4a54";
var yt = "#2d8cf0";
var no = "#2d8cf0";
var io = "#3f4a54";
var Tt2 = "#d19a66";
var ro = "#c678dd";
var so = "#21252b";
var co = "#ceedfa33";
var wt2 = "var(--md-bk-color)";
var pe = "var(--md-bk-color)";
var uo = "#bad5fa";
var xt = "#3f4a54";
var mo = EditorView.theme(
  {
    "&": {
      color: ue2,
      backgroundColor: wt2
    },
    ".cm-content": {
      caretColor: xt
    },
    ".cm-cursor, .cm-dropCursor": { borderLeftColor: xt },
    "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: uo },
    ".cm-panels": { backgroundColor: so, color: ue2 },
    ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
    ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
    ".cm-searchMatch": {
      backgroundColor: "#72a1ff59",
      outline: "1px solid #457dff"
    },
    ".cm-searchMatch.cm-searchMatch-selected": {
      backgroundColor: "#6199ff2f"
    },
    ".cm-activeLine": { backgroundColor: "#ceedfa33" },
    ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
    "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
      backgroundColor: "#bad0f847"
    },
    ".cm-gutters": {
      backgroundColor: wt2,
      color: ue2,
      borderRight: "1px solid",
      borderColor: "var(--md-border-color)"
    },
    ".cm-activeLineGutter": {
      backgroundColor: co
    },
    ".cm-foldPlaceholder": {
      backgroundColor: "transparent",
      border: "none",
      color: "#ddd"
    },
    ".cm-tooltip": {
      border: "1px solid var(--md-border-color)",
      backgroundColor: pe
    },
    ".cm-tooltip .cm-tooltip-arrow:before": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    },
    ".cm-tooltip .cm-tooltip-arrow:after": {
      borderTopColor: pe,
      borderBottomColor: pe
    },
    ".cm-tooltip-autocomplete": {
      "& > ul > li[aria-selected]": {
        color: ue2
      }
    }
  }
  // { dark: true }
);
var go = HighlightStyle.define([
  { tag: tags.keyword, color: ro },
  { tag: [tags.name, tags.deleted, tags.character, tags.propertyName, tags.macroName], color: pt },
  { tag: [tags.function(tags.variableName), tags.labelName], color: no },
  { tag: [tags.color, tags.constant(tags.name), tags.standard(tags.name)], color: Tt2 },
  { tag: [tags.definition(tags.name), tags.separator], color: ue2 },
  {
    tag: [
      tags.typeName,
      tags.className,
      tags.number,
      tags.changed,
      tags.annotation,
      tags.modifier,
      tags.self,
      tags.namespace
    ],
    color: lo
  },
  {
    tag: [
      tags.operator,
      tags.operatorKeyword,
      tags.url,
      tags.escape,
      tags.regexp,
      tags.link,
      tags.special(tags.string)
    ],
    color: oo
  },
  { tag: [tags.meta, tags.comment], color: yt },
  { tag: tags.strong, fontWeight: "bold" },
  { tag: tags.emphasis, fontStyle: "italic" },
  { tag: tags.strikethrough, textDecoration: "line-through" },
  { tag: tags.link, color: yt, textDecoration: "underline" },
  { tag: tags.heading, fontWeight: "bold", color: pt },
  { tag: [tags.atom, tags.bool, tags.special(tags.variableName)], color: Tt2 },
  { tag: [tags.processingInstruction, tags.string, tags.inserted], color: io },
  { tag: tags.invalid, color: ao }
]);
var St2 = [
  mo,
  syntaxHighlighting(go)
];
var he = (e4, o2, l2, a2, i4) => (r4, m5, g4, u2) => {
  const s3 = `${e4}${o2}`.slice(u2 - g4);
  r4.dispatch(r4.state.replaceSelection(`${s3}${l2}${a2}`));
  const h6 = g4 + m5.label.length + (i4 === "title" ? l2.length : 0);
  r4.dispatch({
    selection: EditorSelection.create(
      [
        EditorSelection.range(
          g4 + m5.label.length + (i4 === "title" ? 1 : -o2.length),
          h6
        ),
        EditorSelection.cursor(h6)
      ],
      1
    )
  }), r4.focus();
};
var At = (e4) => (o2, l2, a2, i4) => {
  const r4 = e4.slice(i4 - a2);
  o2.dispatch(o2.state.replaceSelection(`${r4} `));
};
var fo = (e4) => {
  const o2 = (l2) => {
    const a2 = l2.matchBefore(
      /^#+|^-\s*\[*\s*\]*|`+|\[|!\[*|^\|\s?\|?|^\$\$?|!+\s*\w*/
    );
    return a2 === null || a2.from == a2.to && l2.explicit ? null : {
      from: a2.from,
      options: [
        // 标题
        ...["h1", "h2", "h3", "h4", "h5", "h6"].map((i4, r4) => {
          const m5 = new Array(r4 + 1).fill("#").join("");
          return {
            label: m5,
            type: "text",
            apply: At(m5)
          };
        }),
        // 任务列表
        ...["unchecked", "checked"].map((i4) => {
          const r4 = i4 === "checked" ? "- [x]" : "- [ ]";
          return {
            label: r4,
            type: "text",
            apply: At(r4)
          };
        }),
        // 代码
        ...[
          ["`", ""],
          ["```", "language"],
          ["```mermaid\n", ""]
        ].map((i4) => ({
          label: `${i4[0]}${i4[1]}`,
          type: "text",
          apply: he(i4[0], i4[1], "", i4[0] === "`" ? "`" : "\n```", "type")
        })),
        // 链接
        {
          label: "[]()",
          type: "text"
        },
        {
          label: "![]()",
          type: "text"
        },
        // 表格
        {
          label: "| |",
          type: "text",
          detail: "table",
          apply: `| col | col | col |
| - | - | - |
| content | content | content |
| content | content | content |`
        },
        // 公式
        {
          label: "$",
          type: "text",
          apply: he("$", "", "", "$", "type")
        },
        {
          label: "$$",
          type: "text",
          apply: he("$$", "", `
`, `
$$`, "title")
        },
        // 那啥？
        ...[
          "note",
          "abstract",
          "info",
          "tip",
          "success",
          "question",
          "warning",
          "failure",
          "danger",
          "bug",
          "example",
          "quote",
          "hint",
          "caution",
          "error",
          "attention"
        ].map((i4) => ({
          label: `!!! ${i4}`,
          type: "text",
          apply: he("!!!", ` ${i4}`, " Title", `

!!!`, "title")
        }))
      ]
    };
  };
  return autocompletion({
    override: e4 ? [o2, ...e4] : [o2]
  });
};
var Mt = fo;
var ee = (e4) => {
  const o2 = new Compartment();
  return (a2) => (o2.get(e4.state) ? e4.dispatch({ effects: o2.reconfigure(a2) }) : e4.dispatch({
    effects: StateEffect.appendConfig.of(o2.of(a2))
  }), true);
};
var ho = class {
  constructor(o2) {
    q(this, "view");
    q(this, "maxLength", Number.MAX_SAFE_INTEGER);
    q(this, "toggleTabSize");
    q(this, "togglePlaceholder");
    q(this, "setExtensions");
    q(this, "toggleDisabled");
    q(this, "toggleReadOnly");
    q(this, "toggleMaxlength");
    this.view = o2, this.toggleTabSize = ee(this.view), this.togglePlaceholder = ee(this.view), this.setExtensions = ee(this.view), this.toggleDisabled = ee(this.view), this.toggleReadOnly = ee(this.view), this.toggleMaxlength = ee(this.view);
  }
  getValue() {
    return this.view.state.doc.toString();
  }
  /**
   * 设置内容
   *
   * @param insert 待插入内容
   * @param from 插入开始位置
   * @param to 插入结束位置
   */
  setValue(o2, l2 = 0, a2 = this.view.state.doc.length) {
    this.view.dispatch({
      changes: {
        from: l2,
        to: a2,
        insert: o2
      }
    });
  }
  /**
   * 获取选中的文本
   */
  getSelectedText() {
    const { from: o2, to: l2 } = this.view.state.selection.main;
    return this.view.state.sliceDoc(o2, l2);
  }
  /**
   * 使用新的内容替换选中的内容
   *
   * @param text 待替换内容
   * @param options 替换后是否选中
   */
  replaceSelectedText(o2, l2 = {
    // 是否选中
    select: true,
    // 选中时，开始位置的偏移量
    deviationStart: 0,
    // 结束的偏移量
    deviationEnd: 0,
    // 直接替换所有文本
    replaceAll: false
  }, a2) {
    try {
      if (l2.replaceAll) {
        if (this.setValue(o2), o2.length > this.maxLength)
          throw new Error("The input text is too long");
        return;
      }
      if (this.view.state.doc.length - this.getSelectedText().length + o2.length > this.maxLength)
        throw new Error("The input text is too long");
      const { from: i4 } = this.view.state.selection.main;
      if (this.view.dispatch(this.view.state.replaceSelection(o2)), l2.select) {
        const r4 = i4 + o2.length + l2.deviationEnd;
        this.view.dispatch({
          selection: EditorSelection.create(
            [
              EditorSelection.range(i4 + l2.deviationStart, r4),
              EditorSelection.cursor(r4)
            ],
            1
          )
        });
      }
      this.view.focus();
    } catch (i4) {
      if (i4.message === "The input text is too long")
        C2.emit(a2, b2, {
          name: "overlength",
          message: i4.message,
          data: o2
        });
      else
        throw i4;
    }
  }
  /**
   * 设置tabSize
   *
   * @param tabSize 需要切换的大小
   */
  setTabSize(o2) {
    this.toggleTabSize([
      EditorState.tabSize.of(o2),
      indentUnit.of(" ".repeat(o2))
    ]);
  }
  /**
   * 设置placeholder
   *
   * @param t 目标内容
   */
  setPlaceholder(o2) {
    this.togglePlaceholder(placeholder(o2));
  }
  focus(o2) {
    if (this.view.focus(), !o2)
      return;
    let l2 = 0, a2 = 0, i4 = 0;
    switch (o2) {
      case "start":
        break;
      case "end": {
        l2 = a2 = i4 = this.getValue().length;
        break;
      }
      default:
        l2 = o2.rangeAnchor || o2.cursorPos, a2 = o2.rangeHead || o2.cursorPos, i4 = o2.cursorPos;
    }
    this.view.dispatch({
      scrollIntoView: true,
      selection: EditorSelection.create(
        [EditorSelection.range(l2, a2), EditorSelection.cursor(i4)],
        1
      )
    });
  }
  setDisabled(o2) {
    this.toggleDisabled([EditorView.editable.of(!o2)]);
  }
  setReadOnly(o2) {
    this.toggleReadOnly([EditorState.readOnly.of(o2)]);
  }
  setMaxLength(o2) {
    this.maxLength = o2, this.toggleMaxlength([
      EditorState.changeFilter.of((l2) => l2.newDoc.length <= o2)
    ]);
  }
};
var bo = (e4) => {
  const o2 = inject("editorId");
  return (a2) => {
    if (!a2.clipboardData)
      return;
    if (a2.clipboardData.files.length > 0) {
      const { files: r4 } = a2.clipboardData;
      C2.emit(
        o2,
        H,
        Array.from(r4).filter((m5) => /image\/.*/.test(m5.type))
      ), a2.preventDefault();
      return;
    }
    if (e4.autoDetectCode && a2.clipboardData.types.includes("vscode-editor-data")) {
      const r4 = JSON.parse(a2.clipboardData.getData("vscode-editor-data"));
      C2.emit(o2, G, "code", {
        mode: r4.mode,
        text: a2.clipboardData.getData("text/plain")
      }), a2.preventDefault();
      return;
    }
    const i4 = a2.clipboardData.getData("text/plain");
    e4.maxlength && i4.length + e4.modelValue.length > e4.maxlength && C2.emit(o2, b2, {
      name: "overlength",
      message: "The input text is too long",
      data: i4
    });
  };
};
var vo = bo;
var ko = (e4) => {
  const o2 = inject("editorId");
  onMounted(() => {
    C2.on(o2, {
      name: f2,
      callback(l2) {
        var a2;
        (a2 = e4.value) == null || a2.focus(l2);
      }
    });
  });
};
var Co = ko;
var $o = (e4, o2) => [
  {
    key: "Ctrl-b",
    mac: "Cmd-b",
    run: () => (C2.emit(e4, G, "bold"), true)
  },
  {
    key: "Ctrl-d",
    mac: "Cmd-d",
    run: deleteLine,
    preventDefault: true
  },
  {
    key: "Ctrl-s",
    mac: "Cmd-s",
    run: (I3) => (C2.emit(e4, E, I3.state.doc.toString()), true),
    shift: () => (C2.emit(e4, G, "strikeThrough"), true)
  },
  {
    key: "Ctrl-u",
    mac: "Cmd-u",
    run: () => (C2.emit(e4, G, "underline"), true),
    shift: () => (C2.emit(e4, G, "unorderedList"), true)
  },
  {
    key: "Ctrl-i",
    mac: "Cmd-i",
    run: () => (C2.emit(e4, G, "italic"), true),
    shift: () => (C2.emit(e4, T, "image"), true)
  },
  {
    key: "Ctrl-1",
    mac: "Cmd-1",
    run: () => (C2.emit(e4, G, "h1"), true)
  },
  {
    key: "Ctrl-2",
    mac: "Cmd-2",
    run: () => (C2.emit(e4, G, "h2"), true)
  },
  {
    key: "Ctrl-3",
    mac: "Cmd-3",
    run: () => (C2.emit(e4, G, "h3"), true)
  },
  {
    key: "Ctrl-4",
    mac: "Cmd-4",
    run: () => (C2.emit(e4, G, "h4"), true)
  },
  {
    key: "Ctrl-5",
    mac: "Cmd-5",
    run: () => (C2.emit(e4, G, "h5"), true)
  },
  {
    key: "Ctrl-6",
    mac: "Cmd-6",
    run: () => (C2.emit(e4, G, "h6"), true)
  },
  {
    key: "Ctrl-ArrowUp",
    mac: "Cmd-ArrowUp",
    run: () => (C2.emit(e4, G, "sup"), true)
  },
  {
    key: "Ctrl-ArrowDown",
    mac: "Cmd-ArrowDown",
    run: () => (C2.emit(e4, G, "sub"), true)
  },
  {
    key: "Ctrl-o",
    mac: "Cmd-o",
    run: () => (C2.emit(e4, G, "orderedList"), true)
  },
  {
    key: "Ctrl-c",
    mac: "Cmd-c",
    shift: () => (C2.emit(e4, G, "code"), true),
    any(I3, D2) {
      return (D2.ctrlKey || D2.metaKey) && D2.altKey && D2.code === "KeyC" ? (C2.emit(e4, G, "codeRow"), true) : false;
    }
  },
  {
    key: "Ctrl-l",
    mac: "Cmd-l",
    run: () => (C2.emit(e4, T, "link"), true)
  },
  {
    key: "Ctrl-f",
    mac: "Cmd-f",
    shift: () => o2.noPrettier ? false : (C2.emit(e4, G, "prettier"), true)
  },
  {
    any: (I3, D2) => (D2.ctrlKey || D2.metaKey) && D2.altKey && D2.shiftKey && D2.code === "KeyT" ? (C2.emit(e4, G, "table"), true) : false
  }
];
var po = $o;
var yo = (e4) => {
  const o2 = inject("tabWidth"), l2 = inject("editorId"), a2 = inject("theme"), i4 = ref(), r4 = shallowRef(), m5 = new Compartment(), g4 = new Compartment(), u2 = new Compartment(), s3 = po(l2, e4), h6 = vo(e4), w2 = [
    keymap.of([...s3, indentWithTab]),
    minimalSetup,
    m5.of(markdown({ codeLanguages: languages })),
    // 横向换行
    EditorView.lineWrapping,
    EditorView.updateListener.of((d3) => {
      d3.docChanged && e4.onChange(d3.state.doc.toString());
    }),
    EditorView.domEventHandlers({
      paste: h6,
      blur: e4.onBlur,
      focus: e4.onFocus,
      drop: e4.onDrop,
      input: (d3) => {
        e4.onInput && e4.onInput(d3);
        const { data: k3 } = d3;
        e4.maxlength && e4.modelValue.length + k3.length > e4.maxlength && C2.emit(l2, b2, {
          name: "overlength",
          message: "The input text is too long",
          data: k3
        });
      }
    })
  ], C5 = () => {
    const d3 = [
      ...w2,
      g4.of(a2.value === "light" ? St2 : $t2),
      u2.of(Mt(e4.completions))
    ];
    return l.codeMirrorExtensions(a2.value, d3, [
      ...s3
    ]);
  };
  return onMounted(() => {
    const d3 = new EditorView({
      doc: e4.modelValue,
      parent: i4.value,
      extensions: [C5()]
    }), k3 = new ho(d3);
    r4.value = k3, setTimeout(() => {
      k3.setTabSize(o2), k3.setDisabled(e4.disabled), k3.setReadOnly(e4.readonly), e4.placeholder && k3.setPlaceholder(e4.placeholder), typeof e4.maxlength == "number" && k3.setMaxLength(e4.maxlength), e4.autofocus && d3.focus();
    }, 0), C2.on(l2, {
      name: F3,
      callback() {
        undo(d3);
      }
    }), C2.on(l2, {
      name: m2,
      callback() {
        redo(d3);
      }
    }), C2.on(l2, {
      name: G,
      callback(f3, b4 = {}) {
        var S2;
        const { text: $2, options: T3 } = ql(f3, r4.value, b4);
        (S2 = r4.value) == null || S2.replaceSelectedText($2, T3, l2);
      }
    });
  }), watch(
    a2,
    () => {
      var d3;
      (d3 = r4.value) == null || d3.view.dispatch({
        effects: g4.reconfigure(a2.value === "light" ? St2 : $t2)
      });
    },
    {
      deep: true
    }
  ), watch(
    () => e4.completions,
    () => {
      var d3;
      (d3 = r4.value) == null || d3.view.dispatch({
        effects: u2.reconfigure(Mt(e4.completions))
      });
    },
    {
      deep: true
    }
  ), watch(
    () => e4.modelValue,
    () => {
      var d3, k3;
      ((d3 = r4.value) == null ? void 0 : d3.getValue()) !== e4.modelValue && ((k3 = r4.value) == null || k3.setValue(e4.modelValue));
    }
  ), watch(
    () => e4.placeholder,
    () => {
      var d3;
      (d3 = r4.value) == null || d3.setPlaceholder(e4.placeholder);
    }
  ), watch(
    () => e4.disabled,
    () => {
      var d3;
      (d3 = r4.value) == null || d3.setDisabled(e4.disabled);
    }
  ), watch(
    () => e4.readonly,
    () => {
      var d3;
      (d3 = r4.value) == null || d3.setDisabled(e4.readonly);
    }
  ), watch(
    () => e4.maxlength,
    () => {
      var d3;
      e4.maxlength && ((d3 = r4.value) == null || d3.setMaxLength(e4.maxlength));
    }
  ), Co(r4), {
    inputWrapperRef: i4,
    codeMirrorUt: r4
  };
};
var To = yo;
var wo = (e4, o2, l2) => {
  const a2 = reactive({
    resizedWidth: e4.inputBoxWitdh
  }), i4 = reactive({
    width: e4.inputBoxWitdh
  }), r4 = reactive({
    left: e4.inputBoxWitdh,
    display: "initial"
  }), m5 = (s3) => {
    var k3, f3, b4;
    const h6 = ((k3 = o2.value) == null ? void 0 : k3.offsetWidth) || 0, w2 = ((f3 = o2.value) == null ? void 0 : f3.getBoundingClientRect().x) || 0;
    let C5 = s3.x - w2;
    C5 < v ? C5 = v : C5 > h6 - v && (C5 = h6 - v);
    const d3 = `${C5}px`;
    i4.width = d3, r4.left = d3, a2.resizedWidth = d3, (b4 = e4.onInputBoxWitdhChange) == null || b4.call(e4, d3);
  }, g4 = () => {
    document.addEventListener("mousemove", m5);
  }, u2 = () => {
    document.removeEventListener("mousemove", m5);
  };
  return onMounted(() => {
    var s3;
    (s3 = l2.value) == null || s3.addEventListener("mousedown", g4), document.addEventListener("mouseup", u2);
  }), onBeforeUnmount(() => {
    var s3, h6;
    (s3 = l2.value) == null || s3.removeEventListener("mousedown", g4), (h6 = l2.value) == null || h6.removeEventListener("mouseup", u2);
  }), watch(
    () => e4.inputBoxWitdh,
    (s3) => {
      s3 && (i4.width = s3, r4.left = s3);
    }
  ), watch(
    [toRef(e4.setting, "htmlPreview"), toRef(e4.setting, "preview")],
    () => {
      !e4.setting.htmlPreview && !e4.setting.preview ? (i4.width = "100%", r4.display = "none") : (i4.width = a2.resizedWidth, r4.display = "initial");
    },
    {
      immediate: true
    }
  ), { inputWrapperStyle: i4, resizeOperateStyle: r4 };
};
var xo = wo;
var So = defineComponent({
  name: "MDEditorContent",
  props: wt,
  setup(e4) {
    const o2 = inject("editorId"), l2 = ref(""), a2 = ref(), i4 = ref(), {
      inputWrapperRef: r4,
      codeMirrorUt: m5
    } = To(e4), {
      inputWrapperStyle: g4,
      resizeOperateStyle: u2
    } = xo(e4, a2, i4);
    return _l(e4, l2, m5), () => createVNode("div", {
      class: `${a}-content${e4.setting.htmlPreview || e4.setting.preview ? " has-preview" : ""}`,
      ref: a2
    }, [createVNode("div", {
      class: `${a}-input-wrapper`,
      style: g4,
      ref: r4
    }, null), (e4.setting.htmlPreview || e4.setting.preview) && createVNode("div", {
      class: `${a}-resize-operate`,
      style: u2,
      ref: i4
    }, null), createVNode(lt, {
      modelValue: e4.modelValue,
      setting: e4.setting,
      onHtmlChanged: (s3) => {
        l2.value = s3, e4.onHtmlChanged(s3);
      },
      onGetCatalog: e4.onGetCatalog,
      mdHeadingId: e4.mdHeadingId,
      noMermaid: e4.noMermaid,
      sanitize: e4.sanitize,
      noKatex: e4.noKatex,
      formatCopiedText: e4.formatCopiedText,
      noHighlight: e4.noHighlight,
      noImgZoomIn: e4.noImgZoomIn
    }, null), e4.catalogVisible && createVNode(k2, {
      theme: e4.theme,
      class: `${a}-catalog-editor`,
      editorId: o2,
      mdHeadingId: e4.mdHeadingId,
      key: "internal-catalog"
    }, null)]);
  }
});
var Ao = defineComponent({
  props: {
    modelValue: {
      type: String,
      default: ""
    }
  },
  setup(e4) {
    const o2 = inject("usedLanguageText");
    return () => {
      var l2, a2;
      return createVNode("div", {
        class: `${a}-footer-item`
      }, [createVNode("label", {
        class: `${a}-footer-label`
      }, [`${(l2 = o2.value.footer) == null ? void 0 : l2.markdownTotal}:`]), createVNode("span", null, [((a2 = e4.modelValue) == null ? void 0 : a2.length) || 0])]);
    };
  }
});
var Mo = {
  checked: {
    type: Boolean,
    default: false
  },
  onChange: {
    type: Function,
    default: () => {
    }
  }
};
var Lo = defineComponent({
  props: Mo,
  setup(e4) {
    return () => createVNode("div", {
      class: [`${a}-checkbox`, e4.checked && `${a}-checkbox-checked`],
      onClick: () => {
        e4.onChange(!e4.checked);
      }
    }, null);
  }
});
var Io = {
  scrollAuto: {
    type: Boolean
  },
  onScrollAutoChange: {
    type: Function,
    default: () => {
    }
  }
};
var Do = defineComponent({
  props: Io,
  setup(e4) {
    const o2 = inject("usedLanguageText");
    return () => {
      var l2;
      return createVNode("div", {
        class: `${a}-footer-item`
      }, [createVNode("label", {
        class: `${a}-footer-label`,
        onClick: () => {
          e4.onScrollAutoChange(!e4.scrollAuto);
        }
      }, [(l2 = o2.value.footer) == null ? void 0 : l2.scrollAuto]), createVNode(Lo, {
        checked: e4.scrollAuto,
        onChange: e4.onScrollAutoChange
      }, null)]);
    };
  }
});
var Eo = {
  modelValue: {
    type: String,
    default: ""
  },
  footers: {
    type: Array,
    default: []
  },
  scrollAuto: {
    type: Boolean
  },
  onScrollAutoChange: {
    type: Function,
    default: () => {
    }
  },
  defFooters: {
    type: Object
  }
};
var Ho = defineComponent({
  name: "MDEditorFooter",
  props: Eo,
  setup(e4) {
    const o2 = computed(() => {
      const a2 = e4.footers.indexOf("="), i4 = a2 === -1 ? e4.footers : e4.footers.slice(0, a2), r4 = a2 === -1 ? [] : e4.footers.slice(a2, Number.MAX_SAFE_INTEGER);
      return [i4, r4];
    }), l2 = (a2) => {
      if (p.includes(a2))
        switch (a2) {
          case "markdownTotal":
            return createVNode(Ao, {
              modelValue: e4.modelValue
            }, null);
          case "scrollSwitch":
            return createVNode(Do, {
              scrollAuto: e4.scrollAuto,
              onScrollAutoChange: e4.onScrollAutoChange
            }, null);
        }
      else
        return e4.defFooters instanceof Array ? e4.defFooters[a2] || "" : e4.defFooters && e4.defFooters.children instanceof Array && e4.defFooters.children[a2] || "";
    };
    return () => {
      const a2 = o2.value[0].map((r4) => l2(r4)), i4 = o2.value[1].map((r4) => l2(r4));
      return createVNode("div", {
        class: `${a}-footer`
      }, [createVNode("div", {
        class: `${a}-footer-left`
      }, [a2]), createVNode("div", {
        class: `${a}-footer-right`
      }, [i4])]);
    };
  }
});
var No = defineComponent({
  name: "MdEditorV3",
  props: Tt,
  emits: _t,
  setup(e4, o2) {
    const {
      editorId: l2,
      noKatex: a2,
      noMermaid: i4,
      noPrettier: r4,
      noUploadImg: m5,
      noHighlight: g4
    } = e4, u2 = reactive({
      scrollAuto: e4.scrollAuto
    });
    kt(e4, o2), $t(e4), Ct(e4), It(e4, o2);
    const [s3, h6] = St(e4, o2), w2 = Et(e4);
    return onBeforeUnmount(() => {
      C2.clear(l2);
    }), Pt(e4, o2, w2, s3, h6), () => {
      var k3;
      const C5 = s({
        props: e4,
        ctx: o2
      }, "defToolbars"), d3 = s({
        props: e4,
        ctx: o2
      }, "defFooters");
      return createVNode("div", {
        id: l2,
        class: [a, e4.class, e4.theme === "dark" && `${a}-dark`, s3.fullscreen || s3.pageFullscreen ? `${a}-fullscreen` : ""],
        style: e4.style
      }, [createVNode(Rl, {
        noPrettier: r4,
        toolbars: e4.toolbars,
        toolbarsExclude: e4.toolbarsExclude,
        setting: s3,
        updateSetting: h6,
        tableShape: e4.tableShape,
        defToolbars: C5,
        noUploadImg: m5,
        showToolbarName: e4.showToolbarName
      }, null), createVNode(So, {
        modelValue: e4.modelValue,
        setting: s3,
        mdHeadingId: e4.mdHeadingId,
        noMermaid: i4,
        noPrettier: r4,
        sanitize: e4.sanitize,
        placeholder: e4.placeholder,
        noKatex: a2,
        scrollAuto: u2.scrollAuto,
        formatCopiedText: e4.formatCopiedText,
        autofocus: e4.autoFocus,
        disabled: e4.disabled,
        readonly: e4.readOnly,
        maxlength: e4.maxLength,
        autoDetectCode: e4.autoDetectCode,
        noHighlight: g4,
        onChange: (f3) => {
          e4.onChange ? e4.onChange(f3) : (o2.emit("update:modelValue", f3), o2.emit("onChange", f3));
        },
        onHtmlChanged: (f3) => {
          e4.onHtmlChanged ? e4.onHtmlChanged(f3) : o2.emit("onHtmlChanged", f3);
        },
        onGetCatalog: (f3) => {
          e4.onGetCatalog ? e4.onGetCatalog(f3) : o2.emit("onGetCatalog", f3);
        },
        onBlur: (f3) => {
          e4.onBlur ? e4.onBlur(f3) : o2.emit("onBlur", f3);
        },
        onFocus: (f3) => {
          e4.onFocus ? e4.onFocus(f3) : o2.emit("onFocus", f3);
        },
        onInput: (f3) => {
          e4.onInput ? e4.onInput(f3) : o2.emit("onInput", f3);
        },
        completions: e4.completions,
        catalogVisible: w2.value,
        theme: e4.theme,
        noImgZoomIn: e4.noImgZoomIn,
        onDrop: (f3) => {
          e4.onDrop ? e4.onDrop(f3) : o2.emit("onDrop", f3);
        },
        inputBoxWitdh: e4.inputBoxWitdh,
        onInputBoxWitdhChange: (f3) => {
          e4.onInputBoxWitdhChange ? e4.onInputBoxWitdhChange(f3) : o2.emit("onInputBoxWitdhChange", f3);
        }
      }, null), ((k3 = e4.footers) == null ? void 0 : k3.length) > 0 && createVNode(Ho, {
        modelValue: e4.modelValue,
        footers: e4.footers,
        defFooters: d3,
        scrollAuto: u2.scrollAuto,
        onScrollAutoChange: (f3) => u2.scrollAuto = f3
      }, null)]);
    };
  }
});
var ye = No;
ye.install = (e4) => (e4.component(ye.name, ye), e4.use(e3).use(y).use(i3).use(k2).use(N2), e4);

// node_modules/md-editor-v3/lib/es/config.mjs
var s2 = u["zh-CN"];
var t2 = u["en-US"];

// node_modules/md-editor-v3/lib/es/index.mjs
var import_copy_to_clipboard3 = __toESM(require_copy_to_clipboard(), 1);
var import_markdown_it3 = __toESM(require_markdown_it(), 1);
var import_markdown_it_task_lists3 = __toESM(require_markdown_it_task_lists(), 1);
export {
  y as DropdownToolbar,
  k2 as MdCatalog,
  ye as MdEditor,
  h5 as MdModal,
  N2 as MdPreview,
  i3 as ModalToolbar,
  e3 as NormalToolbar,
  p as allFooter,
  m as allToolbar,
  j as config,
  t2 as en_US,
  n as iconfontClassUrl,
  r as iconfontSvgUrl,
  s2 as zh_CN
};
/*! Bundled license information:

medium-zoom/dist/medium-zoom.esm.js:
  (*! medium-zoom 1.1.0 | MIT License | https://github.com/francoischalifour/medium-zoom *)
*/
//# sourceMappingURL=md-editor-v3.js.map
